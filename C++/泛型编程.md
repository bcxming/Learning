泛型编程的核心思想是编写可以应用于多种数据类型的代码。这意味着你可以编写一次代码，然后在不同的上下文中重用它，而无需为每种数据类型重复编写相似的代码。

C++ 中实现泛型编程的主要工具是模板。模板允许开发者定义依赖于类型或值的函数和类。模板分为函数模板和类模板。

### 函数模板

函数模板允许你定义一个可以接受不同类型参数的函数。当编译器遇到模板函数的调用时，它会根据传入的实际参数类型生成相应的函数实例。

```cpp
template<typename T>
T max(T a, T b) {
    return a > b ? a : b;
}
```

### 类模板

类模板允许你定义一个可以使用不同类型的类。当编译器遇到类模板的实例化时，它会根据提供的类型参数生成相应的类实例。

```cpp
template<typename T>
class Stack {
private:
    std::vector<T> elements;

public:
    void push(const T& item) {
        elements.push_back(item);
    }

    T pop() {
        T result = elements.back();
        elements.pop_back();
        return result;
    }

    bool empty() const {
        return elements.empty();
    }
};
```

示例 1: 泛型排序算法

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

template<typename Container>
void sort(Container& container) {
    std::sort(container.begin(), container.end());
}

int main() {
    std::vector<int> numbers = {5, 3, 1, 4, 2};
    std::vector<double> floats = {1.2, 3.4, 5.6, 7.8, 9.0};

    sort(numbers);
    sort(floats);

    for (auto num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    for (auto f : floats) {
        std::cout << f << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

示例 2: 泛型容器

```cpp
#include <vector>
#include <iostream>

template<typename T>
class Array {
private:
    std::vector<T> elements;

public:
    void add(const T& element) {
        elements.push_back(element);
    }

    T get(size_t index) const {
        return elements[index];
    }

    size_t size() const {
        return elements.size();
    }
};

int main() {
    Array<int> int_array;
    int_array.add(1);
    int_array.add(2);
    int_array.add(3);

    Array<double> double_array;
    double_array.add(1.1);
    double_array.add(2.2);
    double_array.add(3.3);

    for (size_t i = 0; i < int_array.size(); ++i) {
        std::cout << int_array.get(i) << " ";
    }
    std::cout << std::endl;

    for (size_t i = 0; i < double_array.size(); ++i) {
        std::cout << double_array.get(i) << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

