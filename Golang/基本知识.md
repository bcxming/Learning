## 入门

1、布尔型无法参与数值运算，也无法与其他类型进行转换

2、Go语言字符串和C++中string有所不同，其中最大的不同就是Go语言中字符串无法直接通过下标修改每一个字

符元素，只能通过重新构造新的字符串并赋值给原来的字符串变量实现

3、Go语言的字符有以下两种：

一种是uint8类型，或者叫byte类型，代表了一个ASCII码的一个字符。等价于C语言中unsigned char

一种是rune类型，代表UTF-8字符，底层是int32类型。用来处理中文、日文等复合字符。

4、定义方式

```go
var i int = 12    //明确定义i为int类型
var i =  12       //自动识别i为int类型
i := 12           //自动推断变量i为int类型

a, b = b, a   //交换了a和b的值

for i < 19 {  //等价于C语言中的while(i < 19)
    i++
}

//for-range遍历通道
for v := range c {
    fmt.Println(v)    //不断从通道中取数据，直到通道被关闭

```

5、**Go** 支持什么形式的类型转换?将整数转换为浮点数

```go
i := 55 //int
j := 67.8 //float64
sum := i + int(j)//j is converted to int
```

6、Golang 的引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。

### 函数

### goroutine相比线程的优势？

协程拥有极高的执行效率，子程序切换不是线程切换而是由程序自身控制，所以没有线程切换的开销。和多线程比，线程的数量越多，协程的性能优势就越明显。

协程不需要多线程的锁机制，因为只有一个线程，所以不存在同时写变量的冲突。在协程中控制共享资源不加锁，只需要判断状态就可以，执行效率比多线程要高。

### go语言中是如何实现继承的？

```go
type Person struct {
	Name string
	Age  int
}

type Student struct {
	Person
	School string
}
```

### for遍历多次执行goroutine会存在什么问题？

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func() {
            fmt.Println(i)
        }()
    }
    time.Sleep(1 * time.Second) // 等待所有goroutine执行完毕
}
```

实际结果可能为

```
5
5
5
5
5
```

解决办法

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func(i int) {
            fmt.Println(i)
        }(i)
    }
    time.Sleep(1 * time.Second) // 等待所有goroutine执行完毕
}
```

###  init函数是什么时候执行的？

**特点**：

- init函数先于main函数自动执行，不能被其他函数调用。
- init函数没有输入参数、返回值。
- 每个包可以有多个init函数，包的每个源文件也可以有多个init函数。
- go没有明确定义同一个包的init执行顺序，编程时程序不能依赖这个执行顺序。
- 不同包的init函数按照包导入的依赖关系决定执行顺序。

**作用**：

- 初始化不能采用初始化表达式初始化的变量。
- 程序运行前的注册。
- 实现sync.Once功能。

**执行顺序**：

go程序初始化先于main函数执行，由runtime进行初始化，初始化顺序如下：

- 初始化导入的包，包的初始化顺序并不是按导入顺序执行的，runtime需要解析包依赖关系，没有依赖的包最先初始化
- 初始化包作用域的变量，runtime解析变量依赖关系，没有依赖的变量最先初始化
- 执行包的init函数

**最终初始化顺序：变量初始化 -> init() -> main()**

### make和new区别

- `new(T)`：分配内存但不进行初始化，只返回指向类型`T`的指针。这通常用于需要显式地处理指针或零值初始化的情况。

  ```go
  // 使用 new 分配内存
  p := new(int)  // *int 类型的指针
  fmt.Println(*p) // 输出: 0 (int 的零值)
  ```

- `make(T, args...)`：用于slice、map和channel的内存分配和初始化，返回的是已经初始化好的值而非指针。

  ```go
  s := make([]int, 5)  // 创建长度和容量都为5的切片
  m := make(map[string]int) 
  c := make(chan int, 1)  
  ```

###  struct能不能比较？

不同类型的结构体，如果成员变量类型、变量名和顺序都相同，而且结构体没有不可比较字段时，那么进行显式类型转换后就可以比较，反之不能比较。

```go
a := StructA{X: 10, Y: "hello"}
b := StructB{X: 10, Y: "hello"}

// 显式类型转换后进行比较
if (StructA(b) == a) {
    fmt.Println("a and b are equal after type conversion")
} else {
    fmt.Println("a and b are not equal after type conversion")
}
```

同类型的struct分为两种情况：

- struct的所有成员都是可以比较的，则该strcut的不同实例可以比较

  ```go
  s1 := MyStruct{A: 1, B: "hello"}
  s2 := MyStruct{A: 1, B: "hello"}
  s3 := MyStruct{A: 2, B: "world"}
  
  fmt.Println(s1 == s2) // 输出: true
  fmt.Println(s1 == s3) // 输出: false
  ```

- struct中含有不可比较的成员，则该struct不可以比较

  ```go
  s1 := MyStructWithSlice{A: 1, B: []int{1, 2, 3}}
  s2 := MyStructWithSlice{A: 1, B: []int{1, 2, 3}}
  
  // 直接比较会导致编译错误，因为 slice 是不可比较的
  // fmt.Println(s1 == s2)
  ```

当需要比较两个struct内容时，最好使用reflect.DeepEqual方法进行比较，无论什么类型均可满足比较要求。

**不可比较的类型**

- slice，因为slice是引用类型，除非和nil比较：因为slice的元素是间接引用的，一个slice甚至可以包含自身，slice的变量实际是一个指针，使用 == 其实在判断地址
- map，和slice同理，如果要比较两个map只能通过循环遍历实现
- 函数类型，不能比较

### slice的底层实现

切片本身是一个只读对象，其工作机制类似数组指针的一种封装。

```go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

如果make函数初始化了一个太大的切片，该切片就会逃逸到堆区；如果分配了一个比较小的切片，就会被分配到栈区，切片大小的临界值默认为64KB，因此make([]int64, 1023) 和 make([]int64, 1024) 是完全不同的内存布局。

要确认变量是否逃逸，可以使用 Go 提供的编译器选项 `-gcflags="-m"` 来查看逃逸分析结果。例如：

```go
go build -gcflags="-m" main.go
```

###  slice和数组的区别？

**切片是指针类型，数组是值类型**

数组是一组内存空间连续的数据，一旦初始化长度大小就不会再改变，切片的长度可以进行扩展，当切片底层的数组容量不够时，切片会创建新的底层数组。

**切片比数组多一个属性容量（cap)**

### slice之间怎么进行比较？

```go
func equal(x, y []int) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true 
}
```

```go
func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false
    }
    for k, xv := range x {
        if yv, ok := y[k]; !ok || yv != xv {
            return false
        }
    }
    return true 
}
//map不能顺序读取，是因为他是无序的，想要有序读取，需要把key变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。
```

### 如何实现一个线程安全的map？

三种方式实现：

- 加读写锁
- 分片加锁
- sync.Map

大量并发读写的情况下，锁的竞争会很激烈，导致性能降低。如何解决这个问题？

尽量减少锁的粒度和锁的持有时间，减少锁的粒度，常用方法就是分片Shard，将一把锁分成几把锁，每个锁控制一个分片。

###  channel有哪些状态？

**nil**：未初始化的状态，只进行了声明，或者手动赋值为nil。

**active**：正常的channel，可读或者可写。

### channel发送数据和接收数据的过程？

**channel发送数据过程：**

- 检查 recvq 是否为空，如果不为空，则从 recvq 头部取一个 goroutine，将数据发送过去，并唤醒对应的 goroutine
- 如果 recvq 为空，则将数据放入到 buffer 中
- 如果 buffer 已满，则将要发送的数据和当前 goroutine 打包成 sudog 对象放入到 sendq中。并将当前 goroutine 置为 waiting 状态

**channel接收数据过程：**

- 检查sendq是否为空，如果不为空，且没有缓冲区，则从sendq头部取一个goroutine，将数据读取出来，并唤醒对应的goroutine，结束读取过程
- 如果sendq不为空，且有缓冲区，则说明缓冲区已满，则从缓冲区中首部读出数据，把sendq头部的goroutine数据写入缓冲区尾部，并将goroutine唤醒，结束读取过程
- 如果sendq为空，缓冲区有数据，则直接从缓冲区读取数据，结束读取过程
- 如果sendq为空，且缓冲区没数据，则只能将当前的goroutine加入到recvq,并进入waiting状态，等待被写goroutine唤醒

### channel的应用场景？

任务定时

```go
select {
    case <-time.After(time.Second)
}
```

**解耦生产者和消费者**

可以将生产者和消费者解耦出来，生产者只需要往channel发送数据，而消费者只管从channel中获取数据。

**控制并发数**

```go
ch := make(chan int, 5)
for _, url := range urls {
  go func() {
    ch <- 1
    worker(url)
    <- ch
  }
}
```

###  select的用途？

select可以理解为是在语言层面实现了和I/O多路复用相似的功能：监听多个描述符的读/写等事件，一旦某个描述符就绪(一般是读或者写事件发生了)，就能够将发生的事件通知给关心的应用程序去处理该事件。

- select语句只能用于信道的读写操作
- select中的case条件(非阻塞)是并发执行的，select会选择先操作成功的那个case条件去执行，如果多个同时返回，则随机选择一个执行，此时将无法保证执行顺序
- 对于case条件语句中，如果存在信道值为nil的读写操作，则该分支将被忽略，可以理解为从select语句中删除了这个case语句
- 如果有超时条件语句，判断逻辑为如果在这个时间段内一直没有满足条件的case，则执行这个超时case。如果此段时间内出现了可操作的case，则直接执行这个case。一般用超时语句代替了default语句
- 对于空的select{}，会引起死锁
- 对于for中的select{}, 可能会引起cpu占用过高的问题

### defer的使用场景？

**并发处理**

```go
var wg sync.WaitGroup

for i := 0; i < 2; i++ {
    wg.Add(1)
    go func() {
        defer wg.Done()
        // 程序逻辑
    }()
}
wg.Wait()
```

**锁场景**

```go
mu.RLock()
defer mu.RUnlock()
```

**资源释放**

```go
// new 一个客户端 client；
cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints})
if err != nil {
    log.Fatal(err)
}
// 释放该 client ，也就是说该 client 的声明周期就只在该函数中；
defer cli.Close()
```

**panic-recover**

```go
defer func() {
if v := recover(); v != nil {
  _ = fmt.Errorf("PANIC=%v", v)
}
}()
```



## 数据类型

### slice

**定义方式**

```go
//一维数组
var str [3]string
var str = [3]string{"hello", "world", ""}
var str = [...]string{"hello", "world", ""}
//二维数组
var arr [3][4]int    //定义三行四列的整型数组
for k, v := range str {
    fmt.Println(k, v)
}

//方式一：从数组生成切片
var a = [...]int{1, 2, 3}
var slice []int = a[1:2]   //从数组a生成切片slice
 
//方式二：从切片生成切片
var a = [...]int{1, 2, 3}
var slice []int = a[0:]
var ss []int = slice[1:2]
 
//方式三：直接声明新的切片
var slice []int
 
//方式四：使用make()函数构造切片
make([]T, size, cap)
//构造一个元素个数为size,容量为cap,类型为T的切片
a := make([]int, 2, 3)
 
//如果你执行 slice[1:4]，那么这个操作会返回从索引 1 开始到索引 3 结束的元素（不包含索引 4 的元素）
//slice[:3] 等同于 slice[0:3]
//slice[2:] 表示从索引 2 开始直到切片结束
//slice[0:0] 返回一个长度为 0 的空切片
 
//append
var slice[] int
slice = append(slice, 3)        //使用append()一次添加一个元素
slice = append(slice, 1, 2, 3)  //使用append()一次添加多个元素
 
team := []string{"pig", "chicken"}
slice = append(slice, team...)  //team后面加上...，表示将team整个添加到slice后面

//切片复制
src := []int{1, 2, 3, 4, 5}
dst := make([]int, len(src)) // 创建一个目标切片，长度与源切片相同
copy(dst, src)               // 将源切片的内容复制到目标切片

//go没有提供直接对切片删除元素的接口，只能通过append实现
seq := []string{"a", "b", "c", "d", "e"}
index := 2
seq = append(seq[:index], seq[index + 1:]...)
```

**nil切片和空切片指向的地址一样吗？**

切片的数据结构

```go
type SliceHeader struct {
 Data uintptr  //引用数组指针地址
 Len  int     // 切片的目前使用长度
 Cap  int     // 切片的容量
}
```

- nil切片和空切片指向的地址不一样。
- nil空切片引用数组指针地址为0（无指向任何实际地址），所有的空切片指向的数组引用地址都是一样的，且固定为一个值

**拷贝大切片一定比小切片代价大吗？**

并不是，所有切片的大小相同；

三个字段:切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字;

所以 拷贝大切片跟小切片的代价应该是一样的。

**for循环里面能append吗**

```go
func main() {
 s := []int{1,2,3,4,5}
 for _, v:=range s {
  s =append(s, v)
  fmt.Printf("len(s)=%v\n",len(s))
 }
}
```

- **不会死循环**，`for range`其实是`golang`的`语法糖`，在循环开始前会获取切片的长度 `len(切片)`，然后再执行`len(切片)`次数的循环。

**Go 中切片扩容的策略是这样的:**

首先判断，如果新申请容量大于2 倍的旧容量，最终容量就是新申请的容量 

否则判断，如果旧切片的⻓度小于1024，则最终容量就是旧容量的两倍 

否则判断，如果旧切片⻓度大于等于1024，则最终容量从旧容量开始循环增加原来的1/4,直到最终容量大于 等于新申请的容量

如果最终容量计算值溢出，则最终容量就是新申请容量

**扩容前后的 Slice 是否相同?** 

情况一:原数组还有容量可以扩容(实际容量没有填充完)，这种情况下，扩容以后的数组还是指向原来的数组，

对一个切片的操作可能影响多个指针指向相同地址的 Slice。 

情况二:原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷⻉过来，然后再执行 append()操作。这种情况丝毫不影响原数组。 要复制一个 Slice，最好使用 Copy函数。

**使切片线程安全的方法：**互斥锁，读写锁，原子操作，sync.once，sync.atomic，channel

### string

**字符串转成byte数组，会发生内存拷贝吗？**

严格来说，只要是发生类型强转都会发生内存拷贝

```go
func main() {
 a :="aaa"
 ssh := *(*reflect.StringHeader)(unsafe.Pointer(&a))
 b := *(*[]byte)(unsafe.Pointer(&ssh))  
 fmt.Printf("%v",b)
}
```

`StringHeader` 是`字符串`在go的底层结构

```go
type StringHeader struct {
 Data uintptr
 Len  int
}
```

`SliceHeader` 是`切片`在go的底层结构

```go
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
```

- 1.`unsafe.Pointer(&a)`方法可以得到变量`a`的地址。
- 2.`(*reflect.StringHeader)(unsafe.Pointer(&a))` 可以把字符串a转成底层结构的形式。
- 3.`(*[]byte)(unsafe.Pointer(&ssh))` 可以把ssh底层结构体转成byte的切片的指针。
- 4.再通过 `*`转为指针指向的实际内容。

```go
func BytesToStr(data []byte) string {
	return *(*string)(unsafe.Pointer(&data))
}
func StrToBytes(data string) []byte {
	str := (*reflect.StringHeader)(unsafe.Pointer(&data))
	bs := reflect.SliceHeader{
		Data: str.Data,
		Len:  str.Len,
		Cap:  str.Len,
	}

	return *(*[]byte)(unsafe.Pointer(&bs))
}
```

**翻转含有中文、数字、英文字母的字符串**

```go
func main() {
  src := "你好abc啊哈哈"
  dst := reverse([]rune(src))
}

func reverse(s []rune) []rune {
  for i, j := 0, len(s)-1; i < j; i++, j-- {
  s[i], s[j] = s[j], s[i]
  }
  return s
}
```

`rune`关键字，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），可表示更多的字符



### chan

channel 中使用了 ring buffer(环形缓冲区)来缓存写入的数据。ring buffer 有很多好处，而且非常适合用来实现 FIFO 式的固定⻓度队列。

Go语言中，不要通过共享内存来通信，而要通过通信来实现内存共享

**创建通道**

你可以使用内置的 `make` 函数来创建一个通道：

```go
ch := make(chan int) 
```

这里我们创建了一个传递 `int` 类型的无缓冲通道。

发送和接收数据

- **发送数据**：使用 `<-` 操作符将数据发送到通道。
- **接收数据**：同样使用 `<-` 操作符从通道接收数据。

**缓冲通道**

默认情况下，通道是无缓冲的，这意味着只有当有接收者准备好接收数据时，发送操作才会完成。如果需要，可以创建带缓冲的通道，这样即使没有立即接收者，发送操作也能完成，直到缓冲区满为止。

```go
package main 
import (    
  "fmt" 
) 
func main() {    
  ch := make(chan int, 2)  // 创建一个容量为2的缓冲通道  
  ch <- 1    
  ch <- 2     
  fmt.Println(<-ch)  // 输出: 1    
  fmt.Println(<-ch)  // 输出: 2 
} 
```

**关闭通道**

你可以使用 `close` 函数来关闭通道，表示不再向该通道发送更多的数据。关闭后的通道仍然可以接收剩余的数据，但不能再发送。

**Select语句**

`select` 语句允许一个 goroutine 等待多个通信操作。当其中一个操作完成时，程序就会执行相应的分支。

```go
package main 
import (    
  "fmt"    
  "time" 
) 
func main() {    
  ch1 := make(chan string)    
  ch2 := make(chan string)     
  go func() {        
    time.Sleep(1 * time.Second)        
    ch1 <- "one"    
  }  
  go func() {        
    time.Sleep(2 * time.Second)        
    ch2 <- "two"    
	}
  for i := 0; i < 2; i++ {        
    select {        
      case msg1 := <-ch1:  
      fmt.Println("Received", msg1)        
      case msg2 := <-ch2:   
      fmt.Println("Received", msg2)        
      }    
  } 
} 
```

这个例子展示了如何使用 `select` 语句同时等待两个通道的消息，并根据哪个通道先收到消息来处理不同的情况。

**总结**

- 使用 `make` 函数创建通道。
- 使用 `<-` 操作符发送和接收数据。
- 可以创建带缓冲的通道以支持异步发送。
- 使用 `close` 函数关闭通道。
- 使用 `select` 语句等待多个通道的通信操作。

channel存在3种状态:

nil，未初始化的状态，只进行了声明，或者手动赋值为nil 

active，正常的channel，可读或者可写 

closed，已关闭，千万不要误认为关闭channel后，channel的值是nil

channel特性：

1. 给一个 nil channel 发送数据，造成永远阻塞

2. 从一个 nil channel 接收数据，造成永远阻塞
3. 给一个已经关闭的 channel 发送数据，引起 panic
4. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值 5. 无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的
5. 关闭一个 nil channel 将会发生 panic

如何判断其已经被关闭

```go
if v, ok := <-ch; !ok {
	fmt.Println("channel 已关闭，读取不到数据")
}
```



### map

**定义方式**

```go
//只遍历值
for _, v :range scene {
......
}
 
//只遍历键
for k : range scene {
......
}

delete(map, key)               //从map中删除key的元素
```

使用 `Store` 方法将键值对存储到 `sync.Map` 中：

```go
m.Store("key1", "value1")
m.Store(2, 3.14) // 支持不同类型的键和值
```

使用 `Load` 方法根据键加载对应的值。如果该键存在，则返回值和 true；否则返回 nil 和 false：

```go
if value, ok := m.Load("key1"); ok {
    fmt.Println("key1:", value)
} else {
    fmt.Println("key1 not found")
}
```

使用 `Delete` 方法删除指定键的键值对：

```go
m.Delete("key1")
```

使用 `LoadOrStore` 方法，如果键已存在则返回其对应的值和 true，否则存储新的键值对并返回新值和 false：

```go
value, loaded := m.LoadOrStore("key2", "new_value")
fmt.Println("Value:", value, "Loaded:", loaded)
```

使用 `Range` 方法遍历 `sync.Map` 中的所有键值对。注意：`Range` 的回调函数的参数是键和值，且如果回调函数返回 false 则停止遍历：

```go
m.Range(func(key, value interface{}) bool {
    fmt.Println("Key:", key, "Value:", value)
    return true // 返回 true 继续遍历，返回 false 停止遍历
})
```

**map的底层哈希表是怎么查询的？**

1. **哈希函数**：
   - 每个键通过一个哈希函数转换成一个哈希值。
   - 哈希函数的目的是将不同的键尽可能均匀地分布到哈希表的各个桶（bucket）中。
2. **定位桶**：
   - 使用哈希值计算出具体应该放入或查找的桶的位置。通常，这一步骤是通过取模运算（hash % bucket_count）完成的。
   - 在Go语言中，每个桶可以包含多个键值对。
3. **遍历桶**：
   - 如果桶中的元素较多，会采用链地址法或者其他方法来解决冲突。
   - 遍历桶中的所有元素，通过比较键找到目标键值对。
4. **扩展机制**：
   - 当负载因子超过一定阈值时，哈希表会自动进行扩展，即增加桶的数量并重新分配已有的键值对，以减少冲突。

### list

**定义方式**

```go
//方式一：通过container/list包的New方法初始化list
l := list.New()
//方式二:通过声明初始化list
var l list.List
 
//在列表中插入元素
l := list.New()
l.PushBack("first")              //从链表尾部插入元素“first”
element := l.PushFront(67)       //从链表头部插入元素67
l.InsertAfter("high", element)   //在element后插入元素
l.InsertBefore("noon", element)  //在element前插入元素
 
//从链表中删除元素
l.Remove(element)
 
//遍历列表
for i := l.Front(); i != nil; i = i.Next() {
    fmt.Println(i.Value)
```



## 高级特性

### 结构体

**go struct能不能比较**

- 相同struct类型的可以比较

- 不同struct类型的不可以比较,编译都不过，类型不匹配



### 反射

Go 语言中的反射（reflection）是一种强大的编程技术，允许程序在运行时检查和操作对象的类型和值。反射可以用来查看变量的类型信息、动态调用方法以及创建新的实例等。

在 Go 中，反射主要通过 `reflect` 包提供的一组函数和类型来实现。以下是一些基本概念和示例，帮助你理解 Go 的反射机制：

**基本概念**

1. **Type**：表示一个 Go 类型，可以通过 `reflect.TypeOf` 函数获取。
2. **Value**：表示一个 Go 值，可以通过 `reflect.ValueOf` 函数获取。
3. **Kind**：表示具体的类别，比如整数、浮点数、结构体、指针等，可以通过 `Type.Kind` 方法获取。

**获取类型和值**

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
func main() {    
  var x float64 = 3.4    
  fmt.Println("type:", reflect.TypeOf(x))   
  // 输出: type: float64    
  fmt.Println("value:", reflect.ValueOf(x)) 
  // 输出: value: 3.4 
} 
```

**操作值**

通过 `reflect.Value` 可以对值进行各种操作，如修改值、调用方法等。

**修改值**

要修改值，需要传递一个可寻址的变量（通常是指针）。

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
func main() {    
  var x float64 = 3.4    
  p := reflect.ValueOf(&x) // 注意这里传入的是 &x    
  v := p.Elem()        
  if v.CanSet() {        
    v.SetFloat(7.1)    
  }    
  fmt.Println(x) // 输出: 7.1 
} 
```

**动态调用方法**

通过反射，你可以在运行时动态地调用方法。

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
type MyStruct struct{} 
func (m MyStruct) Hello(name string){ fmt.Println("Hello,", name) 
} 
func main() {    
  m := MyStruct{}    
  v := reflect.ValueOf(m)    
  method := v.MethodByName("Hello")        
  args := []reflect.Value{
    reflect.ValueOf("World")
  }    
  method.Call(args) // 输出: Hello, World 
} 
```

**总结**

- **Type 和 Value**：`reflect.TypeOf` 返回类型信息，`reflect.ValueOf` 返回值信息。
- **修改值**：需要传递指针并使用 `Elem()` 获取实际值，通过 `CanSet` 检查是否可设置。
- **动态调用方法**：使用 `MethodByName` 查找方法，并使用 `Call` 调用。
- **创建新实例**：使用 `reflect.New` 创建类型的新实例。

如果你只需要处理固定类型的数据，并且追求高性能和简洁的代码，那么不使用反射是更好的选择。

如果你需要编写高度通用的代码，并且愿意接受一定的性能损失和复杂度增加，那么反射是一个非常强大的工具。

### context

以下是一些常见的`context`类型及其使用方式：

`context.Background()`：返回一个空的上下文，这个上下文通常在主函数、初始化或测试代码中作为顶级的上下文使用

```go
ctx := context.Background()
```

`context.TODO()`：返回一个空的上下文，但它表示目前还不知道应该使用什么样的上下文。这种情况下可以用`TODO`来占位，将来再替换成具体的上下文

```go
ctx := context.TODO()
```

`context.WithCancel(parent)`：创建一个可取消的上下文，并返回该上下文和一个取消函数。当调用取消函数时，该上下文会发送取消信号给所有基于它衍生的上下文

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel() // 确保在不再需要的时候调用取消函数

go func() {
    select {
    case <-ctx.Done():
        fmt.Println("Context canceled")
    }
}()
```

`context.WithDeadline(parent, deadline)`：创建一个带有截止时间的上下文。如果到了指定的时间点，上下文会自动发送取消信号

```go
deadline := time.Now().Add(5 * time.Second)
ctx, cancel := context.WithDeadline(context.Background(), deadline)
defer cancel()

go func() {
    select {
    case <-ctx.Done():
        fmt.Println("Context deadline exceeded")
    }
}()
```

`context.WithValue(parent, key, value)`：创建一个携带值的上下文，可以将键值对存储在上下文中，以便在不同的Goroutine之间传递数据。注意，`key`应当是一个非导出的、自定义类型，以避免冲突。

```go
type MyKey string
const key MyKey = "myKey"

ctx := context.WithValue(context.Background(), key, "myValue")

go func(ctx context.Context) {
    if val, ok := ctx.Value(key).(string); ok {
        fmt.Println("Value:", val)
    }
}(ctx)
```

### 并发编程

**Golang 中常用的并发模型?**

- 同步并发控制

```go
func main() {
    ch := make(chan struct{})
    go func() {
        fmt.Println("start working")
        time.Sleep(time.Second * 1)
        ch <- struct{}{}
}()
<-ch
    fmt.Println("finished")
}
```

- 通过sync包中的WaitGroup实现并发控制

```go
//Add, 可以添加或减少 goroutine的数量.
//Done, 相当于Add(-1).
//Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.
func main(){
    var wg sync.WaitGroup
    var urls = []string{
        "http://www.golang.org/",
        "http://www.google.com/",
    }
    for _, url := range urls {
        wg.Add(1)
        go func(url string) {
            defer wg.Done()
            http.Get(url)
        }(url)
}
wg.Wait() }
```

- Context上下文，实现并发控制

通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。 所以我们需要 一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context

```go
func main() {
    // 创建一个带有超时的context
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    go func(ctx context.Context) {
        select {
        case <-ctx.Done():
            fmt.Println("Context canceled:", ctx.Err())
        }
    }(ctx)

    // 模拟一些工作
    time.Sleep(1 * time.Second)

    // 检查context是否已经过期或者被取消
    if err := ctx.Err(); err != nil {
        fmt.Println("Error:", err)
    }

    // 获取context的截止时间
    deadline, ok := ctx.Deadline()
    if ok {
        fmt.Println("Deadline set to:", deadline)
    } else {
        fmt.Println("No deadline set")
    }

    // 使用Value传递数据
    key := "exampleKey"
    valueCtx := context.WithValue(ctx, key, "exampleValue")

    val := valueCtx.Value(key)
    fmt.Println("Value from context:", val)
}

```

**协程，线程，进程的区别**

- 进程：
  - 独立内存空间
  - 进程间通信
  - 上下文切换开销大（栈、寄存器、虚拟内存、文件句柄）
  - 资源分配的基本单位

- 线程：
  - 不独立拥有内存
  - 共享内存通信
  - 开销小(堆、栈、寄存器)
  - 调度的基本单位

- 协程：
  - 用户态的轻量级线程
  - 协程不是被操作系统内核所管理，而是由程序所控制

- 区别：系统开销、资源拥有、多进场比多线程稳定

**协程和线程的区别**

**调度上的开销区别：**OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存 中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换:即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。

**栈空间：**goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到 1GB

**通信**：使用channel

**死锁**

条件：互斥、等待、不可剥夺、环路

情况：

- 同一个线程先后两次调用lock
- 两个线程相互等待对方

预防死锁：

- 资源一次性分配
- 阻塞时释放已有资源
- 有序分配资源

**说Go中的锁有哪些?**

互斥锁、读写锁、sync.Map安全锁

**怎么限制Goroutine的数量**

1、通道

```go
func worker(id int, wg *sync.WaitGroup, semaphore chan struct{}) {
    defer wg.Done()

    // 占用一个信号量
    semaphore <- struct{}{}
    fmt.Printf("Worker %d is starting\n", id)
    time.Sleep(2 * time.Second) // 模拟工作
    fmt.Printf("Worker %d is done\n", id)
    
    // 释放一个信号量
    <-semaphore
}

func main() {
    var wg sync.WaitGroup
    maxGoroutines := 3
    semaphore := make(chan struct{}, maxGoroutines)

    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go worker(i, &wg, semaphore)
    }

    wg.Wait()
}

```

**defer**

不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反

**WaitGroup** 用法

一个 WaitGroup 对象可以等待一组协程结束。使用方法是:

- main 协程通过调用 wg.Add(delta int)设置 worker 协程的个数，然后创建 worker 协程; 
- worker 协程执行结束以后，都要调用 wg.Done();
- main 协程调用 wg.Wait()且被 block，直到所有 worker 协程全部执行结束后返回。

## go进阶

`for`循环`select`时，如果通道已经关闭会怎么样？如果`select`中的`case`只有一个，又会怎么样？

- `select`中如果任意某个通道有值可读时，它就会被执行，其他被忽略。
  - 其中如果通道被关闭了，那么会返回0，false，然后会一直执行，除非你遇到false就把通道关闭了

- 如果没有`default`字句，`select`将有可能阻塞，直到某个通道有值可以运行，所以`select`里最好有一个`default`，否则将有一直阻塞的风险。

对**已经关闭**的的 `chan` 进行读写，会怎么样？**为什么？**

- 读**已经关闭**的 `chan` 能一直读到东西，但是读到的内容根据通道内`关闭前`是否有元素而不同。
  - 如果 `chan` 关闭前，`buffer` 内有元素**还未读** , 会正确读到 `chan` 内的值，且返回的第二个 bool 值（是否读成功）为 `true`。
  - 如果 `chan` 关闭前，`buffer` 内有元素**已经被读完**，`chan` 内无值，接下来所有接收的值都会非阻塞直接成功，返回 `channel` 元素的**零值**，但是第二个 `bool` 值一直为 `false`。
- 写**已经关闭**的 `chan` 会 `panic`

**对未初始化的的chan进行读写，会怎么样?为什么?**

1. **读取未初始化的channel**：如果你尝试从一个未初始化的channel读取数据（即 `var ch chan int`），程序会发生阻塞，因为这个channel没有被分配内存，也没有任何发送者可以向它发送数据。所以，读取操作将永远等待。
2. **写入未初始化的channel**：同样，如果你尝试向一个未初始化的channel发送数据，程序也会发生阻塞，因为没有接收者能够从这个channel读取数据，而且该channel无法接受任何数据。

能说说uintptr和unsafe.Pointer的区别吗？

- unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；
- 而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；
- unsafe.Pointer 可以和 普通指针 进行相互转换；
- unsafe.Pointer 可以和 uintptr 进行相互转换。

```go
func main() {
 var w *W = new(W)
 //这时w的变量打印出来都是默认值0，0
 fmt.Println(w.b,w.c)

 //现在我们通过指针运算给b变量赋值为10
 b := unsafe.Pointer(uintptr(unsafe.Pointer(w)) + unsafe.Offsetof(w.b))
 *((*int)(b)) = 10
 //此时结果就变成了10，0
 fmt.Println(w.b,w.c)
}
```

**怎么避免内存逃逸？**

内存逃逸（Memory Escape）是指变量从栈上分配转移到堆上分配的现象。这通常会导致性能下降，因为堆上的内存分配和垃圾回收比栈上的要慢。

能引起变量逃逸到堆上的**典型情况**：

- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

避免方法：

- **尽量使用局部变量**
- **传值而不是传引用**：在函数调用时，尽量传递值类型，而不是指针或引用类型。如果传递的是指针，很可能会导致被传递的变量逃逸到堆上。
- **使用`sync.Pool`进行对象复用**
- **分析逃逸信息：**go build -gcflags="-m" yourfile.go

**GC垃圾回收？**

不进行垃圾回收：

- 内存检测工具
- 智能指针(c++)

进行垃圾回收：

- 引用计数：python
  - 频繁更新引用计数降低性能
  - 循环引用
- 标记-清除
- 分代收集

Golang 1.5后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法

整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。

1. 先STW，做一些准备工作，比如启动write barrier。然后取消STW，**将扫描任务作为多个并发的 goroutine立即入队给调度器，进而被CPU处理**
   - **入队给调度器**：这些新创建的标记任务会被加入到Go运行时系统的调度队列中，由调度器分配给不同的CPU核心来执行。
   - **并发执行**：由于这些标记任务是并发执行的，它们可以利用多核CPU的优势，提高标记阶段的效率，并减少对应用程序的影响。
2. 第一轮先扫描root对象，包括全局指针和 goroutine 栈上的指针，标记为灰色放入队列
3. 第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后， 这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象;
4. 第三轮再次STW，将第二轮过程中新增对象申请的内存进行标记(灰色)，这里使用了write barrier(写屏障)去记录

Golang gc 优化的核心就是尽量使得 STW(Stop The World) 的时间越来越短。

**GC** **如何调优**

通过 go tool pprof 和 go tool trace 等工具

- 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率
- 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷⻉
- 需要时，增大 GOGC 的值，降低 GC 的运行频率

**协程如何调度？**

协程：协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢 复先前保存的寄存器上下文和栈。

进入上一次离开时所处逻辑流的位置。 线程和进程的 操作是由程序触发系统接口，最后的执行者是系统;协程的操作执行者则是用户自身程序，goroutine也是协程

GMP模型：

- M代表内核级线程，goroutine就是跑在M之上的，M是一个很大的结构，里面维护小对象内存cache(mcache)、当前执行的goroutine、随机数发生器等等非常多的信息
- G，代表一个goroutine，它有自己的栈，正在等待的channel等等，用于调度
- P，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine 
- Sched:代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。

**GMP** 调度过程中存在哪些阻塞:

- I/O，select
- block on syscall
- channel
- 等待锁
- runtime.Gosched()

## go高级

### GMP

go 语言中的协程 goroutine 的缩写，相当于操作系统中的进程控制块。其中存着 goroutine 的运行时栈信息，CPU 的一些寄存器的值以及执行的函数指令等。sched字段保存了 goroutine 的上下文。goroutine 切换的时候不同于线程有 OS 来负责这部分数据，而是由一个 gobuf 结构体来保存。

```go
type g struct {
  stack       stack   		// 描述真实的栈内存，包括上下界

  m              *m     	// 当前的 m
  sched          gobuf   	// goroutine 切换时，用于保存 g 的上下文      
  param          unsafe.Pointer // 用于传递参数，睡眠时其他 goroutine 可以设置 param，唤醒时该goroutine可以获取
  atomicstatus   uint32
  stackLock      uint32 
  goid           int64  	// goroutine 的 ID
  waitsince      int64 		// g 被阻塞的大体时间
  lockedm        *m     	// G 被锁定只在这个 m 上运行
}
```

gobuf 保存了当前的栈指针，计数器，还有 g 自身，这里记录自身 g 的指针的目的是为了**能快速的访问到 goroutine 中的信息**。gobuf 的结构如下

```go
type gobuf struct {
    sp   uintptr
    pc   uintptr
    g    guintptr
    ctxt unsafe.Pointer
    ret  sys.Uintreg
    lr   uintptr
    bp   uintptr // for goEXPERIMENT=framepointer
}
```

M代表一个操作系统的主线程，对内核级线程的封装，数量对应真实的 CPU 数。一个 M 直接关联一个 os 内核线程，用于执行 G。M 会优先从关联的 P 的本地队列中直接获取待执行的 G。M 保存了 M 自身使用的栈信息、当前正在 M上执行的 G 信息、与之绑定的 P 信息。

结构体 M 中，curg代表结构体M当前绑定的结构体 G ；g0 是带有调度栈的 goroutine，普通的 goroutine 的栈是在**堆上**分配的可增长的栈，但是 g0 的栈是 **M 对应的线程**的栈。与调度相关的代码，会先切换到该 goroutine 的栈中再执行。

```go
type m struct {
    g0      *g     				// 带有调度栈的goroutine

    gsignal       *g         	// 处理信号的goroutine
    tls           [6]uintptr 	// thread-local storage
    mstartfn      func()
    curg          *g       		// 当前运行的goroutine
    caughtsig     guintptr 
    p             puintptr 		// 关联p和执行的go代码
    nextp         puintptr
    id            int32
    mallocing     int32 		// 状态

    spinning      bool 			// m是否out of work
    blocked       bool 			// m是否被阻塞
    inwb          bool 			// m是否在执行写屏蔽

    printlock     int8
    incgo         bool
    fastrand      uint32
    ncgocall      uint64      	// cgo调用的总数
    ncgo          int32       	// 当前cgo调用的数目
    park          note
    alllink       *m 			// 用于链接allm
    schedlink     muintptr
    mcache        *mcache 		// 当前m的内存缓存
    lockedg       *g 			// 锁定g在当前m上执行，而不会切换到其他m
    createstack   [32]uintptr 	// thread创建的栈
}
```

Processor 代表了 M 所需的上下文环境，代表 M 运行 G 所需要的资源。是处理用户级代码逻辑的处理器，可以将其看作一个局部调度器使 go 代码在一个线程上跑。当 P 有任务时，就需要创建或者唤醒一个系统线程来执行它队列里的任务，所以 P 和 M 是相互绑定的。P 可以根据实际情况开启协程去工作，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。

```go
type p struct {
    lock mutex

    id          int32
    status      uint32 		// 状态，可以为pidle/prunning/...
    link        puintptr
    schedtick   uint32     // 每调度一次加1
    syscalltick uint32     // 每一次系统调用加1
    sysmontick  sysmontick 
    m           muintptr   // 回链到关联的m
    mcache      *mcache
    racectx     uintptr

    goidcache    uint64 	// goroutine的ID的缓存
    goidcacheend uint64

    // 可运行的goroutine的队列
    runqhead uint32
    runqtail uint32
    runq     [256]guintptr

    runnext guintptr 		// 下一个运行的g

    sudogcache []*sudog
    sudogbuf   [128]*sudog

    palloc persistentAlloc // per-P to avoid mutex

    pad [sys.CacheLineSize]byte
}
```

### GMP的调度流程？

![img](https://pic.imgdb.cn/item/63e223e84757feff33526e36.jpg)

- 每个 P 有个局部队列，局部队列保存待执行的goroutine（流程 2），当 M 绑定的 P 的的局部队列已经满了之后就会把 goroutine 放到全局队列（流 程 2-1）
- 每个 P 和一个 M 绑定，M 是真正的执行 P 中 goroutine 的实体（流程 3）， M 从绑定的 P 中的局部队列获取 G 来执行
- 当 M 绑定的 P 的局部队列为空时，M 会从全局队列获取到本地队列来执行 G （流程 3.1），当从全局队列中没有获取到可执行的 G 时候，M 会从其他 P 的局部队列中偷取 G 来执行（流程 3.2），这种从其他 P 偷的方式称为 work stealing
- 当 G 因系统调用（syscall）阻塞时会阻塞 M，此时 P 会和 M 解绑即 hand off，并寻找新的 idle 的 M，若没有 idle 的 M 就会新建一个 M（流程 5.1）
- 当 G 因 channel 或者 network I/O 阻塞时，不会阻塞 M，M 会寻找其他 runnable 的 G；当阻塞的 G 恢复后会重新进入 runnable 进入 P 队列等待执 行（流程 5.3）

### P和M的个数？

- P: 由启动时环境变量 `$GOMAXPROCS` 或者是由 `runtime`的方法`GOMAXPROCS()`决定。这意味着在程序执行的任意时刻都只有`$GOMAXPROCS`个goroutine在同时运行。
- M:
  - Go 语言本身的限制：Go 程序启动时，会设置 M 的最大数量，默认 10000，但是内核很难支持这么多的线程数，所以这个限制可以忽略。
  - runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量。
  - 一个 M 阻塞了，会创建新的 M。

M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来

### P和M何时会被创建？

P: 在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。

M: 没有足够的 M 来关联 P 并运行其中的可运行的 G 时创建。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M

###  goroutine创建流程？

在调用go func()的时候，会调用runtime.newproc来创建一个goroutine，这个goroutine会新建一个自己的栈空间，同时在G的sched中维护栈地址与程序计数器这些信息（备注：这些数据在goroutine被调度的时候会被用到。准确的说该goroutine在放弃cpu之后，下一次在重新获取cpu的时候，这些信息会被重新加载到cpu的寄存器中。）

创建好的这个goroutine会被放到它所对应的内核线程M所使用的上下文P中的run_queue中，等待调度器来决定何时取出该goroutine并执行，通常调度是按时间顺序被调度的，这个队列是一个先进先出的队列

### goroutine什么时候会被挂起

- waitReasonChanReceiveNilChan：对未初始化的 channel 进行读操作
- waitReasonChanSendNilChan：对未初始化的 channel 进行写操作
- 在 main goroutine 发生 panic 时，会触发
- 在调用关键字 select 时会触发
- 在调用关键字 select 时，若一个 case 都没有，会直接触发
- 在 channel 进行读操作，会触发
- 在 channel 进行写操作，会触发
- sleep 行为，会触发
- IO 阻塞等待时，例如：网络请求等
- 在垃圾回收时，主要场景是 GC 标记终止和标记阶段时触发
- GC 清扫阶段中的结束行为，会触发
- 信号量处理结束时，会触发

###  同时启动了一万个goroutine，会如何调度？

一万个G会按照P的设定个数，尽量平均地分配到每个P的本地队列中。如果所有本地队列都满了，那么剩余的G则会分配到GMP的全局队列上。接下来便开始执行GMP模型的调度策略：

- **本地队列轮转**：每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队首中重新取出一个G进行调度。
- **系统调用**：P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用。当该G即将进入系统调用时，对应的M由于陷入系统调用而进被阻塞，将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。
- **工作量窃取**：多个P中维护的G队列有可能是不均衡的，当某个P已经将G全部执行完，然后去查询全局队列，全局队列中也没有新的G，而另一个M中队列中还有3很多G待运行。此时，空闲的P会将其他P中的G偷取一部分过来，一般每次偷取一半

### goroutine内存泄漏和处理？

**原因**：

Goroutine 是轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的 goroutine 并复用这部分内存，就会造成内存泄漏的现象。造成泄露的大多数原因有以下三种：

- Goroutine 内正在进行 channel/mutex 等读写操作，但由于逻辑问题，某些情况下会被一直阻塞。
- Goroutine 内的业务逻辑进入死循环，资源一直无法释放。
- Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待。

**解决方法**：

- 使用channel
  - 1、使用channel接收业务完成的通知
  - 2、业务执行阻塞超过设定的超时时间，就会触发超时退出
- 使用pprof排查
  - pprof是由 Go 官方提供的可用于收集程序运行时报告的工具，其中包含 CPU、内存等信息。当然，也可以获取运行时 goroutine 堆栈信息。

**在不执行`resp.Body.Close()`的情况下，泄漏了吗？如果泄漏，泄漏了多少个`goroutine`?**

```go
func main() {
 num := 6
 for index := 0; index < num; index++ {
  resp, _ := http.Get("https://www.baidu.com")
  _, _ = ioutil.ReadAll(resp.Body)
 }
 fmt.Printf("此时goroutine个数= %d\n", runtime.NumGoroutine())
}
```

- 虽然执行了 `6` 次循环，而且每次都没有执行 `Body.Close()` ,就是因为执行了`ioutil.ReadAll()`把内容都读出来了，连接得以复用，因此只泄漏了一个`读goroutine`和一个`写goroutine`，最后加上`main goroutine`，所以答案就是`3个goroutine`。
- 从另外一个角度说，正常情况下我们的代码都会执行 `ioutil.ReadAll()`，但如果此时忘了 `resp.Body.Close()`，确实会导致泄漏。但如果你**调用的域名一直是同一个**的话，那么只会泄漏一个 `读goroutine` 和一个`写goroutine`，**这就是为什么代码明明不规范但却看不到明显内存泄漏的原因**。

**内存泄露常见情况：**

- 获取长字符串中的一段导致长字符串未释放

  ```go
  longString := "This is a very long string that we are going to slice."
  shortString := longString[10:20] // 子字符串共享了longString的底层数组
  ```

- 同样，获取长slice中的一段导致长slice未释放

  ```go
  longSlice := make([]int, 10000)
  shortSlice := longSlice[5000:5010] // 子切片共享了longSlice的底层数组
  ```

- 在长slice新建slice导致泄漏

- goroutine泄漏

- time.Ticker未关闭导致泄漏

- Finalizer导致泄漏

- Deferring Function Call导致泄漏

## 包

https://www.csview.cn/cpp/

### json

**基本用法**

```go
type Person struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}
//结构体转json
p := Person{Name: "Alice", Age: 30}
jsonData, _ := json.Marshal(p)
fmt.Println(string(jsonData))
//json转结构体
jsonData := `{"name":"Bob","age":25}`
var p Person
err := json.Unmarshal([]byte(jsonData), &p)
//空接口处理未知json
jsonData := `{"name":"Charlie","age":35,"city":"New York"}`
var result map[string]interface{}
_ := json.Unmarshal([]byte(jsonData), &result)
fmt.Println(result)
name := result["name"].(string)
age := result["age"].(float64) // JSON numbers are always float64 in Go
city := result["city"].(string)
fmt.Printf("Name: %s, Age: %.0f, City: %s\n", name, age, city)

```

**`json`包里使用的时候，结构体里的变量不加`tag`能不能正常转成`json`里的字段？**

- 如果变量`首字母小写`，则为`private`。无论如何`不能转`，因为取不到`反射信息`。
- 如果变量`首字母大写`，则为`public`。
  - `不加tag`，可以正常转为`json`里的字段，`json`内字段名跟结构体内字段`原名一致`。
  - `加了tag`，从`struct`转`json`的时候，`json`的字段名就是`tag`里的字段名，原字段名已经没用。

```go
type J struct {
    a string             //小写无tag
    b string `json:"B"`  //小写+tag
    C string             //大写无tag
    D string `json:"DD"` //大写+tag
}
//转为json前j结构体的内容 = {a:1 b:2 C:3 D:4}
//转为json后的内容 = {"C":"3","DD":"4"}
```

**`json`包里使用的时候，会结构体里的字段边上加`tag`，有没有什么办法可以获取到这个`tag`的内容呢？**

```go
type J struct {
    a string //小写无tag
    b string `json:"B"` //小写+tag
    C string //大写无tag
    D string `json:"DD" otherTag:"good"` //大写+tag
}
//printTag方法传入的是j的指针
func printTag(stru interface{}) {
  //reflect.TypeOf(stru).Elem()获取指针指向的值对应的结构体内容
    t := reflect.TypeOf(stru).Elem()
    for i := 0; i < t.NumField(); i++ {
        fmt.Printf("结构体内第%v个字段 %v 对应的json tag是 %v , 还有otherTag？ = %v \n", i+1, t.Field(i).Name, t.Field(i).Tag.Get("json"), t.Field(i).Tag.Get("otherTag"))
 }
}
```

### http

在Go语言中使用`net/http`包时，可以为同一路由同时支持GET和POST请求。你可以通过在处理函数中检查HTTP方法来实现这一点。
