## 二叉树

### 二叉树的最大深度

自己写的递归秒杀

```cpp
int maxDepth(TreeNode* root) {
    if(root==nullptr)return 0;
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    return max(left,right)+1;
}
```

### 翻转二叉树

自己写的

```cpp
TreeNode* invertTree(TreeNode* root) {
    if(root==nullptr)return root;
    swap(root->left,root->right);
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

### 对称二叉树

如果直接用层序遍历，那么放在队列中的节点不易比较，因此需要按照比较的顺序将其放进去

## 图论

### 岛屿数量

要么修改岛屿中的数字，要么用额外的布尔空间去记录是否被访问

## 回溯

### 全排列

简单的回溯，但是用到了辅助树组来记录是否被访问

## 二分查找

### 搜索插入位置

闭区间分情况考虑写代码：

1、都小于返回0

2、都大于返回数组长度

3、在中间返回看left和right如何移动

### 搜索二维矩阵

就是从左下角开始搜索

## 栈

### 有效的括号

遇到（，就插入），方便弹出的时候进行比较，同时注意栈为空的情况

## 堆

### 手写堆

### 数组中的第k个最大元素

改进版快排能做到0(n),如果基于堆，那么平均复杂度就是0(logn)

```cpp
int findKthLargest(vector<int>& nums, int k) {
    return quickSelect(nums,k);
}
int quickSelect(vector<int>& nums,int k){
  //增加算法稳定性 0(n)，0（logn）
    int pivot = nums[rand()%nums.size()];
    vector<int>big,equal,small;
    for(int& num:nums){
        if(num>pivot)big.push_back(num);
        else if(num<pivot)small.push_back(num);
        else equal.push_back(num);
    }
  //下面的if语句，你把num想象成三段就能理解为啥这样书写逻辑了
    if(k<=big.size())return quickSelect(big,k);
    if(nums.size()-small.size()<k)return quickSelect(small,k-nums.size()+small.size());
    return pivot;
}
```

## 贪心

### 买卖股票的最佳时机
