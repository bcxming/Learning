## 选·质数的最大距离

1、不会判断质数:居然是枚举出100以内的质数

2、用first记录第一次质数位置，一次遍历不断更新结果

```cpp
int maximumPrimeDifference(vector<int>& nums) {
    unordered_set<int>primes = {
        2,3,5,7,11,
        13,17,19,23,29,
        31,37,41,43,47,
        53,59,61,67,71,
        73,79,83,89,97
    };//枚举
    int n = nums.size();
    int first = -1,ans = 0;
    for(int i = 0;i<n;++i){//一次遍历
        if(primes.count(nums[i])){
            if(first!=-1){
                ans = max(ans,i-first);//不断更新
            }else{
                first = i;
            }
        }
    }
    return ans;
}
```

### 哈沙德数

取一个数的每一位

```cpp
while(temp!=0){
    sum += temp%10;
    temp/=10;
}
```

## 统计移除递增子数组的数目

```cpp
int incremovableSubarrayCount(vector<int>& nums) { 
int n = nums.size(); // 获取向量nums的大小，并存储在变量n中
int i = 0; // 初始化变量i为0，用于遍历数组
// 循环找到第一个不满足升序的元素位置
while(i < n - 1 && nums[i] < nums[i + 1]) {
    i++; // 如果当前元素小于下一个元素，则继续移动到下一个位置
}
// 如果整个数组都是严格递增的
if(i == n - 1) {
    return n * (n + 1) / 2; // 返回所有子数组的数量，即C(n+1, 2)
}
int ans = i + 2; // 初始答案为前面严格递增部分的长度加2（包括起点和终点）
// 从后向前遍历数组以计算符合条件的子数组数量
for(int j = n - 1; j == n - 1 || nums[j] < nums[j + 1]; j--) {
    while(i >= 0 && nums[i] >= nums[j]) {
        i--; // 向左移动i直到找到一个比当前j位置元素小的元素
    }
    ans += i + 2; // 更新答案，包括从0到i位置的所有可能子数组
}
return ans; // 返回最终结果
}
```

### 删除最短子树组使数组有序

```cpp
int findLengthOfShortestSubarray(vector<int>& arr) {
    int n = arr.size();
    int right = n-1;
    while(right&&arr[right-1]<=arr[right]){
        --right;
    }
    if(right==0)return 0;
    int ans = right;
    for(int left = 0;left==0||arr[left-1]<=arr[left];++left){
        while(right<n&&arr[right]<arr[left]){
            ++right;
        }
        ans = min(ans,right-left-1);
    }
    return ans;
}
```

## 位运算

来源：https://leetcode.cn/circle/discuss/CaOJ45/

集合论：在集合论中，有交集 ∩、并集 ∪、包含于 ⊆ 等等概念。如果编程实现「求两个哈希表的交集」，需要一个一个地遍历哈希表中的元素。那么，有没有效率更高的做法呢？集合可以压缩成数字

利用位运算「并行计算」的特点，我们可以高效地做一些和集合有关的运算。按照常见的应用场景，可以分为以下四类：

### 集合与集合

| 术语 | 集合    | 位运算    | 集合示例                   | 位运算示例      |
| ---- | ------- | --------- | -------------------------- | --------------- |
| 交集 | *A*∩*B* | *a*&*b*   | {0,2,3}∩{0,1,2}={0,2}      | 1101&0111=0101  |
| 并集 | *A*∪*B* | *a* ∣ *b* | {0,2,3} u{0,1,2}={0,1,2,3} | 1101\|0111=1111 |
|      |         |           |                            |                 |

### 集合与元素

### 遍历集合

### 枚举集合

## 每日一题

### 7.22引爆最多的炸弹

1、如何判断一个炸弹能引爆别的炸弹：

- *n* 个炸弹看成 *n* 个节点，如果炸弹 *x* 可以引爆炸弹 *y*，那么就连一条从节点 *x* 到节点 *y* 的**有向边**
- dx*dx+dy*dy<=r*r来判断能不能引爆

2、枚举DFS：枚举 *i* 作为一开始引爆的炸弹，从 *i* 开始 **DFS** 这张图，统计能访问到的节点个数，更新答案的最大值

- 使用vector<int>vis(n);记录访问过的元素

```cpp
  int maximumDetonation(vector<vector<int>>& bombs) {
        int n = bombs.size();
        vector<vector<int>>g(n);
        for(int i = 0;i<n;i++){
            long long x = bombs[i][0],y = bombs[i][1],r = bombs[i][2];
            for(int j = 0;j<n;j++){
                long long dx = x-bombs[j][0];
                long long dy = y-bombs[j][1];
                if(j!=i&&dx*dx+dy*dy<=r*r){
                    g[i].push_back(j);
                }
            }
        }
        int ans = 0;
        vector<int>vis(n);
        auto dfs = [&](auto&& dfs,int x)->int{
            vis[x] = true;
            int cnt = 1;
            for(int y : g[x]){
                if(!vis[y]){
                    cnt += dfs(dfs,y);
                }
            }
            return cnt;
        };
        for(int i = 0;i<n;i++){
            std::fill(vis.begin(), vis.end(), 0);
            ans = max(ans,dfs(dfs,i));
        }
        return ans;
    }
```

### 7.23求出所有子序列的能量和

有点难，战略性放弃

### 7.24重新放置石块

模拟题，但是好像不用记录石块的数量，所以用unordered_set就可以了

```cpp
  vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {
      unordered_map<int,int>mymap;
      for(auto& a:nums){
          mymap[a]++;
      }
      for(int i = 0;i<moveFrom.size();i++){
          if(mymap.find(moveFrom[i])!=mymap.end()){
              int time = mymap[moveFrom[i]];
              mymap.erase(moveFrom[i]);
              mymap[moveTo[i]] += time;
          }
      }
      vector<int>result;
      for(auto& a:mymap){
          result.push_back(a.first);
      }
      sort(result.begin(),result.end());
      return result;
  }
```

### 7.25生成特殊数字的最少操作

一个数能被 25 整除，有如下五种情况：

这个数是 0。

这个数的末尾是 00，例如 100。

这个数的末尾是 25，例如 225。

这个数的末尾是 50，例如 350。

这个数的末尾是 75，例如 475。

- 在之前找到 0 的情况下，如果当前数字 num[i] 是 0 或者 5，则立刻返回 n−i−2。
- 在之前找到 5 的情况下，如果当前数字 num[i] 是 2 或者 7，则立刻返回 n−i−2。
- 否则，如果 num[i] 是 0，标记我们找到了 0。
- 否则，如果 num[i] 是 5，标记我们找到了 5。
- 如果循环中没有返回，则最后返回 n 或者 n−1，取决于我们是否找到了 0。

```cpp
int minimumOperations(string num) {
    int n = num.size();
    bool found0 = false,found5 = false;
    for(int i = n-1;i>=0;i--){
        char c = num[i];
        if(found0&&(c=='0'||c=='5')||found5&&(c=='2'||c=='7')){
            return n-i-2;
        }
        if(c=='0'){
            found0 = true;
        }else if(c=='5'){
            found5 = true;
        }
    }
    return n-found0;
}
```

### 7.26找出区分值

先写出来再去优化

```cpp
int findValueOfPartition(vector<int>& nums) {
    sort(nums.begin(),nums.end());
    int result = INT_MAX;
    for(int i = 1;i<nums.size();i++){
        result = min(result,nums[i]-nums[i-1]);
    }
    return result;
}
```

### 7.27满足距离约束且字典序最小的字符串

1、对于一个循环的小写字符串，如果求解最小距离

```cpp
 int dis = min(c - 'a', 'z' - c + 1);
```

### 7.28掉落的方块

```cpp
vector<int> fallingSquares(vector<vector<int>>& positions) {
    int n = positions.size();
    vector<int> ret(n);
    map<int, int> heightMap;
    heightMap[0] = 0; // 初始时从 0 开始的所有点的堆叠高度都是 0
    for (int i = 0; i < n; i++) {
        int size = positions[i][1];
        int left = positions[i][0], right = positions[i][0] + positions[i][1] - 1;
        auto lp = heightMap.upper_bound(left), rp = heightMap.upper_bound(right);
        int rHeight = prev(rp)->second; // 记录 right + 1 对应的堆叠高度（如果 right + 1 不在 heightMap 中）

        // 更新第 i 个掉落的方块的堆叠高度
        int height = 0;
        for (auto p = prev(lp); p != rp; p++) {
            height = max(height, p->second + size);
        }

        // 清除 heightMap 中位于 (left, right] 内的点
        heightMap.erase(lp, rp);

        heightMap[left] = height; // 更新 left 的变化
        if (rp == heightMap.end() || rp->first != right + 1) { // 如果 right + 1 不在 heightMap 中，更新 right + 1 的变化
            heightMap[right + 1] = rHeight;
        }
        ret[i] = i > 0 ? max(ret[i - 1], height) : height;
    }
    return ret;
}
```

### 7.29棒球比赛

```go
func calPoints(operations []string) int {
    result := 0
    record := []int{}

    for _, op := range operations {
        switch op {
        case "+":
            if len(record) >= 2 {
                record = append(record, record[len(record)-1]+record[len(record)-2])
            }
        case "D":
            if len(record) > 0 {
                record = append(record, 2*record[len(record)-1])
            }
        case "C":
            if len(record) > 0 {
                record = record[:len(record)-1]
            }
        default:
            num, err := strconv.Atoi(op)
            if err == nil {
                record = append(record, num)
            }
        }
    }

    for _, score := range record {
        result += score
    }

    return result
}

```

### 7.30双模幂运算

**快速幂**

x的13次方= x*x的四次方 * x的8次方

1101 

```go
func myPow(x float64, n int) float64 {
    ans := 1.0
    if n<0{
        n = -n // x^-n = (1/x)^n
        x = 1/x
    }
    for n>0{// 从低到高枚举 n 的每个比特位
        if n&1>0{// 这个比特位是 1
            ans *= x// 把 x 乘到 ans 中
        }
        x *= x// x 自身平方
        n >>= 1// 继续枚举下一个比特位
    }
    return ans

}
```

模运算恒等式

```
（a+b)mod m = ((a mod m)+(b mod m))mod m
 (a*b)mod m = ((a mod m).(b mod m))mod m
```

```go
func getGoodIndices(variables [][]int, target int) []int {
    ans := make([]int,0)
    for i,v:=range variables{
        if pow(pow(v[0],v[1],10),v[2],v[3])==target{
            ans = append(ans,i)
        }
    }
    return ans
}

func pow(x,n,mod int) int{
    res := 1
    for;n>0;n/=2{
        if n%2>0{
            res = res * x % mod
        }
        x = x*x%mod
    }
    return res
}
```

### 7.31覆盖所有点的最少矩形数目

1、把横坐标的第一位根据从小到大排序

2、假设初始化x2 = -1

3、遍历、如果x>x2，那我们就需要一个新的矩形，答案加一同时x2 = x+w

```go
func minRectanglesToCoverPoints(points [][]int, w int) int {
    slices.SortFunc(points,func(p,q []int)int {return p[0]-q[0]})
    x2 := -1
    ans := 0
    for _,p := range points{
        if p[0]>x2{
            ans++
            x2 = p[0]+w
        }
    }
    return ans
}
```

### 8.1心算挑战

总感觉排序就不敢写了，觉得时间复杂度太高

举例：10、9、9、6      cnt = 2

```go
func maxmiumScore(cards []int, cnt int) int {
    slices.SortFunc(cards,func(a,b int)int {return b-a})
    sum := 0
    for _,v:=range cards[:cnt]{
        sum += v
    }
    if sum%2==0{
        return sum
    }
    replaceSum := func(x int)int{
        for _,v := range cards[cnt:]{
            if v%2 != x%2{// 找到一个最大的奇偶性和 x 不同的数
                return sum-x+v// 用 v 替换 s
            }
        }
        return 0
    }
    ans := 0
    for i:=cnt-1;i>=0;i--{
        if cards[i]%2==0{
            ans = max(ans,replaceSum(cards[i]))
        }
    }
    for i:=cnt-1;i>=0;i--{
        if cards[i]%2==1{
            ans = max(ans,replaceSum(cards[i]))
        }
    }
    return ans
}
```

### 8.2直角三角形

做法是枚举中间的点，这样更容易理解，直接就是一个十字架

```go
func numberOfRightTriangles(grid [][]int) (ans int64) {
    n := len(grid[0])
    col_sum := make([]int,n)//每一列的1的个数
    for _,row := range grid{//行
        for j,x := range row{//列
            col_sum[j] += x//第j列的个数加x
        }
    }
    for _,row := range grid{//遍历每一行
        row_sum := -1//每一行预先减去一
        for _,x := range row{//第i行的个数，假设是第一行
            row_sum += x
        }
        for j,x := range row{//假设遍历第一行的每一个数字
            if x==1{
                //递归：第i行有x个1，第j列有y个1，那么第i，j为定点的直角三角形有（i-1)*(j-1)
                ans += int64(row_sum*(col_sum[j]-1))
            }
        }
    }
    return ans
}
```

