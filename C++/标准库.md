C++标准库是C++编程语言中一个非常重要的组成部分，它为开发者提供了丰富的工具和功能，从容器、算法到输入输出流以及多线程支持。C++标准库不仅提高了开发效率，还极大地增强了代码的可读性和可维护性。

### 什么是STL？

**容器（Containers）：** 关联性数据结构和非关联性数据结构

**算法（Algorithms）：** 提供了各种通用算法，如排序、查找、遍历等

**迭代器（Iterators）：** 通过迭代器，可以以统一的方式对容器中的元素进行遍历和访问，而不需要关心具体的容器类型

**适配器（Adapters）：** 提供了一些适配器类模板，stack、queue 和优先队列适配器 priority_queue

**仿函数（Functors）：** 也称为函数对象，是一种行为类似函数的对象。STL中的算法通常通过仿函数来实现其功能，用户也可以自定义仿函数来满足特定的需求

**分配器（Allocators）：** 提供了一种灵活的内存管理机制，可以控制容器的内存分配和释放行为。用户可以自定义分配器来满足特定的内存管理需求

STL 几乎所有的代码都采用了模板类或者模板函数

### 标准容器

C++标准库提供了一组通用的容器类，用于存储和管理数据。常用的标准容器包括：

- **`std::vector`**：动态数组，支持快速随机访问和尾部插入。
- **`std::list`**：双向链表，支持高效的插入和删除操作。
- **`std::deque`**：双端队列，支持高效的首尾插入和删除。
- **`std::set`** 和 **`std::map`**：有序集合和映射，基于红黑树实现，支持快速查找、插入和删除。
- **`std::unordered_set`** 和 **`std::unordered_map`**：无序集合和映射，基于哈希表实现，支持平均常数时间的查找、插入和删除。

这些容器为不同的数据结构需求提供了解决方案，开发者可以根据具体应用场景选择最合适的容器。

**C++中vector和list有啥区别**

**`存储、访问、插入和删除、容量`**

`std::vector` 是一种动态数组，它在内存中连续存储元素。这意味着 `vector` 支持随机访问，即可以使用下标直接访问任意位置的元素。

特点：

- **连续存储**：`vector` 中的元素在内存中是连续存储的。
- **随机访问**：支持通过下标直接访问元素，时间复杂度为 O(1)。
- 插入和删除：
  - 插入和删除元素在尾部时效率较高，时间复杂度接近 O(1)。
  - 在中间或头部插入或删除元素时效率较低，因为需要移动大量元素，时间复杂度为 O(n)。
- **容量和大小**：`vector` 提供了 `size()` 和 `capacity()` 方法来获取当前元素数量和分配的内存大小。
- **自动扩容**：当向 `vector` 添加元素导致当前容量不足时，`vector` 会自动重新分配更大的内存空间，并将原有元素复制过去。

`std::list` 是一个双向链表，它通过指针连接各个节点。每个节点包含数据和指向前后节点的指针。

- **非连续存储**：`list` 中的元素不一定是连续存储的，而是通过指针链接。
- **随机访问**：不支持通过下标直接访问元素，需要遍历链表来访问元素，时间复杂度为 O(n)。
- 插入和删除：
  - 插入和删除元素非常高效，时间复杂度为 O(1)。
  - 插入和删除操作通常发生在已知位置，例如通过迭代器指定位置。
- **迭代器**：`list` 的迭代器提供了对元素的直接访问，但不支持随机访问。
- **不区分大小和容量**：`list` 没有类似于 `vector` 中的 `capacity()` 方法，因为链表的大小可以动态增长。

**总结：**增删改查

- std::vector：
  - **查：**适用于需要快速随机访问的场景
  - 在尾部插入和删除效率较高
- std::list：
  - **删：**适用于需要频繁插入和删除元素的场景
  - **增：**插入和删除操作效率高

### 标准算法

C++标准库中的算法是操作容器的强大工具。标准库提供了诸如排序、搜索、变换和汇总等常见操作的实现。常用的算法包括：

- **`std::sort`**：对范围内的元素进行排序。
- **`std::find`**：在范围内查找第一个满足条件的元素。
- **`std::accumulate`**：对范围内的元素进行累加。
- **`std::transform`**：将一个范围的元素转换为另一个范围的元素。
- **`std::for_each`**：对范围内的每个元素执行给定操作。

这些算法可以大大减少手写代码的复杂度，使代码更加简洁、可读和高效。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用std::for_each遍历和打印所有元素
    std::for_each(vec.begin(), vec.end(), [](int x) {
        std::cout << x << " ";
    });
    std::cout << std::endl;

    // 使用std::transform对所有元素进行平方运算
    std::transform(vec.begin(), vec.end(), vec.begin(), [](int x) {
        return x * x;
    });

    // 使用std::accumulate计算元素总和
    int sum = std::accumulate(vec.begin(), vec.end(), 0);
    std::cout << "Sum of squares: " << sum << std::endl;

    return 0;
}
```

### 字符串处理

C++标准库中的`std::string`类是一个非常强大的工具，用于处理和操作字符串。`std::string`提供了丰富的成员函数，如查找、拼接、替换、子串提取等。此外，C++11还引入了`std::to_string`和`std::stoi`等实用函数，用于在字符串和其他数据类型之间进行转换。

```cpp
#include <iostream>
#include <string>

int main() {
    std::string greeting = "Hello, ";
    std::string name = "world!";
    std::string message = greeting + name;

    std::cout << message << std::endl;

    std::string number = "42";
    int num = std::stoi(number);  // 将字符串转换为整数
    std::cout << "The number is: " << num << std::endl;

    return 0;
}
```

在这个例子中，我们展示了字符串的拼接、转换等操作，`std::string`使得这些操作非常直观和高效。

### 输入输出流

C++标准库提供了一套强大的输入输出流类，用于与标准输入输出、文件和字符串进行交互。常用的流类包括：

- **`std::cin`** 和 **`std::cout`**：用于标准输入输出。
- **`std::ifstream`** 和 **`std::ofstream`**：用于文件输入输出。
- **`std::stringstream`**：用于字符串流操作，适合处理格式化数据的读写。

流操作是C++中处理I/O的基础，C++标准库的流机制提供了极大的灵活性。

```cpp
#include <iostream>
#include <fstream>
#include <sstream>

int main() {
    std::string input = "123 456 789";
    std::stringstream ss(input);

    int a, b, c;
    ss >> a >> b >> c;

    std::cout << "Extracted numbers: " << a << ", " << b << ", " << c << std::endl;

    std::ofstream outfile("output.txt");
    outfile << "This is a line of text." << std::endl;
    outfile.close();

    return 0;
}
```

### 智能指针

C++11引入了智能指针来自动管理动态内存，避免了手动管理内存可能引发的错误。常用的智能指针包括：

- **`std::unique_ptr`**：独占所有权的智能指针，确保同一时间只有一个指针指向特定资源。
- **`std::shared_ptr`**：引用计数智能指针，允许多个指针共享同一资源。
- **`std::weak_ptr`**：配合`shared_ptr`使用，防止循环引用导致的内存泄漏。

智能指针在C++中有效地防止了内存泄漏问题，同时简化了内存管理。

```cpp
#include <iostream>
#include <memory>

class Widget {
public:
    Widget() { std::cout << "Widget created!" << std::endl; }
    ~Widget() { std::cout << "Widget destroyed!" << std::endl; }
};

int main() {
    {
        std::unique_ptr<Widget> ptr1 = std::make_unique<Widget>();
        std::shared_ptr<Widget> ptr2 = std::make_shared<Widget>();
    }  // 自动调用析构函数，释放资源

    return 0;
}
```

在这个例子中，智能指针`std::unique_ptr`和`std::shared_ptr`自动管理资源，确保在超出作用域时自动释放资源。

**RAII**

RAII（资源获取即初始化）：构造函数中申请分配资源，在析构函数中释放资源

因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。

智能指针（std::shared_ptrstd::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。

### 多线程

C++11标准库引入了多线程支持，包括线程创建、管理和同步。`<thread>`库提供了创建和管理线程的接口，而`<mutex>`库提供了必要的同步机制，如互斥锁、条件变量等。

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;

void print_thread_id(int id) {
    std::lock_guard<std::mutex> lock(mtx);
    std::cout << "Thread ID: " << id << std::endl;
}

int main() {
    std::thread t1(print_thread_id, 1);
    std::thread t2(print_thread_id, 2);

    t1.join();
    t2.join();

    return 0;
}
```

在这个例子中，两个线程同时执行打印操作，通过互斥锁`std::mutex`确保线程安全。

### 正则表达式

C++11引入了`<regex>`库，用于处理字符串的模式匹配。正则表达式在文本处理、验证和替换中非常有用。

```cpp
#include <iostream>
#include <regex>

int main() {
    std::string email = "user@example.com";
    std::regex email_regex("[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}");

    if (std::regex_match(email, email_regex)) {
        std::cout << "Valid email address." << std::endl;
    } else {
        std::cout << "Invalid email address." << std::endl;
    }

    return 0;
}
```

在这个例子中，我们使用正则表达式来验证一个邮箱地址的格式是否正确。

