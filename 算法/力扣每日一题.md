## 选·质数的最大距离

1、不会判断质数:居然是枚举出100以内的质数

2、用first记录第一次质数位置，一次遍历不断更新结果

```cpp
int maximumPrimeDifference(vector<int>& nums) {
    unordered_set<int>primes = {
        2,3,5,7,11,
        13,17,19,23,29,
        31,37,41,43,47,
        53,59,61,67,71,
        73,79,83,89,97
    };//枚举
    int n = nums.size();
    int first = -1,ans = 0;
    for(int i = 0;i<n;++i){//一次遍历
        if(primes.count(nums[i])){
            if(first!=-1){
                ans = max(ans,i-first);//不断更新
            }else{
                first = i;
            }
        }
    }
    return ans;
}
```

### 哈沙德数

取一个数的每一位

```cpp
while(temp!=0){
    sum += temp%10;
    temp/=10;
}
```

## 统计移除递增子数组的数目

```cpp
int incremovableSubarrayCount(vector<int>& nums) { 
int n = nums.size(); // 获取向量nums的大小，并存储在变量n中
int i = 0; // 初始化变量i为0，用于遍历数组
// 循环找到第一个不满足升序的元素位置
while(i < n - 1 && nums[i] < nums[i + 1]) {
    i++; // 如果当前元素小于下一个元素，则继续移动到下一个位置
}
// 如果整个数组都是严格递增的
if(i == n - 1) {
    return n * (n + 1) / 2; // 返回所有子数组的数量，即C(n+1, 2)
}
int ans = i + 2; // 初始答案为前面严格递增部分的长度加2（包括起点和终点）
// 从后向前遍历数组以计算符合条件的子数组数量
for(int j = n - 1; j == n - 1 || nums[j] < nums[j + 1]; j--) {
    while(i >= 0 && nums[i] >= nums[j]) {
        i--; // 向左移动i直到找到一个比当前j位置元素小的元素
    }
    ans += i + 2; // 更新答案，包括从0到i位置的所有可能子数组
}
return ans; // 返回最终结果
}
```

### 删除最短子树组使数组有序

```cpp
int findLengthOfShortestSubarray(vector<int>& arr) {
    int n = arr.size();
    int right = n-1;
    while(right&&arr[right-1]<=arr[right]){
        --right;
    }
    if(right==0)return 0;
    int ans = right;
    for(int left = 0;left==0||arr[left-1]<=arr[left];++left){
        while(right<n&&arr[right]<arr[left]){
            ++right;
        }
        ans = min(ans,right-left-1);
    }
    return ans;
}
```

## 位运算

来源：https://leetcode.cn/circle/discuss/CaOJ45/

集合论：在集合论中，有交集 ∩、并集 ∪、包含于 ⊆ 等等概念。如果编程实现「求两个哈希表的交集」，需要一个一个地遍历哈希表中的元素。那么，有没有效率更高的做法呢？集合可以压缩成数字

利用位运算「并行计算」的特点，我们可以高效地做一些和集合有关的运算。按照常见的应用场景，可以分为以下四类：

### 集合与集合

| 术语 | 集合    | 位运算    | 集合示例                   | 位运算示例      |
| ---- | ------- | --------- | -------------------------- | --------------- |
| 交集 | *A*∩*B* | *a*&*b*   | {0,2,3}∩{0,1,2}={0,2}      | 1101&0111=0101  |
| 并集 | *A*∪*B* | *a* ∣ *b* | {0,2,3} u{0,1,2}={0,1,2,3} | 1101\|0111=1111 |
|      |         |           |                            |                 |

### 集合与元素

### 遍历集合

### 枚举集合

## 每日一题

### 7.22引爆最多的炸弹

1、如何判断一个炸弹能引爆别的炸弹：

- *n* 个炸弹看成 *n* 个节点，如果炸弹 *x* 可以引爆炸弹 *y*，那么就连一条从节点 *x* 到节点 *y* 的**有向边**
- dx*dx+dy*dy<=r*r来判断能不能引爆

2、枚举DFS：枚举 *i* 作为一开始引爆的炸弹，从 *i* 开始 **DFS** 这张图，统计能访问到的节点个数，更新答案的最大值

- 使用vector<int>vis(n);记录访问过的元素

```cpp
  int maximumDetonation(vector<vector<int>>& bombs) {
        int n = bombs.size();
        vector<vector<int>>g(n);
        for(int i = 0;i<n;i++){
            long long x = bombs[i][0],y = bombs[i][1],r = bombs[i][2];
            for(int j = 0;j<n;j++){
                long long dx = x-bombs[j][0];
                long long dy = y-bombs[j][1];
                if(j!=i&&dx*dx+dy*dy<=r*r){
                    g[i].push_back(j);
                }
            }
        }
        int ans = 0;
        vector<int>vis(n);
        auto dfs = [&](auto&& dfs,int x)->int{
            vis[x] = true;
            int cnt = 1;
            for(int y : g[x]){
                if(!vis[y]){
                    cnt += dfs(dfs,y);
                }
            }
            return cnt;
        };
        for(int i = 0;i<n;i++){
            std::fill(vis.begin(), vis.end(), 0);
            ans = max(ans,dfs(dfs,i));
        }
        return ans;
    }
```

### 7.23求出所有子序列的能量和

有点难，战略性放弃

### 7.24重新放置石块

模拟题，但是好像不用记录石块的数量，所以用unordered_set就可以了

```cpp
  vector<int> relocateMarbles(vector<int>& nums, vector<int>& moveFrom, vector<int>& moveTo) {
      unordered_map<int,int>mymap;
      for(auto& a:nums){
          mymap[a]++;
      }
      for(int i = 0;i<moveFrom.size();i++){
          if(mymap.find(moveFrom[i])!=mymap.end()){
              int time = mymap[moveFrom[i]];
              mymap.erase(moveFrom[i]);
              mymap[moveTo[i]] += time;
          }
      }
      vector<int>result;
      for(auto& a:mymap){
          result.push_back(a.first);
      }
      sort(result.begin(),result.end());
      return result;
  }
```

### 7.25生成特殊数字的最少操作

一个数能被 25 整除，有如下五种情况：

这个数是 0。

这个数的末尾是 00，例如 100。

这个数的末尾是 25，例如 225。

这个数的末尾是 50，例如 350。

这个数的末尾是 75，例如 475。

- 在之前找到 0 的情况下，如果当前数字 num[i] 是 0 或者 5，则立刻返回 n−i−2。
- 在之前找到 5 的情况下，如果当前数字 num[i] 是 2 或者 7，则立刻返回 n−i−2。
- 否则，如果 num[i] 是 0，标记我们找到了 0。
- 否则，如果 num[i] 是 5，标记我们找到了 5。
- 如果循环中没有返回，则最后返回 n 或者 n−1，取决于我们是否找到了 0。

```cpp
int minimumOperations(string num) {
    int n = num.size();
    bool found0 = false,found5 = false;
    for(int i = n-1;i>=0;i--){
        char c = num[i];
        if(found0&&(c=='0'||c=='5')||found5&&(c=='2'||c=='7')){
            return n-i-2;
        }
        if(c=='0'){
            found0 = true;
        }else if(c=='5'){
            found5 = true;
        }
    }
    return n-found0;
}
```

### 7.26找出区分值

先写出来再去优化

```cpp
int findValueOfPartition(vector<int>& nums) {
    sort(nums.begin(),nums.end());
    int result = INT_MAX;
    for(int i = 1;i<nums.size();i++){
        result = min(result,nums[i]-nums[i-1]);
    }
    return result;
}
```

