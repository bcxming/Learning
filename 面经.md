## 项目

### raft算法、ZAB协议的区别

raft：领导者、跟随者、候选者

**选举过程**：

- 使用随机计时器触发选举，以避免多个节点同时竞选导致冲突。一个节点超时时会变成候选人并开始新一轮投票，如果获得多数票则成为领导者。

**日志复制**：

- 领导者将客户端请求转化为日志条目，并发送给所有跟随者进行复制。只有当大多数跟随者都确认了日志条目后，才认为该条目已提交。

**故障恢复**：

- 如果领导者失败，一个新的领导者通过选举产生。系统能够容忍少数节点失效而继续正常运行。

ZAB：领导者、跟随者

它是特别为**Zookeeper**设计的支持**崩溃恢复**的**原子广播**协议

**待学习**

**raft如何选举新的leader？**

随机扰动+超时重新选举+半数以上节点同意

## 操作系统

### 进程、线程、协程之间的区别，优缺点

进程：稳定性强、开销大、通信方式，分配资源

线程：线程挂了进程一般会挂掉、开销小、共享内存通信，不分配资源

协程：程序调度、开销小、单线程（异步IO和事件循环实现高效并发）

协程的缺点

- 不适用于CPU密集型任务，因为协程不能利用多核处理器

- 调试和监控较为困难，因为协程的调度完全由程序控制

### cpu常见的寄存器有哪些

通用寄存器：临时数据

指令寄存器：内存地址

段寄存器：段基址

标志寄存器：状态和控制

### 虚拟内存和物理内存之间的关系是什么

### 如何排查内存泄露

其中为进程内存泄露，c++内存泄露，go语言内存泄露

## 计算机网络

### TCP三次握手四次挥手

### 在浏览器中输入网址并回车后，发生了什么

### HTTP1/2/3的区别

如果一个tcp请求装不下内容，如何设计webserver，使其可以在高并发环境下把来自不同连接的内容分开

### 301和302的区别

永久重定向、临时重定向：浏览器是否会自动将旧的URL替换成新的

### time_wait和close_wait的区别是什么

## MySQL

### 三种日志的区别

### 了解什么数据库存储引擎，他们的底层是如何实现的

### b+树优缺点

**优点**

1. **高效的范围查询**：
   - B+树的叶节点形成一个链表，可以顺序访问，这使得范围查询（如查找某个区间内的所有值）非常高效。
2. **稳定的深度**：
   - B+树是高度平衡的，多数情况下可以保证O(log n)的时间复杂度进行插入、删除和查找操作。这是因为B+树在每次插入或删除时都会重新平衡自己。
3. **磁盘友好**：
   - B+树的节点通常存储在磁盘块中，每个节点包含多个键值对，这减少了I/O操作次数，提高了性能。因此，B+树特别适用于需要频繁读写大量数据的场景，如数据库索引。
4. **全局排序**：
   - 所有数据都存在叶子节点，并且这些叶子节点按键值大小顺序链接起来，这样不仅便于范围查询，还便于顺序遍历整个数据集。

**缺点**

1. **实现复杂性**：
   - B+树的实现比简单的二叉搜索树要复杂得多，需要处理节点分裂和合并等情况。
2. **更新代价**：
   - 尽管B+树的插入和删除操作具有良好的平均性能，但由于需要维护平衡，有时候这些操作会导致较大的开销，比如节点分裂和重组。

## redis

### 常用淘汰算法

### 如果不能和redis连接，如何排查问题？

1、检查服务是否在运行

```shell
systemctl status redis
```

2、查看配置文件：绑定地址、保护模式、端口号

3、防火墙

4、使用telnet命令测试连接

```shell
telnet <redis_host> 6379
```

### 如何redis内存不足是什么原因

数据量过大、内存配置限制、缓存淘汰策略、内存碎片化



## Linux

### 常见的c++实现设计模式

Linux中，如何杀死名字为server的进程

```shell
ps aux | grep server
kill <PID>
```

查看cpu信息

```shell
lscpu
```

监控cpu

```shell
top
```

判断端口的占用情况

```shell
#列出所有正在监听的TCP和UDP端口
netstat -tuln | grep LISTEN
#显示套接字统计信息
ss -tuln
#如果你知道某个特定端口被占用了，且需要查找是哪一个进程占用
sudo netstat -tulnp | grep :80
```

linux怎么查看运行的所有线程

```shell
# 会列出所有进程及其线程
ps -eLf
# 默认情况下只显示进程，可以通过按下键盘上的 H 键来切换到显示线程模式
top+ H
```



## C++

### **空类指针能访问成员函数？**

```c++
#include<iostream>
class temp {
public:
    virtual void print() {
        std::cout << "1" << std::endl;
    }
};
int main() {
    temp* p = nullptr;
    p->print();
}
```

### AVL树和红黑树的区别

平衡条件：高度差最多为1、红黑规则

调整频率：多次旋转、一次虚旋转

使用场景：读多写少、均衡

### b+树相较于二叉树有什么优点

### epoll为什么用红黑树而不用b+树

`epoll` 选择红黑树而非 B+ 树，主要是因为红黑树在插入、删除和查找操作上的高效表现，以及相对简单的实现和良好的内存局部性。这些特点使得红黑树非常适合用于 `epoll` 中管理大量文件描述符的需求

## 中间件

### zeromq的架构是怎样的，有什么特点？

### etcd底层是如何存储的

**Raft 共识算法**

- **Raft**：etcd 使用 Raft 算法来保证数据的一致性和可靠性。Raft 是一种分布式共识算法，用于在多个节点之间达成一致决策。通过使用 Raft，etcd 保证了即使在部分节点失效的情况下，集群仍然能够正常工作并保持数据一致。

**数据存储格式**

- BoltDB：etcd 的底层存储引擎是 BoltDB，一个嵌入式的键值数据库。BoltDB 提供了高性能的读写操作，并且以 B+ 树的形式组织数据，使得查询效率非常高。
  - **B+ 树**：这是 BoltDB 存储数据的核心结构，它是一种平衡树，可以高效地进行插入、删除和查找操作。

**WAL（Write-Ahead Log）**

- **预写日志**：每次对 etcd 的数据进行修改时，首先会将变更记录到 WAL 中。这确保了即使在崩溃或故障发生时，也可以通过重放 WAL 来恢复未完成的事务，从而保证数据的一致性和持久性。

**Snapshot（快照）**

- **定期快照**：为了防止 WAL 文件过大，影响启动速度和性能，etcd 会定期创建数据快照。快照包含当前状态下的数据副本，这样在需要恢复数据时，可以直接从最近的快照开始，而不是从头回放所有的 WAL 日志。

**MVCC（多版本并发控制）**

- **多版本并发控制**：etcd 实现了 MVCC，以支持高效的并发读写操作。每个键值对都有一个唯一的修订版本号，当数据被更新时，会生成一个新的版本，而旧版本则保留一段时间，以便支持历史查询和监控功能。

**Compact（压缩）**

- **数据压缩**：由于 MVCC 会保存数据的多个版本，为了避免存储空间的浪费，etcd 定期执行压缩操作，将不再需要的旧版本数据清理掉，只保留必要的历史版本。

**工作流程概述**

1. **写操作**：
   - 客户端发送写请求到 etcd 集群中的任意节点。
   - 接收请求的节点作为 leader，通过 Raft 协议与其他节点达成一致。
   - 一旦达成一致，leader 将变更记录到 WAL 中，然后应用到 BoltDB。
   - 最后，leader 向客户端返回确认信息。
2. **读操作**：
   - 客户端发送读请求到 etcd 集群中的任意节点。
   - 如果该节点是 leader，则直接从 BoltDB 读取数据并返回给客户端。
   - 如果该节点不是 leader，则会将请求转发给 leader 处理。
3. **快照和压缩**：
   - 在后台，etcd 定期创建快照并进行数据压缩，以优化存储和提高性能。

通过以上这些机制，etcd 能够提供**高可用、高一致性和高性能**的分布式键值存储服务，非常适合在分布式系统中用作配置管理和服务发现。

### paxos和raft的区别

### rdma了解吗？rdma有什么好处？了解什么是rdma的原语吗？

### probuf序列化与反序列化的原理

### 内部工作原理

1. **字段编号**：
   每个字段都有唯一的编号，这些编号在序列化时被编码成紧凑的二进制形式。这使得Protobuf非常高效，因为字段编号比字段名称短得多。
2. **变长整数编码（Varint Encoding）**：
   Protobuf使用变长整数编码来表示数字，这样小数字可以用更少的字节表示。例如，一个7位的整数只需要一个字节，而不是固定的四个字节。
3. **标签（Tags）**：
   每个字段在序列化时都会带有一个标签（Tag），这个标签包含字段编号和字段类型的信息。例如，一个字段编号为1且类型为整型的字段，其标签可能会被编码为8。
4. **长度前缀**：
   对于字符串、字节数组和嵌套消息，Protobuf会先写入数据的长度，然后再写入实际的数据内容。这使得解析器能够知道何时结束读取这些字段。
5. **顺序无关性**：
   在Protobuf中，字段的顺序不重要，这意味着你可以以任何顺序读写字段，只要字段编号一致即可。
6. **向后兼容和向前兼容**：
   新增字段不会破坏旧版本的消息，未识别的字段会被忽略。因此，你可以安全地添加新字段而不影响现有部署。

### kafka底层是如何实现的，怎样保证高并发

### zeromq底层是如何实现的，怎样保证高并发

## 场景题

第一道是设计一个直播系统，每个直播间有房间号和热度，需要对直播房间列表里面的房间进行插入和删除，并且要能获得热度前100的直播间

```cpp
#include <iostream>
#include <unordered_map>
#include <queue>
#include <vector>

class LiveRoom {
public:
    int room_id;
    int heat;

    LiveRoom(int rid, int h) : room_id(rid), heat(h) {}

    bool operator<(const LiveRoom& other) const {
        // 小顶堆需要反转比较逻辑，使得最小元素在堆顶
        return this->heat > other.heat || (this->heat == other.heat && this->room_id > other.room_id);
    }
};

class LiveSystem {
private:
    std::unordered_map<int, LiveRoom> rooms_by_id;  // 哈希表：key 为 room_id, value 为 LiveRoom 对象
    std::priority_queue<LiveRoom> min_heap;         // 小顶堆：用于维护热度前100的房间
    int max_size = 100;                             // 堆的最大容量为100

public:
    void add_room(int room_id, int heat) {
        if (rooms_by_id.find(room_id) != rooms_by_id.end()) {
            throw std::invalid_argument("Room with this ID already exists");
        }

        LiveRoom new_room(room_id, heat);
        rooms_by_id[room_id] = new_room;
        
        if (min_heap.size() < max_size) {
            min_heap.push(new_room);
        } else if (new_room < min_heap.top()) {
            min_heap.pop();
            min_heap.push(new_room);
        }
    }

    void remove_room(int room_id) {
        auto it = rooms_by_id.find(room_id);
        if (it == rooms_by_id.end()) {
            throw std::invalid_argument("Room with this ID does not exist");
        }

        // 无法直接从 priority_queue 中移除元素，只能重新构建堆
        rooms_by_id.erase(it);

        std::priority_queue<LiveRoom> temp_heap;
        for (const auto& pair : rooms_by_id) {
            temp_heap.push(pair.second);
            if (temp_heap.size() > max_size) {
                temp_heap.pop();
            }
        }
        min_heap.swap(temp_heap);
    }

    std::vector<LiveRoom> get_top_100_rooms() {
        std::vector<LiveRoom> result;
        std::priority_queue<LiveRoom> temp_heap = min_heap;

        while (!temp_heap.empty()) {
            result.push_back(temp_heap.top());
            temp_heap.pop();
        }
        std::reverse(result.begin(), result.end());  // 从大到小排序
        return result;
    }
};

// 示例用法
int main() {
    LiveSystem live_system;
    try {
        live_system.add_room(101, 500);
        live_system.add_room(102, 1500);
        live_system.add_room(103, 300);
        std::vector<LiveRoom> top_rooms = live_system.get_top_100_rooms();

        for (const auto& room : top_rooms) {
            std::cout << "Room ID: " << room.room_id << ", Heat: " << room.heat << "\n";
        }
    } catch (const std::exception& e) {
        std::cerr << e.what() << '\n';
    }

    return 0;
}

```

### 常见的负载均衡算法

轮询（Round Robin）

**思路：**

- 使用一个索引变量来跟踪当前选择的服务器。
- 每次请求时，将索引增加1，并取模总服务器数以确保循环。

加权轮询（Weighted Round Robin）

**思路：**

- 为每个服务器分配一个权重值。
- 维护一个当前权重和最大权重，用于控制分配频率。
- 在循环中调整权重并选出符合条件的服务器。

最少连接（Least Connections）

**思路：**

- 创建一个字典或数组来记录每台服务器的当前连接数。
- 每次请求时，选择当前连接数最少的服务器，并增加其连接计数。
- 请求完成后，减少相应服务器的连接计数。

随机（Random）

**思路：**

- 每次请求时，从服务器列表中随机选择一台服务器。

源地址哈希（Source IP Hashing）

**思路：**

- 对客户端IP地址进行哈希运算，得到一个哈希值。
- 将这个哈希值对服务器数量取模，以确定分配给哪台服务器。

URL 哈希

**思路：**

- 对请求URL进行哈希运算，得到一个哈希值。
- 将这个哈希值对服务器数量取模，以确定分配给哪台服务器。

会话粘滞（Session Stickiness）

**思路：**

- 使用一个数据结构（如字典）保存用户会话与服务器的映射关系。
- 如果用户已有会话，则将请求分配到之前的服务器，否则根据其他策略分配并更新映射。

最快响应时间（Fastest Response Time）

**思路：**

- 定期监测各服务器的响应时间。
- 每次请求时，选择最近一次响应最快的服务器。

动态负载均衡（Dynamic Load Balancing）

**思路：**

- 实时收集各服务器的性能指标（如CPU使用率、内存占用等）。
- 根据这些实时数据计算负载，选择负载最低的服务器。

地理位置（Geolocation-Based Load Balancing）

**思路：**

- 获取用户的地理位置信息。
- 根据预先设定的地理区域划分，将请求分配到距离用户最近的服务器。

### 如果让你去设计并实现一个消息队列，需要怎么做，用到什么通信方法，消息队列的消息存在内存还是硬盘，存在硬盘中的消息如何存储

### 如何自己设计并实现一个malloc和free，保证分配和释放内存的合理，并且不产生内存泄漏

1. **初始化内存池**：创建一块预定义大小的连续内存区域，用于分配和释放。
2. **维护空闲列表**：使用链表或其他数据结构，跟踪内存池中未被分配的部分。
3. **分配内存（malloc）：**
   - 遍历空闲列表，找到满足请求大小的空闲块。
   - 如果找到合适的块，将其拆分为已分配部分和剩余空闲部分，并更新空闲列表。
4. **释放内存（free）：**
   - 将释放的内存块重新插入到空闲列表中。
   - 合并相邻的空闲块以减少碎片化。

### 1TB的文件如何快速找到想要的信息

分块读取➕查找

1、将1TB的文件按照一个G进行读取，读取过程中可采用缓冲区

2、每个块可进行二分查找和哈希查找

### c++如何自定义线程池，其中详细的参数

### **<font color='red'>了解哪些设计模式</font>**

==单例模式==

定义：单例模式是一种创建型模式，用于确保一个类只有一个实例，并提供一个全局访问点来访问该实例

分类：懒汉和饿汉

应用场景：据库连接池、日志文件、全局配置管理

==观察者模式==

定义：当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新

==工厂模式==

定义：提供了一种创建对象的最佳方式，将对象的创建与使用分离

**<font color='red'>如何设计一个低延迟的系统</font>**

1. **减少网络延迟**
   - 使用本地服务或在同一数据中心内部署服务，以减少网络延迟。
   - 选择高性能的网络硬件和优化的网络配置。
   - 减少不必要的网络跳数。
2. **优化数据访问**
   - 使用内存数据库（如 Redis、Memcached）来加速数据访问。
   - 避免复杂的数据库查询和事务处理。
   - 使用缓存来减少对后端存储系统的访问频率。
3. **减少计算开销**
   - 选择高效的编程语言和框架。
   - 使用无锁数据结构和并发模型来减少同步开销。
   - 避免不必要的计算和内存分配。
4. **异步处理**
   - 使用异步 I/O 模型来避免阻塞操作。
   - 异步处理耗时的任务，例如文件读写、网络请求等。
5. **细粒度的资源分配**
   - 在多核处理器上合理分配任务，避免资源争抢。
   - 为关键路径上的服务预留足够的资源。

**<font color='red'>如何设计一个高吞吐量的系统</font>**

1. **水平扩展**
   - 通过增加服务器的数量来扩展系统，而不是依赖于单一高性能服务器。
   - 使用负载均衡器来分发请求到不同的服务器实例。
2. **异步处理**
   - 使用消息队列（如 Kafka、RabbitMQ）来异步处理请求，平滑请求峰值。
   - 异步处理长时间运行的任务，避免阻塞主线程。
3. **数据分片**
   - 将数据分布在多个数据库实例上，以提高读写性能。
   - 使用数据分片策略来减少单个数据库实例的压力。
4. **缓存**
   - 使用缓存来减少对后端存储系统的访问频率。
   - 实现缓存穿透、缓存雪崩和缓存击穿的解决方案。
5. **优化数据访问**
   - 优化数据库索引和查询语句。
   - 使用 NoSQL 数据库或其他适合大规模数据存储的技术。