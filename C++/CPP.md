## 基本知识

### **<font color='Red'>C++源文件到可执行文件的过程（预处理，编译、汇编、链接）</font>**

**预处理阶段**：处理 `#` 开头的预处理指令，生成一个经过**<font color='purple'>宏</font>**替换和包含其他头文件的临时文件，生成*.i文件

**编译阶段**：词法分析、语法分析后转成汇编代码，生成*.s的汇编文件

**汇编阶段**：将汇编语言的目标文件转换成机器语言的目标文件（.o）,缺少外部函数地址

**链接阶段**：将目标文件和其他库文件链接在一起，生成最终的可执行文件

**<font color='red'>什么叫静态库，为什么要静态链接？</font>**

==静态库：==在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件

每个源文件都是独立编译的，即每个* .cc文件会形成一个* .o文件

由很多目标文件* .o进行链接形成的是静态库，可以使用归档工具（如 `ar`）创建

==举例说明：==

假设有一个静态库 `libmylib.a`，它包含三个目标文件 `foo.o`、`bar.o` 和 `baz.o`。其中：

- `foo.o` 定义了函数 `foo()`
- `bar.o` 定义了函数 `bar()`
- `baz.o` 定义了函数 `baz()`

你的程序 `main.cpp` 只使用了 `foo()` 函数，链接器会执行以下操作：

打开 `libmylib.a`。

查找 `foo()` 函数的定义，发现 `foo.o` 包含 `foo()` 函数。

提取 `foo.o` 并将其链接到你的程序中。

`bar.o` 和 `baz.o` 因为没有被使用到，所以不会被提取和链接

**<font color='red'>什么叫动态库，为什么要动态链接？</font>**

不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本

更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍

==在程序运行时才将它们链接在一起形成一个完整的程序==

**<font color='red'>动态链接地址是如何重定位的呢？</font>**

在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符

号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行

==链接阶段：==在编译时，可以使用 `-l` 选项指定要链接的动态库，编译器会将对动态库的引用添加到目标文件中。通常，你还需要指定动态库的路径。

==运行阶段：==在运行时，动态链接器（如 Linux 下的 ld.so ）会根据程序中的动态链接库引用，将相应的动态库加载

到进程的地址空间中，并完成符号重定位。

**<font color='red'>动态链接和静态链接区别</font>**

**链接时间**：运行时链接还是编译时链接

**文件大小**：静态链接较大

**更新和维护**：静态库可维护性低

### **<font color='red'>DDL调用的内存分区</font>**

==DLL的加载和内存映射==

**加载DLL文件**：操作系统通过文件系统读取DLL文件，并为其分配一个内存区域，通常称为“映射区”

**映射到虚拟地址空间**：操作系统将DLL的各个部分（包括代码段、数据段等）映射到进程的虚拟地址空间

**解析导入表和导出表**：当一个程序运行时，动态链接器会解析该程序和它所依赖的所有动态链接库的导入表和导出表。

导入表包含了程序需要从动态链接库中使用的符号（如函数和变量）。导入表告诉动态链接器程序需要哪些外部符号，并且这些符号位于哪些DLL中。

导出表包含了动态链接库中可供外部使用的符号。每个符号都有一个与之关联的地址，当动态链接器解析导入表时，会查找导出表以找到实际的地址。

**设置基址和重定位**：

设置基址：每个动态链接库在编译时都有一个首选的基址，这是该库在进程虚拟地址空间中的默认加载地址。当动态链接器加载一个动态链接库时，它会尝试将其映射到这个首选基址。

重定位（Relocation）：如果首选基址已经被其他库或程序占用，操作系统会将动态链接库映射到另一个地址。这时就需要进行重定位。重定位的过程包括更新动态链接库中的所有绝对地址引用，使它们指向新的内存位置。

动态链接库通常有一个重定位表（Relocation Table），其中包含了所有需要更新的地址。当动态链接器确定了新的基址后，它会遍历重定位表，并更新所有需要更新的地址引用。

**举例理解**

假设一个动态链接库`libexample.so`有一个首选基址`0x10000000`，但在加载时，这个地址已被其他库占用，操作系统将其加载到新基址`0x20000000`。

- **原地址**：函数`foo`在库中定义，其绝对地址为`0x10000100`。
- **新的地址**：由于基址变更，`foo`的新地址应为`0x20000100`。

重定位表中包含`foo`的原地址`0x10000100`的条目，动态链接器将遍历重定位表，计算出新的地址`0x20000100`，并更新所有引用`foo`的绝对地址。

==内存区域划分==

尽管DLL的各个部分被映射到映射区，但从逻辑上看，它们仍然属于不同的段（sections）：

**代码段（.text）**、**数据段（.data）**、**未初始化数据段（.bss）**

### **<font color='red'>什么叫软链接和硬链接</font>**

**软链接**

1、类似于Windows中的快捷方式，是指向另一个==文件或目录==的特殊文件

2、如果删除了被链接的文件，软链接将变成一个无效的链接

3、ln -s  软链接的大小是它所包含的路径的长度

**硬链接**

1、硬链接是指向相同文件数据块的多个文件名，对数据块的直接引用

2、只有当所有硬链接都删除后，文件数据块才会被释放

3、ln 硬链接的大小是文件内容的大小

**举例**

假设有一个文件`/home/user/file.txt`

```shell
ln -s /home/user/file.txt /home/user/link.txt
ln /home/user/file.txt /home/user/hardlink.txt
```

**<font color='red'>如果硬链接指向的原始文件被删除了会发生啥</font>**

1、删除原始文件名不会影响硬链接，文件数据只有在所有硬链接都被删除后才会被真正删除

2、因为硬链接与文件的数据是独立于文件名存在的，硬链接实际上是直接指向文件的 inode（即文件的元数据和

磁盘位置），而不是文件名

### **<font color='red'>linux内存布局</font>**

**Stack (栈)**：局部变量，函数参数，返回地址，高地址往低地址增长

**Memory-mapped Segment (内存映射段)**：用于内存映射文件和共享内存，动态链接库

**Heap (堆)**：new、malloc、低地址往高地址增长

**Data Segment (数据段)**：全局变量和静态变量（初始化、未初始化BSS）

**Text Segment (代码段)**：通常是只读的，可设置为多进程共享

### **<font color='Red'>C++内存分区</font>**

**<font color='blue'>不要和进程虚拟空间搞混了</font>**

==运行时候动态申请的内存：==

栈：调用函数过程中使用到的局部变量和函数参数

堆：动态内存

==编译期间确定的：==

数据段：初始过的全局变量和静态变量

BBS段：未初始化的变量

常量区：里面存放的是常量，不允许修改

代码段：存放机器码的虚拟内存空间

### **<font color='Red'>在main执行之前和之后执行的代码可能是什么</font>**

**main函数执行之前：**程序放在硬盘中，分为==代码段、数据段、BSS段==，运行时加载==栈段和堆段==

- 全局对象初始化，在`main`之前调用构造函数

- 数据段：静态变量和全局变量的初始化
- BSS段：将未初始化部分的全局变量赋初值
- 栈段：设置栈指针
- ==将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数==

**main函数执行之后**：

- 全局对象的析构函数会在main函数之后执行
- 内存清理（堆）

```cpp
int main(int argc, char *argv[]){
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
    }
}
```

==所有的参数在指针char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称==

### **<font color='Red'>结构体内存对齐问题</font>**

内存对齐是计算机系统中的一种优化手段，它确保数据结构中的每个字段都位于某个地址的整数倍上，以提高访问

速度，由编译器负责

- 结构体内成员按照声明**顺序存储**，第一个成员地址和整个结构体地址相同
- 未特殊说明时，按结构体中size最大的成员对齐
- ==手动修改：==C++11：`alignof`**可以计算出类型的对齐方式**、`alignas`**可以指定结构体的对齐方式**

### **<font color='Red'>全局变量和局部变量有什么区别？</font>**

==生命周期不同==

==使用方式不同：==

==内存分配的位置：==

- 全局变量分配在**全局数据段**并且在程序开始运行的时候被加载
- 局部变量则分配在**堆栈**里面 

**<font color='red'>函数调用过程栈的变化，返回值和参数变量哪个先入栈？</font>**

**参数变量**先入栈，以从右到左的顺序压入栈中。

**返回地址**紧随其后。

返回值通常通过寄存器传递，而不在栈中分配位置

**<font color='red'>静态成员与普通成员的区别是什么？</font>**

生命周期、共享方式、定义位置、初始化位置

**<font color='red'>c++中静态函数和静态变量的销毁时间</font>**

静态函数和静态变量的销毁时间都与程序的生命周期相关，它们在程序结束时被销毁

### **<font color='red'>命名空间的作用</font>**

第一：避免与其他作用域的函数、变量、类发生冲突

第二：限定变量、函数、类等的作用域，使其只在特定的命名空间中可见

### **<font color='Red'>指针和引用的区别</font>**

是否初始化

是否可以改变

引用非空

指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名，函数传参传递的是指针的副本

**<font color='red'>C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</font>**

指针参数传递使用指针来传递参数，函数内部通过指针间接地访问参数值。

引用参数传递使用引用来传递参数，函数内部直接通过引用访问参数值。

### **<font color='red'>空类指针能访问成员函数？</font>**

```c++
#include<iostream>
class temp {
public:
    virtual void print() {
        std::cout << "1" << std::endl;
    }
};
int main() {
    temp* p = nullptr;
    p->print();
}
```

**<font color='red'>通过指针实现引用的效果？</font>**

```cpp
//二级指针
#include <iostream>
void SetData(int **p) {
    *p = new int(100); // 修改传入的指针，使其指向新的内存地址
}
int main() {
    int *pData = NULL;
    SetData(&pData); // 传入指针的地址，便于修改指针的值
    std::cout << *pData << std::endl;
    delete pData; // 不要忘记释放内存
    return 0;
}
//引用传递
#include <iostream>
void SetData(int *&p) {
    p = new int(100); // 直接修改传入的指针，使其指向新的内存地址
}
int main() {
    int *pData = NULL;
    SetData(pData); // 传递指针的引用
    std::cout << *pData << std::endl;
    delete pData; // 不要忘记释放内存
    return 0;
}
```

### **<font color='red'>野指针和空指针</font>**

==野指针==

**定义**：指向一个已经释放的或未分配的内存区域的指针

**后果：**访问非法内存可能会导致==引发段错误、数据损坏和程序崩溃==

==空指针==

**定义**：指向一个特殊的地址（通常为0）的指针

**后果：**访问空指针导致==程序崩溃、引发段错误==，解引用空指针会导致==运行时错误==

==避免方法==

初始化指针、释放内存后置空、检查指针有效性、避免返回局部变量的地址、使用智能指针

==调试工具检查==

```shell
valgrind --leak-check=yes ./your_program
```

### **<font color='Red'>在传递函数参数时，什么时候该使用指针，什么时候该使用引用</font>**

1、需要返回函数内==局部变量的内存==的时候用指针，注意内存泄漏，而返回局部变量的引用是没有意义的。

2、对==栈空间大小==比较敏感（比如递归）的时候使用引用，使用引用传递不需要创建临时变量，开销要更小

==重要：==在函数内部修改指针本身（比如改变它指向的地址），不会影响到原始指针==(值传递)==

3、==类对象==作为参数传递的时候使用引用，这是C++类对象传递的标准方式

### **<font color='Red'>指针加减计算要注意什么？</font>**

指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分

小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。**它实际跨越的内存间隔**

**是指针类型的长度**

### **<font color='red'>栈</font>**

栈内存是程序执行期间用来存储==局部变量和函数调用信息==的内存区域。栈内存的分配和释放是

由编译器自动管理的

**函数调用时的分配**：

- 当函数被调用时，编译器会生成代码在函数调用栈上分配内存给该函数的==局部变量==。这通常通过将栈指针向下移动（减小地址）来实现。
- 函数调用过程中还会在栈上==保存返回地址、传递的参数以及调用者的栈帧指针==（frame pointer）。

**函数返回时的释放**：

- 当函数返回时，栈指针会==恢复到函数调用之前的位置==，意味着该函数在栈上分配的所有内存都被自动释放。

### **<font color='Red'>堆和栈的区别</font>**

**申请方式**：栈由系统自动分配、堆是自己申请和释放的

**申请大小**：栈是向栈底扩展，大小固定（4M）、堆向高地址扩展，不连续的内存区域（1G - 4G）

**申请效率**：栈速度快，不会有碎片、速度慢，且会有碎片

**<font color='red'>堆开辟能和内存一样大吗</font>**

操作系统限制、进程内存布局

```shell
ulimit -a
max memory size         (kbytes, -m) unlimited
```

尽管 `ulimit` 显示内存限制为 `unlimited`，但堆内存的申请仍会受物理内存和系统配置的影响。申请过多内存可

能导致系统变慢或程序崩溃。

### **<font color='Red'>你觉得堆快一点还是栈快一点</font>**

毫无疑问是栈快一点

- 操作系统会在底层对栈提供支持
- 堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存

**<font color='red'>栈溢出什么造成的</font>**

1、过深的递归调用

2、栈上的局部变量占用的空间太大

**<font color='red'>如何避免</font>**

1、确保递归函数有合适的终止条件

2、避免过大的局部变量

3、不使用递归

**<font color='red'>线程栈空间多大，怎么调大</font>**

```shell
ulimit -s  # 8192KB（8 MB）
```

要使更改永久生效，可以将该命令添加到 shell 的配置文件（如 `~/.bashrc` 

```shell
ulimit -s 65536  # 设置栈大小为 64 MB
```

### **<font color='Red'>宏定义</font>**

宏定义：==预处理阶段完成文本替换==，**<font color='blue'>没有类型检查</font>**，==无返回值==

```cpp
#define PI 3.14159 // 定义一个常量 PI
#define SQUARE(x) ((x) * (x)) // 定义一个计算平方的函数宏
//多行定义宏
//条件编译宏
```

typedef：==编译起作用==，**<font color='blue'>有类型检查</font>**

```cpp
typedef int Integer;  // 将 int 定义为 Integer
typedef int* IntPtr;  // 将 int* 定义为 IntPtr
typedef struct {
    int x;
    int y;
} Point;
```

内联函数：==编译时将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率==，**<font color='blue'>有类型检查</font>**

const：==编译起作用==，**<font color='blue'>有类型检查</font>**

```cpp
void constFunction() const {
    // 不能修改对象的成员变量
    // memberVar = 10;  // 错误，const 成员函数不能修改非静态成员变量
}
```

**<font color='Red'>变量声明和定义区别</font>**

声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间

相同变量可以在多处声明，但只能在一处定义

### **<font color='red'>strlen和sizeof区别？</font>**

1、sizeof是运算符，结果在编译时得到而非运行中获得；strlen是字符处理的库函数

2、sizeof参数可以是任何数据的类型或者数据；strlen的参数只能是字符指针且结尾是'\0'的字符串

**<font color='red'>怎么求一个类或者类型的字节大小</font>**

`sizeof` 返回的大小是==编译时确定的==，不会因为不同的编译环境而改变

对于类和结构体，`sizeof` 返回的大小可能会受到==编译器的优化和内存对齐==的影响，因此可能大于成员变量本身大小之和

`sizeof` 运算符可以用于==任何类型、表达式或变量名==，包括基本数据类型、数组、指针、结构体、类、枚举等

**<font color='red'>一个指针占多少字节？</font>**

在C++中，一个指针通常占用4字节或8字节，取决于==操作系统的位数和编译器的实现==

### **<font color='red'>为什么不能把所有的函数写成内联函数?</font>**

内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率

第一：函数体较大、频繁调用会增加可执行文件大小

第二：编译时间变长、可维护性降低

### **<font color='red'>volatile、mutable和explicit关键字的用法</font>**

**<font color='blue'>volatile</font>**：让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值

**<font color='blue'>mutable</font>**：为了突破const的限制而设置的

**<font color='blue'>explicit</font>**：构造函数显式的方式进行类型转换

**<font color='red'>volatile关键字的作用？</font>**

`volatile` 的主要作用是防止编译器对变量的读写操作进行优化，以确保每次访问到的都是变量的最新值

硬件寄存器：寄存器可能会被硬件或外部设备修改

内存映射 I/O：需要频繁读取或写入的 I/O 内存地址，编译器可能会出于优化考虑，省略重复的读写操作

多线程标志变量：如果一个线程需要不断检查某个变量的变化，`volatile` 可以防止编译器对变量的读取操作进行优化

注意事项：`volatile` 并不是线程安全的；`volatile` 不影响编译器对 CPU 缓存的使用

### **<font color='red'>四种强制转换</font>**

**`reinterpret_cast`**：用于非常低级别的类型转换，如指针和整数之间的转换

```cpp
int* ptr = new int(42);
char* charPtr = reinterpret_cast<char*>(ptr);
```

**`const_cast`**：用于添加或删除 `const` 修饰符

```cpp
const int x = 10;
int* nonConstPtr = const_cast<int*>(&x);
```

**`static_cast`**：执行基本类型之间的转换，不进行运行时类型检查

```cpp
double d = 3.14;
int i = static_cast<int>(d);
```

**`dynamic_cast`**：在继承层次结构中进行安全的向下转型（派生类到基类）和运行时类型检查

```cpp
Base* basePtr = new Derived;
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
```

### **<font color='red'>static_cast比C语言中的转换强在哪里？</font>**

更加安全，可读性强

```cpp
int i = 10;
float f = static_cast<float>(i);
Base* basePtr = new Derived();
Derived* derivedPtr = static_cast<Derived*>(basePtr);
```

### **<font color='red'>C++函数调用的压栈过程</font>**

**保存当前状态**：

- 将当前函数的返回地址压入调用栈中。
- 保存当前函数的基址指针 (base pointer, BP)，用于后续局部变量的访问。

**创建新的栈帧**：

- 创建一个新的栈帧（stack frame），用于存储函数的局部变量和临时变量。
- 栈帧包括函数的参数、返回地址和其他局部变量。

**参数传递**：

- 如果函数有参数，它们可能会被复制到新的栈帧中，或者通过寄存器等方式传递给函数。

### **<font color='red'>extern"C"的用法</font>**

为了能够**正确的在C++代码中调用C语言**的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；

哪些情况下使用extern "C"：

（1）C++代码中调用C语言代码；

（2）在C++中的头文件中使用；

（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；

### **<font color='red'>写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</font>**

coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这

个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以

定位到程序异常的时候对应的堆栈调用信息。

1、使用 GDB（GNU 调试器）加载 core 文件，查看崩溃时的状态和调用堆栈

```shell
gdb ./my_program core
```

2、`bt`（backtrace）：查看崩溃时的调用堆栈。

`info locals`：显示当前函数中所有局部变量的值。

`print variable_name`：检查某个变量的值

### **<font color='red'>C++的异常处理的方法</font>**

常见的异常有：

- 数组下标越界
- 除法计算时除数为0
- 动态分配空间时空间不足

如果不及时对这些异常进行处理，程序多数情况下都会崩溃

**（1）try、throw和catch关键字**

- `try` 关键字用于标识包含可能抛出异常的代码块
- 当程序在 `try` 块内遇到异常情况时，可以使用 `throw` 关键字来抛出一个异常对象
- `catch` 后面紧跟一个异常的声明，用于匹配和处理特定类型的异常

**（2）函数的异常声明列表**

```cpp
int fun() throw(int,double,A,B,C){...};
```

函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常

**（3）C++标准异常类 exception**

- bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
- out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常
- bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时

### **<font color='red'>怎样判断两个浮点数是否相等？</font>**

对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！

对于两个浮点数比较只能通过相减并与==预先设定的精度==比较，记得要取绝对值！

**<font color='red'>union和sizeof</font>**

`union` 是一种特殊的数据结构，它允许在同一内存位置存储不同的数据类型。`union` 的大小等于其成员中最大的

数据类型的大小，并且所有成员共享相同的内存空间。这意味着在任何时候只能使用其中一个成员。

```cpp
#include <stdio.h>

// 枚举用于标记 union 中的不同类型
enum DataType {
    INT,
    FLOAT,
    CHAR
};

// 定义一个 union，包含不同的数据类型
union MyUnion {
    int intValue;
    float floatValue;
    char charValue;
    enum DataType type; // 增加一个标记成员
};
```

**<font color='red'>atomic是怎么保证原子性的</font>**

**原子指令集**：现代处理器通常提供了一组原子指令

**硬件锁**：会获取一个全局的锁来确保其他线程不能同时访问相同的内存位置

## 动态内存

### **<font color='red'>new / delete 与 malloc / free的异同</font>**

**不同点**

- new自动计算要分配的空间大小，malloc需要手工计算

- new是类型安全的，malloc不是。例如：

  ```cpp
  int *p = new float[2]; //编译错误
  ```

- new是封装了malloc，直接free不会报错，但是这只是**释放内存，而不会析构对象**，new和delete除了分配回收功能外，还会调用**构造函数和析构函数**

- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针

- new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL

### **<font color='red'>malloc怎么分配一个对象</font>**

```cpp
#include <iostream>
#include <new>    // 需要包含此头文件以使用 placement new
#include <cstdlib> // 包含 malloc 和 free 函数

class MyClass {
public:
    MyClass(int value) : value(value) {
        std::cout << "Constructor called, value = " << value << std::endl;
    }
    ~MyClass() {
        std::cout << "Destructor called, value = " << value << std::endl;
    }
    void print() const {
        std::cout << "Value: " << value << std::endl;
    }

private:
    int value;
};

int main() {
    // 使用 malloc 分配内存，但不会调用构造函数
    void* mem = malloc(sizeof(MyClass));
    if (!mem) {
        std::cerr << "Memory allocation failed" << std::endl;
        return 1;
    }
    // 使用 placement new 在已分配的内存上构造对象
    MyClass* obj = new (mem) MyClass(42);
    // 使用对象
    obj->print();
    // 手动调用析构函数
    obj->~MyClass();
    // 使用 free 释放内存
    free(mem);
    return 0;
}
```

**<font color='red'>调用malloc函数后，操作系统是如何运行的</font>**

1、计算所需内存大小

2、查看用户态是否有充足内存

3、brk和mmap

4、返回虚拟地址指针

###  **<font color='red'>new和delete是如何实现的</font>**

分配内存，调用构造函数；调用析构函数，释放内存

==为什么 `delete[]` 和 `delete` 的行为不同==

- **`delete[]` 的行为：**
  - `delete[]` 知道它需要释放的是一个数组，因此它会从 `p` 指针往前偏移四个字节来找到数组的大小 `n`。
  - 它会调用数组中每个元素的析构函数，然后释放从 `[p-4]` 开始的内存块。
- **`delete` 的行为：**
  - `delete` 只释放单个对象的内存，它不会查找或使用数组大小信息。
  - 直接释放 `p` 指向的内存，而不会处理 `[p-4]` 位置存储的数组大小信息。
  - 如果用 `delete` 释放由 `new[]` 分配的内存，系统不知道要释放的内存块的实际起始地址 `[p-4]`，也不会调用每个元素的析构函数，这会导致内存泄漏或程序崩溃。

**<font color='red'>operator new和new operator区别</font>**

**operator new** 是一个内存分配函数，用于分配未初始化的内存。

**new operator** 是 C++ 中用于动态分配和初始化对象的语法，它调用 `operator new` 来进行实际的内存分配。

### **<font color='red'>new什么时候计算对象大小</font>**

**编译时确定类型大小**：对象的大小是在编译时通过类型信息确定的。编译器知道每种类型的大小，包括所有非静态成员变量和必要的对齐填充。

**调用`new`运算符**：当`new`运算符被调用时，它会请求分配对象所需的内存大小。`new`运算符实际上会调用`operator new`函数，这个函数需要知道分配多少内存。

### **<font color='red'>malloc与free的实现原理？</font>**

==第一：==这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;

==第二：== brk是将「堆顶」指针向高地址移动，获得新的内存空间,mmap是在进程的虚拟地址空间中找一块空闲的

虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发

生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；

==第三：== malloc小于128k的内存，使用brk分配内存，将「堆顶」指针往高地址推；malloc大于128k的内存，使用

mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而

mmap分配的内存可以单独释放。

### **<font color='red'>new申请的内存一定不会还给操作系统吗</font>**

- **小块内存（堆内存）**：在大多数情况下，`new` 申请的小块内存释放后不会立即归还给操作系统，而是留在进程的内存池中，以备未来分配。
- **大块内存（映射内存）**：对于大块的内存分配，特别是通过 `mmap` 获取的内存，`delete` 释放时可能立即归还给操作系统。
- **内存碎片**：由于碎片化，小块内存在释放后可能会保留在程序中，不会被立即回收。

是否归还内存取决于内存分配器的实现以及操作系统的策略。

### **<font color='red'>new 一定会陷入内核态吗？</font>**

不一定，因为底层是 malloc ，malloc 根据分配内存的大小不同有两种分配方式，小于128k使用brk()，并且 

malloc 调用 brk() 时是预先申请一大段内存，不需要每次都陷入内核态去申请，大于128k使用 mmap() 

==缺页中断==

### **<font color='red'>new 的系统调用开销有多少？</font>**

**减少动态内存分配的频率：** 尽量避免在循环中频繁地调用 `new` 和 `delete`。

**使用对象池或者自定义内存池：** 对于某些需要频繁创建和销毁的对象，可以考虑使用对象池来复用已分配的内存。

**使用局部变量和栈内存：** 对于生命周期短暂的对象，尽量使用局部变量和栈内存，避免动态内存分配。

**预先分配和缓存：** 对于已知大小和数量的对象，可以提前进行分配并缓存，避免运行时的动态分配。

### **<font color='red'>深拷贝与浅拷可以描述一下吗？</font>**

浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变

在计算机中开辟了一块新的内存地址用于存放复制的对象

### **<font color='red'>什么是内存泄露，如何检测与避免</font>**

==内存泄露==

一般我们常说的内存泄漏是指**堆内存的泄漏**。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程

序运行期决定)内存块，使用完后必须显式释放的内存。

==避免内存泄露的几种方式==

- 一定要将基类的析构函数声明为**虚函数**
- 手动检查代码
- 使用智能指针
- 对象数组的释放一定要用**delete []**
- 有new就有delete，有malloc就有free，保证它们一定成对出现

==检测工具==

Linux下可以使用**Valgrind工具**

```cpp
#include <stdlib.h>
int main() {
    int *array = malloc(10 * sizeof(int));
    array[10] = 0;  // 错误：越界访问
    free(array);
    return 0;
}
```

为了生成==更详细的内存泄漏报告==，可以使用`--leak-check=full`：

```shell
valgrind --leak-check=full ./my_program
```

使用`--track-origins=yes`选项可以追踪==未初始化内存==的来源：

```shell
valgrind --track-origins=yes ./my_program
```

valgrind默认会检测常见的==内存访问错误==（如越界访问）。只需简单运行：

```shell
valgrind ./my_program
```

### **<font color='red'>C++中struct和class的区别</font>**

**相同点**：基本一样

**不同点**

- struct默认是公有的，class则默认是私有的
- class默认是private继承， 而struct默认是public继承
- C struct不支持函数

**<font color='red'>C和C++的 struct有啥区别</font>**

在C语言中，`struct`主要用于定义复合数据类型，其中可以包含不同类型的成员变量。

在C++中，`struct`仍然可以用来定义复合数据类型，但它还可以包含成员函数，并且支持面向对象。C++中的`struct`和`class`是非常相似的，主要的区别在于默认的访问级别不同：

- `struct`的默认访问级别是`public`
- `class`的默认访问级别是`private`

**运算符重载**：C++中的`struct`可以支持运算符重载等功能，这是C语言所不具备的

==经验法则：==

**struct**：当你设计的类型主要是用来**存储数据**，公开的成员更多时使用 `struct`。

**class**：当你设计的类型主要是用来**封装逻辑和行为**，并且需要控制访问权限时使用 `class`。

### **<font color='red'>C++中const和static的作用</font>**

**<font color='red'>static</font>**

类static：不与对象关联、必须外部初始化

非类static：隐藏、保持状态、生命周期很长

它的第一条也是最重要的一条：==隐藏(static函数，static变量均可)==

==不考虑类的情况==

- ==隐藏：==所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
- ==保持状态：==静态局部变量可以在函数调用之间保持状态
- ==生命周期管理：==始终存在，且只进行一次初始化，**函数退出后仍然存在，但不能使用**

==考虑类的情况==

- static成员变量：只与类关联，不与类的对象关联，==必须在类定义体外部初始化==
- static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；==必须在类定义体外部初始化==

**<font color='red'>const</font>**

常量、指针、引用、函数、多态

==不考虑类的情况==

- **常量声明**
- **常量指针**: 指出指针所指向的对象是常量，或者是指出指针本身是常量
- **常量引用**: 所引用的对象不能通过这个引用被改变
- **常量成员函数**: 该成员函数不会修改类的任何成员变量（除非这些成员变量也是`mutable`的)
- **只读成员变量**
- **函数参数的常量保护**
- **多态中的const**: 因为对于非`const`和`const`的同一个成员函数，编译器会视为两个不同的函数

==考虑类的情况==

- `const`成员变量必须在构造函数的初始化列表中进行初始化

`const` 本身不能直接隐藏变量的可见性，但通过 `static` 变量、匿名命名空间、`extern` 声明等技术，可以限制

变量的可见性，使其仅在定义的源文件中可见。

**<font color='red'>`#define` 和 `const` 都可以用来定义常量, 区别是啥</font>**

#define 宏定义

1、预处理阶段进行文本替换

2、没有类型： `#define PI` 被定义为一个浮点数，但是在使用时被当作整数

3、不可调试、不可撤销

const 常量

1、**编译期常量**：`const` 声明的常量是在编译期确定的，并且有明确的数据类型

2、**类型安全**：具有明确的数据类型，编译器可以检查类型错误

3、**可调试：**`const` 声明的常量是在编译期间确定的，因此可以在调试器中查看其值

**<font color='red'>const变量可以在构造函数中初始化吗</font>**

1、**在声明时初始化**

2、**在构造函数初始化列表中初始化**

**<font color='red'>const noncopyable& operator=(const noncopyable&);加不加const有啥区别</font>**

**加 `const` 的版本**：赋值后返回一个 `const` 引用，**不允许**链式赋值（如 `a = b = c`）。

**不加 `const` 的版本**：赋值后返回一个普通引用，**允许**链式赋值。

### **<font color='red'>数组名和指针（这里为指向数组首元素的指针）区别？</font>**

二者均可通过增减偏移量来访问数组中的元素

| 特性             | 数组名                     | 指针（指向数组首元素的指针） |
| ---------------- | -------------------------- | ---------------------------- |
| **本质**         | 常量指针，指向数组的首元素 | 变量，指向某个地址           |
| **是否可修改**   | 不可修改                   | 可以修改指向                 |
| **内存分配**     | 静态分配                   | 动态或静态分配               |
| **sizeof结果**   | 数组的总大小               | 指针本身的大小               |
| **算术运算**     | 不支持                     | 支持                         |
| **作为函数参数** | 退化为指针                 | 直接作为指针传递             |

### **<font color='red'>final和override关键字</font>**

override: 它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的

当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错

## 面向对象

[c++ - 虚函数表_c++虚函数表-CSDN博客](https://blog.csdn.net/weixin_49303682/article/details/122117650)

### **<font color='red'>对象的内存布局</font>**

==基本对象的内存布局：==对于一个简单的类对象，内存布局就是按顺序存储它的成员变量，可能会有内存结构对齐

==带有继承的对象内存布局：==基类成员变量在前，派生类在后

==带有虚函数的对象内存布局：==对象的内存布局中首先是一个指向虚函数表的指针 `vptr`，然后是基类的成员 `a`，接着是派生类的成员 `b`

==虚拟继承的内存布局：==`Final` 对象包含两个虚函数指针 `vptr1` 和 `vptr2`，分别指向 `Derived1` 和 `Derived2` 的虚函数表。基类 `Base` 的成员 `a` 由于虚拟继承在内存中有唯一实例，接着是 `Derived1` 和 `Derived2` 的成员 `b` 和 `c`，最后是 `Final` 的成员 `d`。

```cpp
class Base {
public:
    int a;
};

class Derived1 : virtual public Base {
public:
    double b;
};

class Derived2 : virtual public Base {
public:
    char c;
};

class Final : public Derived1, public Derived2 {
public:
    float d;
};

int main() {
    Final obj;
    // obj 的内存布局
    // +---------+---------+---------+-----------+------+-----------+
    // |  vptr1  |  vptr2  |    a    |     b     |  c   |     d     |
    // +---------+---------+---------+-----------+------+-----------+
    // |  8字节  |  8字节  |  4字节  |  8字节    | 1字节|  4字节    |
    // +---------+---------+---------+-----------+------+-----------+
}
```

==所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的==

### **<font color='red'>菱形继承</font>**

会产生的问题：**冗余基类成员**、**二义性问题**

==解决方法：虚拟继承==

```cpp
class A {
public:
    int value;
    void show() { std::cout << "A::show()" << std::endl; }
};

class B : virtual public A {
};

class C : virtual public A {
};

class D : public B, public C {
};

int main() {
    D d;
    d.value = 10;   // 只有一份 A::value
    d.show();       // 没有二义性
    return 0;
}
```

虚拟继承的工作原理

- 共享基类实例：
  - 虚拟继承确保在最底层派生类（例如 `D`）中，只存在一份基类 `A` 的实例。
- 基类初始化：
  - 在这种结构中，基类 `A` 的构造函数只能由最底层的派生类 `D` 调用，因为它负责初始化唯一的 `A` 实例。

**<font color='red'>如果一个类本身有一个虚函数，再加一个虚函数它的大小怎么变化？</font>**

**类的大小在第一次添加虚函数时会增加**，因为它会添加一个虚表指针。

**后续添加虚函数不会增加类的大小**，因为它们只增加虚表的条目，不会影响类的内存布局。

```cpp
#include <iostream>

class A {
public:
    ~A() { // 使用虚析构函数，确保派生类对象被正确释放
        std::cout << "~A" << std::endl;
    }
private:
    int m;
};

class B : public A {
public:
    ~B() {
        std::cout << "~B" << std::endl;
    }
private:
    char a;
    int m;
};

int main() {
    A* pa = new B();
    std::cout << "size of *pa: " << sizeof(*pa) << std::endl;
    delete pa; // 使用delete时，确保调用了虚析构函数

    B* pb = new B();
    std::cout << "size of *pb: " << sizeof(*pb) << std::endl;
    delete pb; // 使用delete时，确保调用了正确的析构函数

    return 0;
}
```

输出结果

```
size of *pa: 4           // 根据具体实现与环境，可能不同
~A
size of *pb: 12          // 根据具体实现与环境，可能不同
~B
~A
```

基类改成虚函数以后

```
size of *pa: 16
~B
~A
size of *pb: 24
~B
~A
```

**基类 `A`**：

- `A` 包含一个 `int` 成员变量 `m`。
- 当析构函数设置为虚函数后，`A` 会有一个 `vptr`。假设指针大小为 8 字节（64 位系统上通常为 8 字节），则 `A` 的对象大小为 `int`（4 字节） + `vptr`（8 字节） = 12 字节。
- 通常，为了对齐，编译器会将对象大小填充到 16 字节。

因此，`sizeof(*pa)` 的结果为 `16` 字节。

**派生类 `B`**：

- `B` 继承了 `A` 的成员 `m`，并且增加了 `char` 成员 `a` 和 `int` 成员 `m`。

- `B` 继承 `A` 的虚函数，因此 `B` 对象也会包含一个 `vptr` 指针，用于指向派生类的虚表。

- 在 64 位系统上，大小计算如下：

  - `vptr` 指针：8 字节
  - `char`：1 字节（一般对齐到 4 字节）
  - 两个 `int` 成员：4 字节 + 4 字节

- 合计：`vptr`（8 字节） + 对齐填充（3 字节）+ `char`（1 字节） + `int`（4 字节） + `int`（4 字节）= 20 字节。

- 对齐填充后，编译器会将对象大小填充到 24 字节。

**<font color='red'>派生类指针转为基类指针时所指向地址的变化</font>**

**单一继承**（无虚函数）和**有虚函数的单继承**：派生类指针转换为基类指针时，地址一般不变。

**多重继承**：派生类指针转换为不同的基类指针时，地址可能会有所不同。

**<font color='red'>为什么虚函数表和对象的地址不一样？</font>**

**对象地址**：表示对象在堆中的起始位置，包括成员变量和虚表指针（`vptr`）。

**虚函数表地址**：表示存储虚函数指针的表的位置，属于类的静态存储区。

**虚表指针（vptr）**：存在于对象内存中，指向该类的虚函数表，所有同一类的对象共享相同的虚表。

### **<font color='red'>public，protected和private访问和继承权限的区别？</font>**

OOP 的主要思想是将==属性==与==方法==封装在对象中，从而使得程序的设计更加==模块化==、==可重用==和==易于理解==

**<font color='blue'>访问权限：</font>**

- public的变量和函数在类的内部外部都可以访问
- protected的变量和函数只能在类的内部和其派生类中访问
- private修饰的元素只能在类内访问

**<font color='blue'>继承权限：</font>**

- public 继承可以访问基类保护成员
- protected 继承把基类都变成protected 
- private 继承把基类的东西都变成private

### 构造函数

**<font color='blue'>默认构造函数</font>**、

==直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数==

**<font color='blue'>拷贝/赋值构造函数</font>**

```cpp
MyClass(const MyClass& other) {
}
MyClass& operator=(const MyClass& other) {
}
MyClass obj2(obj1);   // 调用拷贝构造函数
MyClass obj2 = obj1;  // 调用赋值构造函数
```

**<font color='red'>什么情况下会调用拷贝构造函数</font>**

用类的一个实例化对象去初始化另一个对象的时候

函数的参数是类的对象时（非引用传递）

**<font color='blue'>移动构造函数</font>**

```cpp
// 移动构造函数
MyClass(MyClass&& other) noexcept : resource(other.resource) {
        std::cout << "Move constructor called\n";
        other.resource = nullptr;
        // 实现移动构造逻辑}
MyClass obj2 = std::move(obj1);  // 调用移动构造函数
```

**<font color='red'>构造函数、拷贝构造函数和赋值操作符的区别</font>**

**构造函数**

对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数

**拷贝构造函数**

对象不存在，但是使用别的已经存在的对象来进行初始化

**赋值运算符**

对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的

**<font color='red'>为什么拷贝构造函数必须传引用不能传值？</font>**

**避免无限递归调用**：如果拷贝构造函数的参数是按值传递的，那么在调用拷贝构造函数时，需要创建实参的副本。而创建副本时需要调用拷贝构造函数，这将导致无限递归调用，最终导致栈溢出或程序崩溃。通过传引用的方式，避免了创建参数副本的过程，可以确保拷贝构造函数不会无限递归调用，从而避免了潜在的问题

**性能考虑**：如果拷贝构造函数的参数是按值传递的，会导致每次调用拷贝构造函数时都需要进行参数的复制操作，这在对象较大时会产生较大的性能开销。通过传引用的方式，避免了参数的复制操作，可以提高程序的性能

###  **<font color='red'>说说移动构造函数</font>**

1、移动构造函数通过“移动”资源而非“复制”资源来实现高效对象构造，特别适用于大对象或资源管理类

2、**在容器中存储和重分配元素**：例如，`std::vector`在扩容时会使用移动构造来高效转移对象。

3、**返回局部对象**：如果函数返回一个局部对象，移动构造可以避免多余的拷贝

###  **<font color='red'>this指针</font>**

**<font color='blue'>基本概念</font>**

- this指针是类的指针，指向对象的首地址
- 在类的**非静态成员函数**中访问类的**非静态成员**的时候，即使你没有写上this指针，编译器在编译的时候也是加上this的

**<font color='blue'>用法</font>**

- 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this
- 当形参数与成员变量名相同时用于区分

### **<font color='red'>构造函数的执行顺序是什么？</font>**

第一：在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；

第二：对象的vptr被初始化；

第三：如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；

第四：执行程序员所提供的代码

**<font color='red'>类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</font>**

- 类成员初始化方式
  - 赋值初始化：所有的数据成员被分配内存空间后才进行
  - 列表初始化：给数据成员分配内存空间时就进行初始化
  - 区别：对于类型，它少了一次调用构造函数的过程，而对于内置数据类型则没有差别；**如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作**
- 执行顺序
  - 虚拟基类的构造函数、基类的构造函数、类类型的成员对象的构造函数、派生类自己的构造函数

**<font color='red'>最早可以使用虚函数表的精确时刻</font>**

**虚函数表的精确可用时刻**是在对象构造函数的执行过程中，但具体而言，**基类部分构造完成后 `vptr` 被初始化**，

即可访问虚表。

在基类的构造函数中，`vptr` 指向的是基类的虚表，只有基类的虚函数能被正确调用。

当派生类的构造函数开始时，`vptr` 会被更新为指向派生类的虚表，这时派生类的虚函数可以被正确调用。

### **<font color='red'>基类、派生类、成员对象构造函数调用顺序</font>**

==构造函数调用顺序：==基类构造函数 -> 成员对象构造函数 -> 派生类构造函数

==析构函数调用顺序：==派生类析构函数 -> 成员对象析构函数 -> 基类析构函数

## 多态

###  **<font color='red'>什么是纯虚函数，与虚函数的区别</font>**

**实现差异**：虚函数有默认的实现，但是可以在派生类中被重写，而纯虚函数在基类中没有默认实现，必须在派生类

中提供实现

**对象创建**：含有纯虚函数的类无法实例化对象，因为无法提供完整的实现；而含有虚函数的类可以实例化对象

**<font color='red'>什么是纯虚函数？使用场景有哪些？</font>**

纯虚函数是一个在基类中声明的虚函数，但没有在基类中提供实现，其声明形式为在函数声明后面添加 `= 0`

第一：定义接口

第二：实现多态

第三：限制基类对象的创建

### **<font color='red'>介绍面向对象的三大特性，并且举例说明</font>**

==（1）继承：==它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展

常见的继承有三种方式：

1. **实现继承：**指使用基类的属性和方法而无需额外编码的能力
2. **接口继承：**指仅使用属性和方法的名称、但是子类必须提供实现的能力

==（2）封装==

将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰，可以被继承的用protected

==（3）多态==

**编译时多态性（静态多态性）：**

- **函数重载：** 允许在同一作用域内定义多个同名函数，但参数列表不同
- **操作符重载：** 允许对类的操作符进行重载，使其在不同情境下有不同的行为

**运行时多态性（动态多态性）：**

- **虚函数和继承：** 使用虚函数和继承的机制实现运行时多态性

**<font color='blue'>实现方式：</font>**

- **编译时多态性：** 通过编译器在编译时根据函数参数的类型和数量选择正确的函数或操作符。
- **运行时多态性：** 通过虚函数表（vtable）和虚函数指针（vptr）的机制，在运行时根据对象的实际类型调用相应的函数

==简单一句话：允许将子类类型的指针赋值给父类类型的指针==

```cpp
 //多态性
Shape* shapePtr = new Circle;
shapePtr->draw();  // 运行时多态性，调用 Circle 类的 draw 函数
//抽象接口、 基类可以定义一组纯虚函数，形成一个抽象的接口
AbstractInterface* ptr = new ConcreteImplementation;
ptr->performAction();  // 调用实现了抽象接口的函数
//统一管理
std::vector<Animal*> animalList;
animalList.push_back(new Dog);
animalList.push_back(new Cat);
```

### **<font color='red'>C++的多态如何实现</font>**

在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函

数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数

==多态的原理==

虚函数表：类中含有virtual关键字修饰的方法时，编译器会自动生成虚表

虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针(在 64 位系统中，指针大小为 8 个字节)

- 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，==该表是一个一维数组，虚表里保存了虚函数的入口地址==
- **编译器会在每个对象的前8个字节中保存一个虚表指针，即vptr**，指向对象所属类的虚表，在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数
- 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；==当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面==

**<font color='red'>那如果派生类有自己的虚函数呢，基类能看见吗</font>**

通过基类指针或引用，无法调用派生类中新增加的虚函数，因为基类中没有这些函数的声明和条目。基类指针只知

道基类中声明的虚函数，并在运行时通过虚表指针（vptr）调用重写后的函数实现

### **<font color='red'>虚函数可以内联吗</font>**

虚函数在 C++ 中**可以**被声明为内联函数，但它们**通常不会被内联**

==冲突来源：==

**虚函数的特性**：虚函数的主要目的是支持**动态绑定**，也就是在运行时根据对象的实际类型调用对应的函数实现。这种机制依赖于虚函数表（vtable），只有在程序运行时才能确定调用的是哪个函数。

**内联函数的特性**：内联函数的目的是为了**优化性能**，在编译时将函数的代码直接插入到调用点，避免函数调用的开销。内联函数在编译时需要确定调用的具体函数实现。

==虚函数内联的可能性：==

1、编译器能够确定对象的静态类型（如在编译时确定了具体类型）。

2、虚函数调用并未涉及多态机制（如直接调用派生类的函数，而不通过指针或引用）。

```cpp
struct Base {
    inline virtual void show() {
        std::cout << "Base show" << std::endl;
    }
};
struct Derived : public Base {
    void show() override {
        std::cout << "Derived show" << std::endl;
    }
};
int main() {
    Derived d;
    d.show();  // 这里编译器知道 d 是 Derived 类型，可以内联 show()
    return 0;
}
```

不能确定，不能内联

```cpp
Base* b = new Derived();
b->show();  // 这里不能内联，因为要在运行时根据实际对象决定调用哪个函数
```

==总结==

**可以声明**虚函数为内联函数，但它们**通常不会被内联**，因为虚函数的调用依赖于运行时的动态绑定。

**当编译器可以确定对象的具体类型时**，虚函数有可能被内联，但这通常只在非多态调用的情况下发生。

**<font color='red'>虚函数表和虚表指针是两个不同的概念吗，一个类中只能有一个虚表指针吗</font>**

==虚函数表（vtable）==

- **虚函数表**是一个由指针组成的数组，这些指针指向类的虚函数的实现。
- 每个具有虚函数的类都有一个虚函数表。该表在编译时生成，并在运行时用于动态绑定。
- 虚函数表包含该类的所有虚函数的地址。

==虚表指针（vptr）==

- **虚表指针**是一个指针，指向虚函数表。
- 每个包含虚函数的类的对象都有一个vptr。
- vptr在对象的构造函数中初始化，指向该对象所属类的虚函数表。
- vptr用于在运行时决定调用哪个具体的虚函数。

==一个类中只能有一个虚表指针吗？==

一个类是否只有一个vptr取决于继承关系：

1. **单继承**：
   - 如果一个类只进行单继承（或者不继承），则该类的每个对象通常只有一个vptr，指向该类的虚函数表。
2. **多继承**：
   - 如果一个类进行多继承，它会有多个基类，每个基类都有自己的虚函数表。
   - 因此，该类的每个对象可能有多个vptr，每个vptr指向相应基类的虚函数表。

**<font color='red'>举个你在项目中多态的例子</font>**

**消息处理系统**，其中有多种消息类型，比如文本消息、图像消息和视频消息。我们希望系统能够以相同的方式处理

不同类型的消息，而无需为每种消息类型编写重复的处理代码

### **<font color='red'>类如何实现只能静态分配和只能动态分配</font>**

静态分配：==单例模式==

动态分配：

==工厂模式：==构造、析构函数设为**protected属性**，再用子类来动态创建

==静态成员函数==

### **<font color='red'>函数指针</font>**

```cpp
int add(int a, int b) {
    return a + b;
}
int subtract(int a, int b) {
    return a - b;
}
int main() {
    // 声明一个函数指针，指向接受两个整数参数并返回整数的函数
    int (*operation)(int, int);
    // 初始化函数指针，使其指向add函数
    operation = &add;
    // 使用函数指针调用add函数
    int result = operation(5, 3);
    // 将函数指针指向subtract函数
    operation = &subtract;
    // 使用函数指针调用subtract函数
    result = operation(5, 3);
    return 0;
}
```

### **<font color='red'>如何阻止一个类被实例化？</font>**

==多态：==将类定义为抽象基类

==单例模式：==不允许类外部创建类对象，只能在类内部创建对象

### **<font color='red'>为什么析构函数一般写成虚函数</font>**

==不写：==由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类

析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放；==因为此时的虚函数表里面找不到派生类的析构指针，所以无法去调用它==

==写了：==如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而

不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成==内存泄漏==

**<font color='blue'>最主要的目的是防止内存泄漏</font>**

**<font color='blue'>析构函数可以是纯虚函数</font>**

**<font color='red'>为什么而派生类的析构函数又自动调用基类的析构函数</font>**

这是因为当一个派生类对象被销毁时，需要确保其基类部分也被正确地销毁。这个过程由编译器自动处理，遵循严格的析构顺序规则

### **<font color='red'>构造函数能不能写成虚函数</font>**

**构造函数的目的是初始化对象**：如果基类构造函数是虚函数，且在基类构造函数中调用虚函数，编译器需要确定调用的是基类版本还是派生类版本的虚函数，而此时派生类对象尚未完全构造好，可能导致未定义行为。

**虚函数表的初始化：**如果构造函数是虚函数，就需要==通过虚函数表调用==，可是对象没有初始化就没有虚函数表，==无法找到虚函数实际地址==；当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的虚函数表

**虚函数机制依赖于对象完全构造**：虚函数机制依赖于 vptr 正确指向合适的 vtable。在对象完全构造之前，vptr 可能尚未正确设置，导致虚函数调用失败或错误。

**<font color='red'>如果派生类不用override去重写，而是和父类用一用的函数名字会发生啥</font>**

1、如果派生类中的函数与基类中的函数同名但没有使用 `override` 关键字明确表示重写，这会导致基类函数在派生类中被隐藏。

2、为了避免这种情况，应使用 `virtual` 关键字在基类中声明函数，并在派生类中使用 `override` 关键字明确表示重写，从而确保正确的函数调用和多态行为。

3、可以用过基类指针访问对应的虚函数

### **<font color='red'>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</font>**

**虚函数表的特征**

1、虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成

2、虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段

3、由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在**对象内存布局的最前面**。

一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区

C++中虚函数表位于C++内存模型中的==常量区==（全局只读数据区）；而虚函数C++内存模型中的==代码区==。

**<font color='red'>虚函数的代价是什么？</font>**

带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类

带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小

### **<font color='red'>哪些函数不能是虚函数？</font>**

构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化

静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义

友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法

普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数

### **<font color='red'>你知道空类的大小是多少吗？</font>**

==C++空类的大小不为0，不同编译器设置不一样==，vs设置为1；

==带有虚函数的C++类大小不为1==，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；

C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了

==每个实例均有独一无二的内存地址==。

**<font color='red'>若一个子类继承自空类，子类多大？为什么</font>**

空类为1，但是子类如果有int之类的不会把这个1加上去

### **<font color='red'>如果在类的析构函数中调用delete this，会发生什么？</font>**

会导致堆栈溢出

delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。

delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出

==如果确实需要在类的某个方法中调用 `delete this`，务必确保对象是动态分配的，并且在调用 `delete this` 后==

==不会再访问该对象。==

**<font color='red'>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</font>**

对象被删除且不可再使用

### **<font color='red'>有哪些设计模式？</font>**

==单例模式（Singleton Pattern）：==确保一个类只有一个实例，并提供一个全局访问点来访问该实例

==工厂模式（Factory Pattern）：==定义一个用于创建对象的接口，但是将实际创建工作延迟到子类中。这样可以使客户端代码与具体创建的类解耦，从而更容易扩展和维护系统

==观察者模式（Observer Pattern）：==定义了一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。这种模式被广泛用于事件驱动系统中

## STL

### **<font color='red'>什么是STL？</font>**

**容器（Containers）：** 关联性数据结构和非关联性数据结构

**算法（Algorithms）：** 提供了各种通用算法，如排序、查找、遍历等

**迭代器（Iterators）：** 通过迭代器，可以以统一的方式对容器中的元素进行遍历和访问，而不需要关心具体的容器类型

**适配器（Adapters）：** 提供了一些适配器类模板，stack、queue 和优先队列适配器 priority_queue

**仿函数（Functors）：** 也称为函数对象，是一种行为类似函数的对象。STL中的算法通常通过仿函数来实现其功能，用户也可以自定义仿函数来满足特定的需求

**分配器（Allocators）：** 提供了一种灵活的内存管理机制，可以控制容器的内存分配和释放行为。用户可以自定义分配器来满足特定的内存管理需求

### **<font color='red'>stack实现</font>**

在 C++ 中，`stack` 适配器是基于底层容器实现的，比如 `deque`, `vector`, 或 `list`。`stack` 本身并不是一个容器，而是一个容器适配器，它仅允许在一端进行操作（后进先出，LIFO）

### **<font color='red'>C++中vector和list有啥区别</font>**

==内部数据结构：==

vector它在内存中连续存储元素，因此支持随机访问

list是双向链表，不支持随机访问

==增删改查：==

增删：vector可能是O(n)，list是O(1)

如果需要频繁地执行插入和删除操作，且不需要随机访问元素，那么 `list` 可能更合适

而如果需要频繁地随机访问元素，且插入和删除操作较少，那么 `vector` 可能更有效率

**<font color='red'>使用迭代器删除元素和双指针有啥区别</font>**

实际上，并不是说被删除元素的内存到了尾部，而是说在`std::vector`和`std::deque`这类容器中，删除元素之后，容器内部的元素可能会向前移动来填补被删除元素的位置。这意味着容器的容量（capacity）保持不变，但大小（size）减少了。

要显式地释放`std::vector`或`std::deque`中的多余内存，你可以采取以下措施之一：

**调用 `shrink_to_fit()`**：

- 这个方法尝试将容器的容量调整为当前大小，从而释放未使用的内存。但是，这不是强制性的，实现可以选择忽略这个请求。

**交换技术**：

- 使用“交换清空”的方式也可以释放多余的内存。通过将容器与一个空容器交换，容器将释放其所持有的所有多余内存

```cpp
template <typename T>
class MyVector {
private:
    T* data;
    size_t capacity;
    size_t size;

    void expand() {
        size_t newCapacity = capacity == 0 ? 1 : capacity * 2;
        T* newData = new T[newCapacity];
        for (size_t i = 0; i < size; ++i) {
            newData[i] = std::move(data[i]);
        }
        delete[] data;
        data = newData;
        capacity = newCapacity;
    }

public:
    MyVector() : data(nullptr), capacity(0), size(0) {}

    ~MyVector() { delete[] data; }

    void push_back(const T& value) {
        if (size == capacity) {
            expand();
        }
        data[size++] = value;
    }

    size_t getSize() const { return size; }
    size_t getCapacity() const { return capacity; }

    T& operator[](size_t index) { return data[index]; }
};
```

### **<font color='red'>说一下C++左值引用和右值引用</font>**

**左值**是可以取地址的、有名字的对象，它们在内存中有持久的存储位置

**右值**是没有名称、临时存在的对象，通常是表达式的结果，无法在多个语句中使用

**左值引用**是指向**左值**的引用，使用符号`&`表示

**右值引用**是指向**右值**的引用，使用符号`&&`表示

==右值引用的主要作用有两个方面：==

**移动语义**：通过右值引用，可以实现资源（如动态分配的内存、文件句柄等）的有效转移，而不是简单的拷贝。这在处理临时对象时特别有用，可以提升程序的性能，减少内存分配和释放的开销

**完美转发**：右值引用还用于实现通用代码中的完美转发，即在不失去参数类型信息的情况下，将参数（无论是左值还是右值）传递给其他函数。使用`std::forward`可以帮助实现这一点，确保参数的值类别保持一致

### **<font color='red'>完美转发</font>**

完美转发通常在两个主要的场景下使用：

- **传递参数给模板或泛型函数**：当模板或泛型函数需要将参数转发给其他函数时，可以使用完美转发确保传递的参数类型和引用类型保持不变。

- **传递参数给其他类的构造函数或成员函数**：在编写包装类（wrapper class）或代理类（proxy class）时，经常需要将构造函数或成员函数的参数传递给内部对象，完美转发可以帮助保持原始参数的类型和引用属性。

完美转发主要依赖于两个重要的特性：

- **右值引用（Rvalue Reference）**：C++11引入的`&&`语法，用于标识临时对象或将要销毁的对象。
- **`std::forward`函数模板**：C++11标准库中提供的一个工具函数，用于将参数完美转发给其他函数，确保参数的值类别和`const`属性保持不变。

### **<font color='red'>怎么解决哈希冲突</font>**

**链式地址法**：通过链表或其他数据结构解决冲突，适用于负载较高且需要动态扩展的情况。

**开放地址法**：包括线性探测法、二次探测法和双重哈希法，适用于内存占用需要较小的场景，但可能会遇到聚集问题。

**再哈希**：在哈希表负载过高时，通过扩大表的大小并重新计算哈希值来减小冲突。

**动态扩容**：通过调整负载因子，控制哈希表的大小，减少冲突的发生。

**<font color='red'>哈希map插入一个数据的过程，它内部是怎么判断的</font>**

`unordered_map` 通过哈希函数计算键的哈希值，用于决定键值对的存储桶。

冲突时，使用链表（或开放寻址）来处理冲突。

插入时，`unordered_map` 会查找冲突的键并判断重复。

为了保持性能，当负载因子超出阈值时，`unordered_map` 会自动增加桶的数量并再哈希。

**<font color='red'>在哈希桶里面它的哈希冲突是怎么优化的,底层数据结构转换逻辑</font>**

**链地址法的链表转红黑树**：在桶内链表过长时，转换为红黑树以提高查找速度；当某个桶的链表长度超过一定阈值（通常为 8）时，`std::unordered_map` 会将该桶内的链表转换为红黑树结构。

**扩展重哈希**：当负载因子过高时，扩展哈希表并重新分配元素，减少冲突。

### **<font color='red'>讲一下STL中在什么情况下会造成迭代器失效？（分顺序式容器和关联式容器去讲）</font>**

==对容器进行增删改查使得元素的位置发生变化，从而使得原来指向这些元素的迭代器失效==

**<font color='purple'>容器类型</font>**

- **顺序容器**：顺序存储，插入和删除元素可能导致迭代器失效。
  - **vector**：动态数组，支持快速随机访问和在末尾插入或删除元素。
  - **deque**：双端队列，支持在两端高效地插入和删除元素。
  - **list**：双向链表，支持在任意位置高效地插入和删除元素，`erase`操作不会使其他迭代器失效。
  - **forward_list**：单向链表，只支持在头部插入和删除元素。
- **关联容器**：键值对存储，插入和删除元素也可能导致迭代器失效，尤其是在容器内部的树结构变化时。
  - **set**：有序集合，内部以红黑树实现，元素按照键值有序排列。
  - **multiset**：允许重复键值的有序集合。
  - **map**：有序映射表，键值对按照键有序排列。
  - **multimap**：允许重复键的有序映射表。

**<font color='red'>map中删除元素</font>**

第一

```cpp
// 使用迭代器遍历并删除值小于 30 的元素
for (auto it = myMap.begin(); it != myMap.end(); /* no increment here */) {
    if (it->second < 30) {
        it = myMap.erase(it); // erase() 返回下一个有效的迭代器
    } else {
        ++it; // 只有在没有删除时才增加迭代器
    }
}
```

第二

```cpp
auto it = mp.begin();
auto next = it;  // 用于跟踪下一个元素

while (it != mp.end()) {
    next = it;
    ++next;  // 移动到下一个元素
    if (it->first % 2) {
        mp.erase(it);
        maxNum = std::max(maxNum, it->first);
        std::cout << it->first << std::endl;
    }
    it = next;  // 更新当前迭代器
}
```

第三

```cpp
for(auto it = testMap.begin(); it != testMap.end();)
{
   if(it->second == xxx)
   {
        testMap.erase(it++);  
   }
   else
   {
       it++;
   }
} 
```

### **<font color='red'>讲一下STL的有哪些常用的容器，各有什么特点</font>**

顺序式容器：std::vector、std::deque、std::list 和 std::forward_list

关联式容器：std::set、std::map、std::multiset 和 std::multimap、unordered_set、unordered_map

容器适配器：std::stack、std::queue 和 std::priority_queue

### **<font color='red'>STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</font>**

==1.5倍的扩容策略==

```cpp
int main() {
    std::vector<int> vec;
    size_t last_capacity = vec.capacity();
    std::cout << "Initial capacity: " << last_capacity << std::endl;
    for (int i = 0; i < 10000; ++i) {
        vec.push_back(i);

        if (vec.capacity() != last_capacity) { // 检测到容量变化
            std::cout << "Size: " << vec.size()
                << ", New Capacity: " << vec.capacity()
                << ", Growth factor: " << static_cast<double>(vec.capacity()) / last_capacity
                << std::endl;
            last_capacity = vec.capacity();
        }
    }
    return 0;
}
```

由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有

效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收

对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了

```cpp
// 彻底释放内存空间
std::vector<int>().swap(vec);
```

**<font color='red'>resize()` 和 `reserve()区别</font>**

**`resize(n)`**：改变容器中**元素的数量**，即修改 `size`，并可能影响 `capacity`。

- 如果 `n` **大于当前的 `size`**，则容器会新增元素，并更新 `size`。如果 `n` **大于当前的 `capacity`**，容器会重新分配内存，扩大 `capacity`。
- 如果 `n` **小于当前的 `size`**，则容器会移除多余的元素，`size` 减小，**但 `capacity` 不会改变**。

**`reserve(n)`**：只影响容器的**容量 (`capacity`)**，不改变当前的 `size`（元素的数量）。

- 如果 `n` **大于当前的 `capacity`**，容器会分配足够的内存来存储 `n` 个元素，**`capacity` 会增大**。
- 如果 `n` **小于等于当前的 `capacity`**，`reserve()` **不会改变 `capacity`**，也不会影响 `size`。

**<font color='red'>vector是分配在栈上还是堆上</font>**

- `std::vector` 的数据存储在堆上，这样可以动态地增长和缩减。
- `std::vector` 的对象本身可能位于栈上，但这主要是指控制结构（如指针、大小和容量信息等）。
- `std::vector` 自动管理其内部的内存，无需手动释放内存。

### **<font color='red'>STL迭代器如何实现</font>**

**<font color='red'>迭代器：++it、it++哪个好，为什么</font>**

- **++it:**是前置递增操作符。它会先将迭代器递增，然后返回递增后的迭代器的引用
- **it++:**是后置递增操作符。它会返回当前迭代器的原始值，然后再将迭代器递增

- 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低

### vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？

==map：==如果不存在这个key，就将一个具有该key和value的值插入这个map

通过下标访问vector中的元素时会做边界检查

erase()函数，只能删除内容，不能改变容量大小

erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器

clear()函数，只能清空内容，不能改变容量大小

通常情况下，被删除元素之后的迭代器会失效，而指向被删除元素之前的迭代器仍然有效

**<font color='red'>vector中push_back和emplace_back的区别？</font>**

==push_back== 接受的是元素的副本

==emplace_back==直接在 vector 的尾部构造新元素

**<font color='red'>emplace_back是用new来构造吗（回答错啦）</font>**

使用 `emplace_back` 不需要显式地使用 `new` 来创建对象。相反，你只需传递构造函数所需的参数给 

`emplace_back`，它会在向量的末尾直接调用类的构造函数来创建对象。

**<font color='red'>如果把类push_back到vector里面，大小是多少？如果给他添加一个虚析构函数，类的大小是多少？会变化吗？</font>**

**没有虚析构函数**：类的大小就是成员变量的大小。例如：`sizeof(A)` 为 4 字节（一个 `int`）。

**有虚析构函数**：类的大小会因为虚函数表指针而增加。例如，在 32 位系统中，`sizeof(A)` 增加到 8 字节；在 64 位系统中，`sizeof(A)` 增加到 16 字节==（内存对齐）==

### STL中list与queue之间的区别

**数据结构**：

- `list` 是双向链表，每个元素都包含指向前一个和后一个元素的指针。
- `queue` 是队列，通常使用其他数据结构来实现，比如双端队列（deque）或者数组。

**功能**：

- `list` 是一个通用的双向链表容器，可以在任意位置插入和删除元素，并支持高效的随机访问。
- `queue` 是一个队列，只允许在队尾插入元素，在队首删除元素，并且遵循先进先出（FIFO）的原则。

**接口**：

- `list` 提供了丰富的成员函数，包括插入、删除、查找等操作。
- `queue` 提供了入队、出队、获取队首元素等基本操作。

**使用场景**：

- `list` 适合需要频繁在中间位置插入或删除元素的场景，因为链表的插入和删除操作时间复杂度为 O(1)。
- `queue` 适合需要先进先出顺序的场景，比如任务调度、消息传递等。

### **<font color='red'>STL中的空间配置器（allocator）</font>**

STL的空间配置器有两种类型：全局空间配置器和局部空间配置器。

1. **全局空间配置器**：通常使用`std::allocator`作为全局的默认空间配置器。它是标准的分配器，实现了`allocate`和`deallocate`等成员函数，用于分配和释放内存。当容器没有提供自定义的空间配置器时，默认会使用`std::allocator`。
2. **局部空间配置器**：某些容器（例如`std::vector`、`std::list`等）可能会使用特定的局部空间配置器。这些局部空间配置器通常被设计用于提高性能或满足特定的需求。例如，`std::vector`通常会使用`std::allocator`作为其默认空间配置器，但也可以通过模板参数来指定自定义的空间配置器。

**我感觉起了一个内存池的效果**

空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；

空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。

**第一级空间配置器**：

当需要分配的内存大小大于128字节时，第一级空间配置器会直接调用系统的`malloc()`进行分配。

第一级空间配置器的性能较差，因为它不能有效地处理内存碎片问题。

**第二级空间配置器**：

它通过自己实现内存池来管理小块内存的分配和释放，以解决第一级空间配置器性能较差的问题。

### STL中哈希表

**<font color='red'>map和哈希map有什么优缺点，适应于什么场景</font>**

map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为O(logn)，但是空间占用比较

大，因为每个节点要保持父节点、孩子节点及颜色的信息

==优点：==稳定的性能、范围查询；==缺点：==相对较慢、内存占用大

unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为

O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大；C++ 中的哈希表使用数组作为底层存储结构，每个数组位置（桶）可以存储一个链表或其他结构来处理哈希冲突

==优点：==高效查找、低内存开销；==缺点：==时间复杂度不稳定、不支持范围查询

从两者的底层机制和特点可以看出：map适用于有序数据，**<font color='purple'>数据量小</font>**的应用场景，unordered_map适用于高效查

询，**<font color='purple'>数据量大</font>**的场景

**<font color='red'>从内存角度这两个有什么区别</font>**

`unordered_map` 的内存布局更加紧凑，在没有哈希冲突时，内存使用效率更高，且具有较好的内存局部性

`map` 需要较多的指针来维护树结构，由于节点不连续分布，内存局部性差，导致在遍历或访问多个元素时性能

**哈希表扩容：**

- 创建新的哈希表、重新哈希元素、释放原哈希表的内存、更新容量和负载因子

**红黑树**：**红黑树是为了解决普通的二叉搜索树在频繁插入、删除等操作下可能产生的不平衡现象而设计的**

- **节点颜色：** 每个节点被标记为红色或黑色。
- **根节点和叶子节点：** 根节点是黑色的，叶子节点（NIL 节点或空节点）是黑色的。
- **颜色约束：** 不能有两个相邻的红色节点；即红色节点的子节点必须是黑色的。
- **黑高度（Black Height）：** 从根节点到其任何叶子节点的简单路径上的黑色节点数必须相同。这个属性确保了树的平衡性。

AVL 树具有以下特性：

1. **平衡性**：对于任意节点，其左右子树的高度差（平衡因子）不超过1。
2. **二叉搜索树性质**：对于任意节点，其左子树中的所有节点的键值小于该节点的键值，右子树中的所有节点的键值大于该节点的键值。
3. **递归定义**：AVL 树的左子树和右子树都是 AVL 树。

与红黑树相比，AVL 树的平衡调整更加频繁，因此在实际应用中，如果对平衡性要求较高，可以选择使用 AVL 

树；而如果更注重性能和简洁性，则可以选择红黑树。

**<font color='red'>为什么要用红黑树而不是平衡二叉树？</font>**

红黑树通过增加颜色属性和遵循严格的颜色规则，在保持平衡方面具有较高的效率和较低的维护成本

虽然 AVL 树在查找操作方面比红黑树略快，因为 AVL 树更加严格地平衡，但在大多数应用中，这种差异并不显著

**<font color='red'>对于较大规模的数据优化unordered_map的方法</font>**

预先分配空间、使用自定义的哈希函数、调整负载因子

## C++11新特性

- nullptr替代 NULL
- 引入了 auto 和 decltype 这两个关键字实现了类型推导
- 基于范围的 for 循环for(auto& i : res){}
- 类和结构体的中初始化列表
- Lambda 表达式（匿名函数）
- std::forward_list（单向链表）
- 右值引用和move语义

### **<font color='red'>右值引用和move语义</font>**

**右值引用（Rvalue References）：**

- 右值引用可以绑定到右值（临时对象），但不能绑定到左值（非临时对象）
- 右值引用主要用于实现移动语义，允许将资源从一个对象“窃取”并转移到另一个对象，而不是进行传统的深拷贝

**Move 语义**：

- Move 语义通过将资源（如动态分配的内存、文件句柄等）的所有权从一个对象转移到另一个对象，避免了不必要的内存分配和复制操作
- Move 语义的实现依赖于右值引用。通常，我们会为类实现移动构造函数和移动赋值运算符，以实现资源的有效转移和管理

**<font color='red'>C++中的move怎么实现的，解决什么问题，怎么解决的</font>**

**实现原理**：`std::move` 是一个类型转换，它将对象转换为右值引用，提示编译器可以使用移动语义。

**移动语义：**允许在不进行深层复制的情况下转移对象的所有权

**解决的问题**：解决了对象拷贝的高性能开销，特别是对于资源密集型对象（如内存、文件句柄等），通过移动资源而不是拷贝资源提高了效率。

**解决的方式**：`std::move` 将对象转换为右值引用，使得程序可以调用对象的**移动构造函数**和**移动赋值运算符**，实现高效的资源转移而非复制。

**<font color='red'>左值引用和右值引用可以相互转换吗</font>**

1、**左值引用**：用来引用可以被持久访问的内存对象；**右值引用**：用来引用即将被销毁的临时对象

2、左值引用不能绑定到右值上；右值引用（`T&&`）一般用于绑定右值，但通过 **`std::move`**，我们可以将左值显式地转换为右值引用

3、完美转发： C++11 引入的一种特性，使用 `T&&`，在模板类型推导时可以同时绑定左值和右值

```cpp
template<typename T>
void foo(T&& arg) {
    // arg 可以是左值引用或右值引用
}

int x = 10;
foo(x);      // 传递左值，T 推导为 int&，arg 是 int& 类型（左值引用）
foo(10);     // 传递右值，T 推导为 int，arg 是 int&& 类型（右值引用）
```

4、**`std::forward`**：在模板中用于实现完美转发，它根据传入的参数类型决定是否保持左值或右值的属性

```cpp
template <typename T>
void bar(T&& t) {
    foo(std::forward<T>(t));  // 根据 T 的类型保持左值或右值
}
```

### **<font color='red'>auto、decltype和decltype(auto)的用法</font>**

**auto ：**让编译器通过初始值来进行类型推演

**decltype：**关键字用于获取表达式的类型，并且不会进行类型转换。它主要用于编译时类型推导，可以用于变量声明、返回类型推导等

**decltype(auto)**：用于声明变量时，**保留表达式的引用特性和常量**属性，并根据表达式的类型推导出变量的类型

### **<font color='red'>C++中NULL和nullptr区别</font>**

`NULL` 是一个宏，通常被定义为整数值 0，而 `nullptr` 是一个关键字，它的类型是 `nullptr_t`

`NULL` 可能会导致类型歧义和错误的使用场景，而 `nullptr` 是类型安全的，不能隐式转换为整数或其他类型

### **<font color='red'>完美转发</font>**

定义：它允许函数在接受参数时保持其原始的左值或右值属性，并将参数完美地转发给其他函数

完美转发的主要优点在于==它能够在转发参数时保留其原始的左值或右值属性，同时避免不必要的复制或移动操作==

```cpp
#include <iostream>
#include <utility>
// 接受任意类型的参数并转发给其他函数的模板函数
template<typename T>
void wrapper(T&& arg) {
    // 将参数完美转发给其他函数
    forwarder(std::forward<T>(arg));
}
// 接受参数的具体实现函数
void forwarder(int& x) {
    std::cout << "Lvalue reference: " << x << std::endl;
}
void forwarder(int&& x) {
    std::cout << "Rvalue reference: " << x << std::endl;
}
int main() {
    int x = 42;
    wrapper(x); // Lvalue reference: 42
    wrapper(42); // Rvalue reference: 42
    return 0;
}
```

## 模板

**<font color='red'>平时都建议把C++模板类的实现，放到头文件中，基于什么考虑？</font>**

核心原因：C++ 模板的代码会在**编译时**生成特定类型的代码，这叫**实例化**。编译器必须要看到模板的完整实现，才能在使用时生成具体类型的代码。

==如果模板实现不在头文件：==如果实现放在 .cpp 文件中，编译器在编译头文件时只能看到类的声明，但看不到实现。因此它不知道如何生成具体类型的代码。

==头文件中的实现如何解决这个问题：==把实现放在头文件中，编译器就能在每个包含头文件的地方看到完整的模板代码，从而生成所需的代码。简而言之：

- **头文件**：让编译器知道模板的所有细节。
- **模板实例化**：编译器在看到具体类型时会生成相应的实现。

**<font color='red'>C++一个虚函数可以定义成模板函数吗？</font>**

在 C++ 中，**虚函数**不能直接定义为**模板函数**。这是因为模板函数的类型在编译时才会确定，而虚函数的动态多态特性要求在运行时通过虚表（vtable）来决定调用哪个函数。这两者的特性是相互冲突的。

**虚函数的动态绑定**：

- 虚函数的调用是在运行时通过虚表（vtable）实现的。每个类的虚函数在编译时会被编入虚表，虚表的目的是支持在运行时确定调用的具体函数（多态性）。

**模板函数的编译期多态**：

- 模板函数在编译时通过模板参数实例化。模板的不同参数会生成不同的函数代码，这意味着编译器需要在编译期就确定模板的具体类型和实现。

**虚表和模板实例化的冲突**：

- 虚表要求编译器提前知道虚函数的具体类型，而模板的类型在使用时才能确定，因此编译器无法把模板函数放入虚表。
- 模板函数无法在虚表中动态分配给一个具体类型，因为它在编译期并没有固定的实现（它的实现依赖于模板实例化）。

==解决办法：==

**使用模板类中的非模板虚函数**：将模板类作为接口或基类，而虚函数本身并不使用模板参数。

**手动分发函数模板调用**：在虚函数中调用不同的模板实现。

**<font color='red'>如果我在一个头文件中定义一个函数，这里会有什么问题吗？</font>**

==1、多重定义错误：==如果头文件被多个源文件（.cpp 文件）包含，那么头文件中的函数定义也会被多次包含和编译，导致多个源文件之间有重复的定义。

2、如何避免多重定义：`inline` 关键字；`inline` 并不保证函数一定会被内联（实际的内联取决于编译器优化），只是允许它在多个文件中定义而不报错

**<font color='red'>\#pragma once可以避免这种现象吗</font>**

`#pragma once` 可以避免头文件在**同一个编译单元**中被多次包含，但无法解决函数在**不同编译单元**中的多重定义问题。要避免函数重复定义，应使用 `inline` 关键字或将实现放在 `.cpp` 文件中

### **<font color='red'>模板</font>**

模板：程序员可以编写与具体数据类型无关的函数和类，极大地提高了代码的灵活性和效率。

1、函数模板：函数模板允许你编写一个函数，而不必指定它的具体数据类型。

```cpp
// 定义一个通用的函数模板
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

2、类模板：类模板允许你定义一个类，而不必指定它的具体数据类型

```cpp
// 定义一个通用的类模板
template <typename T>
class Pair {
private:
    T first, second;
public:
    Pair(T a, T b) : first(a), second(b) {}
    T getFirst() const { return first; }
    T getSecond() const { return second; }
};
```

3、模板特例化：模板特化允许你为特定类型提供不同的实现

```cpp
// 通用模板
template <typename T>
class Printer {
public:
    void print(T value) {
        std::cout << "Value: " << value << std::endl;
    }
};

// 针对const char* 类型的特化
template <>
class Printer<const char*> {
public:
    void print(const char* value) {
        std::cout << "String: " << value << std::endl;
    }
};
```

4、在调用模板函数时，编译器可以根据传递的参数自动推导模板实参类型。模板参数不仅可以是类型，还可以是值，如整数、指针等

**<font color='blue'>ps：</font>**模板函数可以特例化

```cpp
template<typename T>
bool isEqual(const T& a, const T& b) {
    return a == b;
}
// 字符串特例化
template<>
bool isEqual<std::string>(const std::string& a, const std::string& b) {
    return a.compare(b) == 0;
}
```

###  lambda函数

==值传递、引用传递、按特定值传递、按特定引用传递、混合传递==

- Lambda 函数通常用于需要短小、临时的代码片段，并且能够方便地捕获外部变量
- 内联函数则更适合于需要重复调用的、可读性较高的代码块
- 捕获可以通过值捕获（`[var]`）、引用捕获（`[&var]`）、隐式值捕获（`[=]`）和隐式引用捕获（`[&]`）来实现

```cpp
[capture-list] (parameter-list) -> return-type {
    // 函数体
}
//谓词
std::vector<int> vec = {1, 2, 3, 4, 5};
int count = std::count_if(vec.begin(), vec.end(), [](int n) { return n % 2 == 0; });
int x = 5;
auto func = [&]() -> int {return x * 2;};
```

### **<font color='red'>智能指针（底层代码实现）</font>**

RAII（资源获取即初始化）：构造函数中申请分配资源，在析构函数中释放资源

- shared_ptr内部的引用计数是**线程安全**的，但是对象的读取需要加锁
- unique_ptr对象是线程安全的

`std::unique_ptr` 本身并不是线程安全的，`std::unique_ptr` 拥有对其所管理的资源的独占所有权，这有助于避免多个线程同时访问同一资源，从而避免了竞争条件

- weak_ptr也是需要加锁

```cpp
std::shared_ptr<int> ptr1(new int(42));//直接初始化
std::shared_ptr<int> ptr2 = ptr1;//拷贝初始化
auto ptr3 = std::make_shared<int>(42);//使用 make_shared
ptr1.reset(new int(42));

std::unique_ptr<int> ptr1(new int(42));  // 直接初始化
auto ptr2 = std::make_unique<int>(42);   // 使用 make_unique 初始化
std::unique_ptr<int> ptr3 = std::move(ptr1);  // 移动所有权

std::shared_ptr<int> sptr(new int(42));  // 创建 shared_ptr
std::weak_ptr<int> wptr(sptr);           // 创建 weak_ptr
if (auto ptr = wptr.lock()) {            // 获取 shared_ptr
    // 在 ptr 不为空的情况下使用资源
}
```

**<font color='red'>unique_ptr怎么做到的单独拥有一块内存，而不是和别人共享一块内存？</font>**

`unique_ptr` 的核心在于它的设计使得**任何时候只有一个 `unique_ptr` 指向同一块资源**。

通过禁用拷贝、使用移动语义、并在销毁时自动释放资源，`unique_ptr` 做到了“独占”内存。

这种设计确保了 `unique_ptr` 的所有权语义，使得它的资源独占性（独占内存）在程序中得以实现。

**<font color='red'>指针可以相互转换吗</font>**

**从 `unique_ptr` 转换为 `shared_ptr`** 是允许的，可以通过 `std::move()` 实现，这样可以安全地将独占所有权转为共享所有权。

**从 `shared_ptr` 转换为 `unique_ptr`** 是不允许的，因为这会破坏共享所有权模型，C++ 标准库也没有提供直接的支持。

### 智能指针的循环引用

循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况

可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构

weak_ptr.lock()延长指针生命周期会发生什么问题：多线程下先检查 weak_ptr 是否有效，以避免空指针错误

```cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    ~MyClass() { std::cout << "Destructor of MyClass" << std::endl; }
};

int main() {
    std::shared_ptr<MyClass> sharedPtr = std::make_shared<MyClass>();
    std::weak_ptr<MyClass> weakPtr = sharedPtr;

    // 输出引用计数
    std::cout << "sharedPtr use count: " << sharedPtr.use_count() << std::endl;

    // 使用weakPtr观察对象
    if (auto observedPtr = weakPtr.lock()) {
        std::cout << "Object exists!" << std::endl;
    } else {
        std::cout << "Object expired!" << std::endl;
    }

    // 手动释放sharedPtr
    sharedPtr.reset();

    // 再次使用weakPtr观察对象
    if (auto observedPtr = weakPtr.lock()) {
        std::cout << "Object exists!" << std::endl;
    } else {
        std::cout << "Object expired!" << std::endl;
    }

    return 0;
}

```

### **<font color='red'>讲一下C++11中的智能指针有哪些？解决什么问题？是怎么解决的？共享指针是如何实现共享的？独占指针是如何保证独占的？</font>**

**<font color='purple'>std::unique_ptr：</font>**

- `std::unique_ptr` 是一种独占式智能指针，它所管理的对象是唯一的，没有其他指针可以指向同一块内存
- 当 `std::unique_ptr` 离开作用域时，它所管理的对象会被自动释放，从而避免了内存泄漏。
- **复制构造函数和复制赋值运算符被删除、移动构造函数和移动赋值运算符来转移所有权**
- 通过使用 `std::move` 函数，可以将所有权转移给另一个 `std::unique_ptr`，实现所有权的转移。

**<font color='purple'>std::shared_ptr：</font>**

- `std::shared_ptr` 是一种共享式智能指针，可以多个 `std::shared_ptr` 指向同一块内存
- 内部使用引用计数来跟踪管理的对象的引用次数，当引用次数为 0 时自动释放内存
- **构造函数、复制构造、移动构造会加一、析构函数会减一**
- 可以通过 `std::make_shared` 来创建 `std::shared_ptr`，推荐使用这种方式。

**<font color='purple'>std::weak_ptr：</font>**

- `std::weak_ptr` 是 `std::shared_ptr` 的一种弱引用，不增加对象的引用计数。

- 主要用于解决 `std::shared_ptr` 的循环引用问题，避免出现内存泄漏。

- 可以通过 `lock()` 方法获取一个 `std::shared_ptr` 的临时拷贝。

智能指针解决了手动管理内存可能导致的**内存泄漏**和**资源泄漏**的问题

独占指针：拷贝构造函数和复制运算符声明为private，定义移动构造函数和移动赋值运算符

共享指针：使用引用计数来实现共享

```cpp
// 删除复制构造函数和复制赋值运算符
MyUniquePtr(const MyUniquePtr&) = delete;
MyUniquePtr& operator=(const MyUniquePtr&) = delete;

// 移动构造函数
MyUniquePtr(MyUniquePtr&& other) noexcept {
    ptr = other.ptr;
    other.ptr = nullptr;
}

// 移动赋值运算符
MyUniquePtr& operator=(MyUniquePtr&& other) noexcept {
    if (this != &other) {
        delete ptr;
        ptr = other.ptr;
        other.ptr = nullptr;
    }
    return *this;
}
```

**<font color='red'>举一个循环引用的例子在智能指针中</font>**

两个类相互持有对方的指针

## code

### **<font color='red'>单例模式</font>**

```cpp
#include <iostream>

class Singleton {
public:
    // 获取实例的静态方法
    static Singleton& getInstance() {
        // 使用静态局部变量保证线程安全的懒汉式单例模式
        static Singleton instance;
        return instance;
    }

    // 示例方法
    void showMessage() {
        std::cout << "Hello, I am a singleton instance!" << std::endl;
    }

private:
    // 私有构造函数，防止外部调用构造函数创建对象
    Singleton() {}

    // 删除拷贝构造函数和赋值运算符，防止拷贝和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    // 获取单例实例
    Singleton& singleton = Singleton::getInstance();

    // 使用单例实例
    singleton.showMessage();

    return 0;
}

```

**饿汉式（Eager Initialization）**：

- 在程序运行时，即在单例类被加载时就创建单例对象实例，而不管是否真正需要使用该实例。
- 在饿汉式中，单例对象的实例在程序启动时就已经创建好了，因此不存在**线程安全**的问题。

**懒汉式（Lazy Initialization）**：

- 在程序运行时，只有在需要使用单例对象时才创建单例对象实例，也就是在调用 `getInstance()` 方法时创建实例。
- 懒汉式需要在获取单例对象的方法中进行**线程安全**的实现，以确保多线程环境下单例对象的唯一性。

### **<font color='red'>编程题：三个线程，依次打印1-100</font>**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
int count = 1;

void printNumber(int threadId) {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [threadId] { return (count % 3) == threadId || count > 100; });

        if (count > 100) {
            cv.notify_all();
            return;
        }

        std::cout << "Thread " << threadId << ": " << count << std::endl;
        count++;
        cv.notify_all();
    }
}

int main() {
    std::thread t1(printNumber, 1);
    std::thread t2(printNumber, 2);
    std::thread t3(printNumber, 0);

    t1.join();
    t2.join();
    t3.join();

    return 0;
}

```

### **<font color='red'>怎么给std::thread传递参数</font>**

==使用 Lambda 表达式==

使用 Lambda 表达式可以直接捕获外部作用域的变量，并将其作为参数传递给线程函数。例如：

```cpp
#include <iostream>
#include <thread>

void threadFunction(int a, const std::string& str) {
    std::cout << "Thread function: a = " << a << ", str = " << str << std::endl;
}

int main() {
    int a = 42;
    std::string message = "Hello from main!";

    std::thread t([a, message]() {
        threadFunction(a, message);
    });

    t.join();

    return 0;
}
```

在这个示例中，Lambda 表达式 `[a, message]()` 捕获了 `main` 函数中的 `a` 和 `message` 变量，并将它们作为参数传递给 `threadFunction` 函数。

==使用 `std::bind` 绑定函数==

可以使用 `std::bind` 函数来绑定函数和其参数，创建一个可调用对象，然后将其传递给 `std::thread` 构造函数。例如：

```cpp
#include <iostream>
#include <thread>
#include <functional>

void threadFunction(int a, const std::string& str) {
    std::cout << "Thread function: a = " << a << ", str = " << str << std::endl;
}

int main() {
    int a = 42;
    std::string message = "Hello from main!";

    auto boundFunction = std::bind(threadFunction, a, message);
    std::thread t(boundFunction);

    t.join();

    return 0;
}
```

这里 `std::bind` 将 `threadFunction` 绑定到 `a` 和 `message`，并返回一个可调用对象 `boundFunction`，它可以作为参数传递给 `std::thread`。

在这个例子中，`std::ref(a)` 将 `a` 的引用传递给 `threadFunction`。

==直接值传递示例==

下面是一个示例，演示了如何直接传递值给线程函数：

```cpp
#include <iostream>
#include <thread>

void threadFunction(int a, const std::string str) {
    std::cout << "Thread function: a = " << a << ", str = " << str << std::endl;
}

int main() {
    int a = 42;
    std::string message = "Hello from main!";

    // 直接传递值给线程函数
    std::thread t(threadFunction, a, message);
    t.join();

    return 0;
}
```

在这个例子中，`std::thread t(threadFunction, a, message);` 直接将 `a` 和 `message` 的值传递给 `threadFunction` 函数。这种方式会复制 `a` 和 `message` 的值到新的线程中，因此在 `threadFunction` 中对这些值的修改不会影响主线程中的 `a` 和 `message`。

### **<font color='red'>两个线程交替打印ab</font>**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool isA = true; // 初始时打印 'a'

void printChar(char ch, int count) {
    for (int i = 0; i < count; ++i) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [ch] { return (ch == 'a') ? isA : !isA; }); // 等待条件满足

        std::cout << ch;
        isA = !isA; // 切换到下一个字符
        cv.notify_all(); // 通知其他线程
    }
}

int main() {
    std::thread t1(printChar, 'a', 50); // 打印50个 'a'
    std::thread t2(printChar, 'b', 50); // 打印50个 'b'

    t1.join();
    t2.join();

    std::cout << std::endl;

    return 0;
}
```

### **<font color='red'>线程池</font>**

```cpp
class ThreadPool {
public:
    ThreadPool(size_t num_threads) : num_threads_(num_threads), stop_(false) {
        for (size_t i = 0; i < num_threads_; ++i) {
            threads_.emplace_back([this] {
                while (true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(mutex_);
                        //使当前线程等待，直到被通知或唤醒
                        //wait() 被调用后，会释放锁，让其他线程能够获得锁并继续执行。等待时，该线程会处于阻塞状态。
                        //condition_.wait_for(),最多等待多久
                        condition_.wait(lock, [this] {
                            return stop_ || !tasks_.empty();
                        });
                        // stop_ 为真（true）,或者 tasks_ 非空,当前线程不需要继续等待
                        if (stop_ && tasks_.empty()) {
                            return;
                        }
                        task = std::move(tasks_.front());
                        tasks_.pop();
                    }
                    task();
                }
            });
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(mutex_);
            stop_ = true;
        }
        condition_.notify_all();
        for (std::thread& thread : threads_) {
            thread.join();
        }
    }

    template <class F>
    void submit(F&& f) {
        {
            std::unique_lock<std::mutex> lock(mutex_);
            tasks_.emplace(std::forward<F>(f));//完美转发
        }
        condition_.notify_one();
    }

private:
    size_t num_threads_;
    std::vector<std::thread> threads_;
    std::queue<std::function<void()>> tasks_;
    std::mutex mutex_;
    std::condition_variable condition_;
    std::atomic<bool> stop_;
};
```

### **<font color='red'>函数重载和类重载</font>**

```cpp
class MyInt {
private:
    int value;
public:
    MyInt(int val) : value(val) {}

    // 重载相等操作符
    bool operator==(const MyInt& other) const {
        return value == other.value;
    }
};
//向量重载
Vector operator+(const Vector& vec1, const Vector& vec2) {
    Vector result;
    result.x = vec1.x + vec2.x;
    result.y = vec1.y + vec2.y;
    return result;
}

// 重载 << 运算符
std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << c.real << " + " << c.imag << "i";
    return os;
}
```

**<font color='red'>让你设计一个类，然后这个类是只能在堆上进行那个生成的？ </font>**

第一：将类的构造函数私有化，并提供一个静态的公有成员函数来创建对象，这个静态函数内部使用 `new` 操作符在堆上分配内存并返回指向对象的指针

```cpp
class MyClass {
private:
    MyClass() {} // 私有构造函数
public:
    static MyClass* createObject() {
        return new MyClass(); // 在堆上分配对象
    }
    ~MyClass() {
        // 在析构函数中释放堆上分配的内存
    }
};
```
