## 题单

### 子序列问题

[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/) **反复刷**

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) **反复刷**

[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/) **反复刷**

[491. 非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

### 回溯问题

组合问题

- [77. 组合](https://leetcode.cn/problems/combinations/)
- [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)
- [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
- [39. 组合总和](https://leetcode.cn/problems/combination-sum/)
- [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

分割问题

- [131.分割回文串](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0131.分割回文串.html)
- [93.复原IP地址](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0093.复原IP地址.html)

子集问题

- [698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

- [78.子集](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0078.子集.html)
- [90.子集II](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0090.子集II.html)

排列问题

- [46.全排列](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0046.全排列.html)
- [47.全排列II](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0047.全排列II.html)

棋盘问题

- [51.N皇后](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0051.N皇后.html)
- [37.解数独](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0037.解数独.html)

其他

- [491.递增子序列](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0491.递增子序列.html)
- [332.重新安排行程](https://leetcode.cn/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0332.重新安排行程.html)

## 子序列

[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

不连续递增子序列的跟前0-i 个状态有关，连续递增的子序列只跟前一个状态有关

所以这道题用贪心来求解

```go
func findLengthOfLCIS(nums []int) int {
    ans := 1
    n := len(nums)
    count := 1
    for i:=1;i<n;i++{
        if nums[i]>nums[i-1]{
            count++
        }else{
            count = 1
        }
        ans = max(ans,count)
    }
    return ans
}
```

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

dfs定义：*dfs*(*i*) 表示以 *nums*[*i*] 结尾的最长递增子序列（LIS）的长度

状态转移方程：*dp*[*i*]= 0<=j<i and nums[j]<nums[i]  **(dp[j]+1)**

注意点：我们只遍历从索引 0 到 `i-1` 的元素。这意味着 `j` 的范围始终是 `[0, i-1]`

如果num[I]<num[I-1]，那么你就得去找i-2来进行计算了，所以才会去遍历前i个数

```go
func lengthOfLIS(nums []int) int {
    n := len(nums)
    memo := make([]int,n)
    ans := 0
    var dfs func(int)int
    dfs = func(i int)int{
        p := &memo[i]
        if *p>0{
            return *p
        }
        res := 0
        for j,x :=range nums[:i]{
            if x<nums[i]{
                res = max(res,dfs(j))
            }
        }
        res++
        *p = res
        return res
    }
    for i:=0;i<n;i++{
        ans = max(ans,dfs(i))
    }
    return ans
}
```

[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

我知道是这个思路，但是在用set的时候，我在思索要不要去把set中的元素删掉，亦或者如果找到的不是最小值怎么处理（找不到就返回，直到找到为止）

```go
func longestConsecutive(nums []int) int {
    ans := 0
    set := map[int]bool{}
    for _,num := range nums{
        set[num] = true
    }
    for num:= range set{
        if !set[num-1]{
            curnum := num
            curtime := 1
            for set[curnum+1]{
                curnum++
                curtime++
            }
            if ans<curtime{
                ans = curtime
            }
        }
    }
    return ans
}
```

[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

简单的双指针一起移动字符

[491. 非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

- 使用uset去重

```cpp
class Solution {
private:
    vector<vector<int>>result;
    vector<int>path;
    void backtracking(vector<int>& nums,int start){
        if(path.size()>1){
            result.push_back(path);
        }
        unordered_set<int>uset;
        for(int i = start;i<nums.size();i++){
            if((!path.empty()&&nums[i]<path.back())||uset.find(nums[i])!=uset.end()){
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums,i+1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums,0);
        return result;
    }
};
```

## 回溯问题

[698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

```cpp
class Solution {
public:
    // 回溯函数，尝试将 nums 中的元素分配到 subsetSum 中
    bool backtracking(vector<int>& nums, int index, vector<int>& subsetSum, int target) {
        // 如果所有元素都被分配完毕，则返回 true，表示找到了有效的分割
        if (index == nums.size()) {
            return true;
        }
        // 遍历 subsetSum，尝试将当前元素 nums[index] 分配给每个子集
        for (int i = 0; i < subsetSum.size(); i++) {
            // 如果当前子集的和加上 nums[index] 不超过目标值 target
            if (subsetSum[i] + nums[index] <= target) {
                // 如果当前子集不是第一个被考虑的子集，并且它的和与前一个子集相同，则跳过
                if (i > 0 && subsetSum[i] == subsetSum[i - 1]) {
                    continue;
                }
                // 尝试将 nums[index] 分配给当前子集
                subsetSum[i] += nums[index];
                // 递归地尝试分配下一个元素
                if (backtracking(nums, index + 1, subsetSum, target)) {
                    // 如果成功分配完所有元素，则返回 true
                    return true;
                }
                // 如果无法成功分配所有元素，则撤销当前的分配
                subsetSum[i] -= nums[index];
            }
        }
        // 如果没有任何子集可以接受当前元素，则返回 false
        return false;
    }

    // 主函数，检查是否可以将 nums 分割成 k 个子集，每个子集的和都等于 target
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum = 0;
        // 计算 nums 中所有元素的总和
        for (int a : nums) {
            sum += a;
        }
        // 如果总和不能被 k 整除，则无法分割成 k 个相等的子集
        if (sum % k != 0) {
            return false;
        }
        // 计算目标值 target，即每个子集的期望和
        int target = sum / k;
        // 初始化 subsetSum，每个子集的初始和为 0
        vector<int> subsetSum(k, 0);
        // 对 nums 进行降序排序，以便优先考虑较大的元素
        sort(nums.begin(), nums.end(), [](int a, int b) { return a > b; });
        // 调用回溯函数，尝试分配 nums 中的元素
        return backtracking(nums, 0, subsetSum, target);
    }
};
```

[77. 组合](https://leetcode.cn/problems/combinations/)

回溯的板子题，秒杀

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

[216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

板子题，拿捏

[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

1、string 也能pop_back(),我还在用vector<char>path;

2、unordered_map<char,string>来保存映射

3、int start来表示digits一直往前走，不需要在内部i = start这样循环

```cpp
#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

class Solution {
private:
    vector<string> result;
    string path;
    unordered_map<char,string> mymap = {
            {'2',"abc"},
            {'3',"def"},
            {'4',"ghi"},
            {'5',"jkl"},
            {'6',"mno"},
            {'7',"pqrs"},
            {'8',"tuv"},
            {'9',"wxyz"}
    };

    void backtracking(const string& digits, int start) {
        if (start == digits.size()) {
            result.push_back(path);
            return;
        }

        for (int j = 0; j < mymap[digits[start]].size(); ++j) {
            path.push_back(mymap[digits[start]][j]);
            backtracking(digits, start + 1);
            path.pop_back(); // 回溯，撤销选择
        }
    }

public:
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) {
            return {};
        }
        result.clear();
        path.clear();
        backtracking(digits, 0);
        return result;
    }
};
```

[39. 组合总和](https://leetcode.cn/problems/combination-sum/)

怎么去重是关键点:因为他是无重复的数组，那么start就可以去重

```cpp
void backtracking(vector<int>&candidates,int target,int start){
    if(target<0)return;
    if(target==0){
        result.push_back(path);
        return;
    }
    for(int i = start;i<candidates.size();i++){
        path.push_back(candidates[i]);
        backtracking(candidates,target-candidates[i],i);
        path.pop_back();
    }
}
```

[40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

怎么去重：这次是有重复元素，那么就先排序，然后再去重

```cpp
void backtracking(vector<int>&candidates,int target,int start){
    if(target<0)return;
    if(target==0){
        result.push_back(path);
        return;
    }
    for(int i =start;i<candidates.size();i++){
        //经典去重步骤
        if(i>start&&candidates[i]==candidates[i-1])continue;
        path.push_back(candidates[i]);
        backtracking(candidates,target-candidates[i],i+1);
        path.pop_back();
    }
}
```

