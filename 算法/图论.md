#### 网络延迟时间

```cpp
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // 创建一个图，g[i]存储节点i的所有邻居及其对应的权重
        vector<vector<pair<int,int>>> g(n);
        
        // 填充图的数据结构，将输入的times转换为邻接表形式
        for(auto& t : times){
            // t[0]-1表示起点，t[1]-1表示终点，t[2]表示边的权重
            g[t[0] - 1].emplace_back(t[1] - 1, t[2]);
        }
        
        // 初始化距离数组dis，初始值为无穷大（INT_MAX）
        vector<int> dis(n, INT_MAX);
        // 起点k-1到自身的距离为0
        dis[k - 1] = 0;
        
        // 优先队列pq，用于Dijkstra算法，按距离从小到大排序
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> pq;
        // 将起点加入优先队列
        pq.emplace(0, k - 1);
        
        // 开始Dijkstra算法
        while(!pq.empty()){
            // 取出当前距离最小的节点dx和该节点编号x
            auto [dx, x] = pq.top();
            pq.pop();
            
            // 如果当前节点的距离已经大于记录的最短距离，则跳过
            //起点的dx = 0，dis【x】 = 0；
            if(dx > dis[x]){
                continue;
            }
            
            // 遍历当前节点的所有邻居
            for(auto& [y, d] : g[x]){
                // 计算新路径的距离
                int new_dis = dx + d;
                // 如果新路径比已知的最短路径更短，则更新并将新的状态加入优先队列
                if(new_dis < dis[y]){
                    dis[y] = new_dis;
                    pq.emplace(new_dis, y);
                }
            }
        }
        
        // 找到所有节点中最大的距离
        int mx = ranges::max(dis);
        // 如果最大距离仍然是无穷大，说明有节点不可达，返回-1；否则返回最大距离
        return mx < INT_MAX ? mx : -1;
    }
};
```

