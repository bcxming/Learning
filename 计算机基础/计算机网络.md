## 概述

### 七层网络模型

应用层（数据）：HTTP、FTP、DNS、DHCP

表示层：语法问题

会话层：建立通信会话

传输层（段）：UDP、TCP

网络层（包）：IP

数据链路层（帧）：上层数据封装成帧，MAC访问

物理层（比特流）：设备之间

## TCP和UDP

### TCP头部

源端口、目的端口

序列号（乱序）

确认号（丢包）

首部长度（4位）、保留（6位）、控制位（**URG**、**ACK**、**RST**、**SYN**、**FIN**、**PSH**）、窗口（16位）

校验和（CRC算法）、紧急指针（16位）

### TCP如何保证可靠传输?

三次握手

校验和：验证TCP首部和数据在发送过程中没有任何改动

序列号和确认号

流量控制：如果缓冲区大小为0，那么发送方会停止发送数据。并且发送方定期会发送探测报文，来获取缓冲区大小

拥塞控制：慢启动算法、拥塞避免算法、快速重传和快速恢复

超时重传、快速重传

四次挥手

### TCP的拥塞控制？

慢启动：

- 初始化设置 cwnd = 1，并开始传输数据

- 收到ACK，会将 cwnd 加 1
- 当 cwnd >= ssthresh 或发生丢包重传时慢启动结束，进入拥塞避免状态

拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd

拥塞发生：

- 超时重传：ssthresh 设为 cwnd/2，cwnd 重置为 1
- 快速重传：cwnd = cwnd/2 ，ssthresh = cwnd，进入快速恢复

快速恢复：

- 拥塞窗口 cwnd = ssthresh + 3
- 重传丢失的数据包，收到重复的 ACK，那么 cwnd 增加 1
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，进入拥塞避免

### TCP的三次握手？

**第一次握手**

客户端请求建立连接，将首部的SYN标识位置为1，初始化序列号seq=x，发送给服务器，并进入**SYN_SENT**状态，等待服务器确认。

**第二次握手**

服务器接收到SYN后，将首部的SYN和ACK标识位置为1，回复确认ack的值为客户端发送的序列号x+1，同时自己也要初始化一个seq=y，ACK和SYN一起发送客户端，进入**SYN_RECV**状态。

**第三次握手**

客户端收到服务器的SYN和ACK包后，向服务器发送确认包ack，值为服务器的序列号y+1，并且自己的seq为x+1，此包发送完毕，客户端和服务器进入**ESTABLISHED**（TCP连接成功）状态。

### TCP为什么要三次握手？

同步双方序列号和确认服务端和客户端的收发能力都是正常的

### TCP的三次握手丢了？

ACK报文发生了丢包是不会重传的

**第一次丢失：**重传的SYN报文序列号和之前相同，一般5次

**第二次丢失**：客户端和服务端都会重传

**第三次丢失**：服务端收不到ACK会触发超时重传机制，重传 SYN-ACK 报文

### TCP为什么不是两次握手？

首要原因是为了防止旧的重复连接初始化造成混乱

同步双方初始序列号

### TCP的四次挥手？

第一次挥手：首部的FIN标识位置为1，序列号seq=u，客户端进入**FIN_WAIT_1**状态，即便FIN报文不携带数据，也要消耗一个序列号。

第二次挥手：ACK标识位置为1，ack = u+1, seq = v,服务器进入**CLOSE_WAIT关闭等待**状态，客户端进入**FIN_WAIT_2**状态

第三次挥手：FIN标识位置为1，ACK标识位置为1，seq = w，ack = u+1,服务器进入**LAST_ACK**状态

第四次挥手：seq = u+1，ack = w+1，客户端就进入**TIME_WAIT**状态

### TCP为什么要四次挥手？

确保连接双方能够正常的关闭连接

### 在FIN_WAIT_2状态下，是如何处理收到的乱序到 FIN 报文，然后TCP连接又是什么时候才进入到TIME_WAIT状态？

在FIN_WAIT_2状态时，如果收到乱序的FIN报文会加入到乱序队列，并不会进入到TIME_WAIT状态。等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有FIN标志，如果发现有FIN标志，才会进入TIME_WAIT状态。

###  TCP的四次挥手丢了？

**第一次丢失**：客户端超时重传

**第二次丢失：**客户端超时重传

**第三次丢失**：服务端收到客户端的 FIN 报文后内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态。服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。收不到ACK的话会重发FIN报文直到最大次数为止。

**第四次丢失**：最后一次的ACK发生了丢失，服务端没有收到 ACK 报文前是处于 LAST_ACK 状态。超时之后服务端会重传FIN报文，客户端此时是在 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，会重置定时器，当等待 2MSL 时长后，客户端会断开连接。

### TCP的延迟应答和累计应答？

**延迟应答**：TCP在接收到对端的报文后并不会立即发送ACK，而是等待一段时间发送ACK，以便将ACK和要发送的数据一块发送。

**累计应答**：为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会**应答某个之前的ID**。

### TCP会有三次挥手出现吗？

**没有数据要发送**并且开启了**延迟应答**，第二和第三次挥手就会合并传输

### TCP的MSL？

TCP是以IP数据报的形式在网络中传输，IP有限制其生存的时间TTL，**RFC793指出MSL为2分钟，现实中常用30秒或1分钟**

### 已经建立了连接，客户端突然出现故障了会怎样？

通常计时器设置为两小时，在每次收到客户端发来的报文都会重置计时器，超时之后客户端就会发送探测报文，每隔75S发送一次，如果连续10个探测报文都没有收到回复，服务器会认为客户端发生故障，中断此次连接。

###  什么时候用长连接，短连接？

长连接：数据库

短连接：HTTP

### 什么是SYN攻击？如何避免？

概念：半连接队列满了无法接受新的请求

避免方法：

- 哈希表保存半连接信息，开销更小
- 减少SYN+ACK重传次数
- 增大半连接队列，修改TCP的内核参数，增大全连接队列大小

###  TIME_WAIT作用，过多如何解决？

TCP常用的三个状态是：**ESTABLISHED**表示正在通信，**TIME_WAIT**表示主动关闭，**CLOSE_WAIT**表示被动关闭

作用：

**实现全双工的可靠释放连接**：假设发起主动关闭的一方最后发送的ACK在网络中丢失，由于TCP的重传机制，被动关闭的一方会重新发送FIN报文，在FIN在被主动关闭方接收之前，主动关闭方都需要维护这条连接状态，包括对应的IP地址和端口号。如果发送方不维护TIME_WAIT状态，那么当FIN到达主动关闭方的时候，主动关闭放会发送RST包来响应，被动关闭方就会认为有错误发生。

**旧的数据包在网络因过期而消失**：假设有一个新的相同的四元组建立了TCP连接，因为TCP连接是由四元组唯一标识的，所以没法区分新旧连接

危害：

- 占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等
- 占用端口资源

避免方法：

- 修改短连接为长连接
- 客户端机器打开tcp_tw_reuse和tcp_timestamps选项：tcp_tw_reuse调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复。复用连接之后需要更新timestamps参数，当旧的TCP数据包到达时，根据时间戳判断是旧连接的数据可以舍弃。

### TIME_WAIT状态为什么需要经过2MSL？

1、因为客户端最后一个发送的ACK有可能丢失。`2MSL` 的时间是从**客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 **2MSL 时间将重新计时**

2、避免历史连接

###  CLOSE_WAIT状态过多如何解决？

在对方关闭连接之后服务器程序自己没有进一步发出ACK信号，看看代码是不是没有调用close函数

### TCP和UDP的区别？

面向连接、可靠、字节流

首部长度、传输层分片/IP层分片

UDP：应用于高速传输并且对实时性有要求的通信

### 粘包和拆包问题的解决办法？

发送方延迟、接收方延迟、网络因素

拆包本身就应该在应用层来完成

### TCP的keepalive和HTTP的 keepalive 的区别？

用户态（应用层）、内核态（传输层）

## IP

### DNS查询服务器的基本流程？

递归和迭代

### DNS采用TCP还是UDP，为什么？

DNS在进行区域传输的时候使用TCP协议，**其它时候则使用UDP协议**。

区域传输使用TCP协议的原因大概是：

- 区域传输的数据量相比单次DNS查询的数据量要大得多
- 区域传输对数据的可靠性和准确性相比普通的DNS查询要要高得多，因此使用TCP协议

域名解析时一般返回的内容都不超过512字节，首选的通讯协议是UDP。使用UDP传输，不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。

### DNS劫持是什么？解决办法？

DNS重定向，通过覆盖计算机的TCP/IP设置，将个人查询重定向到域名服务器DNS。

**本地DNS劫持**

攻击者在用户的计算机上安装木马恶意软件，并更改本地DNS设置以将用户重定向到恶意站点。

**路由器DNS劫持**

攻击者接管路由器并覆盖DNS设置，从而影响连接到该路由器的所有用户。

**中间DNS攻击的人**

攻击者拦截用户和DNS服务器之间的通信，并提供指向恶意站点的不同目标IP地址。

### 浏览器输入一个URL到显示器显示的过程？

**键盘输入**

输入键盘字符后键盘就会产生扫描数据，并将其缓冲存在寄存器中，然后键盘通过总线给 CPU 发送中断请求。CPU 收到中断请求后，操作系统会保存被中断进程的 CPU 上下文，然后调用键盘的中断处理程序。

**URL解析**

浏览器会首先从缓存中找是否存在域名，否则就DNS域名解析

**TCP连接**

在URL解析过程中得到真实的IP地址之后，会调用Socket函数建立TCP连接。

**HTTP请求**

在建立起的 TCP连接中，按照 HTTP协议标准发送一个索要网页的请求。请求包含请求行、请求头、请求体三个部分组成，有GET、POST等主要方法。

**浏览器接收响应**

服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。

**页面渲染**

**断开连接**

### PING是怎么工作的？

ICMP主要的功能包括：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置等。

ping命令执行的时候，源主机首先会构建一个ICMP回送请求消息数据包，由ICMP协议将这个数据包连同服务端IP一起交给IP层，IP层将以服务端IP作为目的地址，本机IP地址作为源地址，协议字段设置为1，再加上一些其他控制信息，构建一个IP数据包；

目的主机会构建一个ICMP回送响应消息数据包，回送响应数据包的类型字段为0，序号为接收到的请求数据包中的序号，然后再发送出去给源主机。

### Cookie和Session的关系和区别是什么？

Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务器两个请求是否来自同一浏览器。

Session代表着服务器和客户端一次会话的过程。

区别

- **作用范围不同**：Cookie 保存在客户端（浏览器），Session 保存在服务端
- **存取方式的不同**：Cookie 只能保存 ASCII，Session 可以存任意数据类型
- **有效期不同**：Cookie 可设置为长时间保持，比如经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效
- **隐私策略不同**：Cookie 存储在客户端，比较容易遭到不法获取；Session 存储在服务端，安全性相对 Cookie 要好一些
- **存储大小不同**：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie

## HTTP

### HTTP和HTTPS的区别？

是否加密

CA证书

80/443

SSL/TLS握手

### HTTPS的加密与认证过程？

第一次：

- 客户端支持的 SSL/TLS协议版本
- 客户端产生的的随机数(Client Random）
- 客户端支持的密码套件列表

第二次：

- 确认 SSL/ TLS 协议版本(如果浏览器不支持，则关闭加密通信）
- 服务端生产的随机数(Server Random）
- 确认的密码套件列表
- 服务端的数字证书

第三次：

客户端收到服务端的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务端的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务端的公钥，然后使用它加密报文

- 一个随机数，该随机数会被服务端公钥加密
- 客户端握手结束通知，表示客户端的握手阶段已经结束
- 之前所有内容的发生的数据做个摘要，用来供服务端校验

服务端和客户端有了三个随机数，接着用双方协商的加密算法，各自生成本次通信的会话秘钥。

第四次：

- 服务端握手结束通知，表示服务端的握手阶段已经结束
- 之前所有内容的发生的数据做个摘要，用来供客户端校验

### HTTPS一定安全可靠吗？

不要去点击接收中间人的证书

客户端被恶意导入伪造的根证书

### HTTP状态码的含义？

1、websocket

2、200（成功）

3、301（永久）、302（临时）、304（未修改）

4、客户端发送的**报文有误**：403（禁止）、404（未找到）

5、服务器端的**错误码**：503（服务不可用）、502（网关错误）

### HTTP缓存有哪些实现方式

强制缓存：相对和绝对时间戳

协商缓存

### HTTP1.0、HTTP1.1、HTTP2.0和HTTP3.0的区别？

HTTP1.0：无连接、队头阻塞

HTTP1.1：长连接、管道运输

HTTP2.0：头部压缩（静态和动态表）、多路复用、二进制压缩、服务器主动推送

HTTP/3.0：

- UDP解决TCP导致的队头阻塞问题

- **0-RTT**：缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。(**这是QUIC协议相比HTTP2.0的最大优势**）

### QUIC协议的概念和特点？

HTTP/3 基于**UDP 协议**在应用层实现了 **QUIC 协议**，具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，让UDP协议变得可靠。

**无队头阻塞**

QUIC 协议有类似 HTTP/2 Stream 与多路复用的概念，可以在同一条连接上并发传输多个 Stream。UDP 不关心数据包的顺序，也不关心是否丢包。UDP将每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，该流的其他数据包到达了，数据也无法被 HTTP/3 读取，QUIC 重传丢失的报文之后数据才会交给 HTTP/3。而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。

**快速连接建立**

对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，需要分批次来握手，先 TCP 握手，再 TLS 握手。

HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。

**连接迁移**

QUIC 协议没有用四元组的方式来绑定连接，而是通过**连接 ID**来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息(比如连接 ID、TLS 密钥等），就可以复用原连接，消除重连的成本，达到了**连接迁移**的功能。

### HTTP的GET和POST方法区别？

- GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源。
- GET是幂等的，即读取同一个资源总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的。
- GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的请求头中，以?分割URL和传输数据，参数之间以&相连；而POST请求会把提交的数据则放置在是HTTP请求报文的请求体中。

###  既然有HTTP协议，为什么还要有RPC？

大部分RPC协议底层使用TCP，但实际上它们不一定非要用TCP，改用UDP或者HTTP。HTTP主要用于b/s架构，而RPC更多用于c/s架构。

**服务发现：**RPC一般会有专门的中间服务去保存服务名和IP信息，比如consul或者etcd，或者是redis。

**传输的内容**：HTTP设计初是用于做网页文本展示的，传的内容以字符串为主，有header和body。在body这块，它使用json来序列化结构体数据，内容会有冗余。RPC因为定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向。

### 中间人攻击以及如何防范？

通过 **HTTPS 双向认证**来避免这种问题：一般 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。