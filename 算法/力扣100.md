## 二叉树

### 二叉树的最大深度

自己写的递归秒杀

```cpp
int maxDepth(TreeNode* root) {
    if(root==nullptr)return 0;
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    return max(left,right)+1;
}
```

### 翻转二叉树

自己写的

```cpp
TreeNode* invertTree(TreeNode* root) {
    if(root==nullptr)return root;
    swap(root->left,root->right);
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

### 对称二叉树

如果直接用层序遍历，那么放在队列中的节点不易比较，因此需要按照比较的顺序将其放进去

## 图论

### 岛屿数量

要么修改岛屿中的数字，要么用额外的布尔空间去记录是否被访问

### 腐烂的橘子

1、知道要用BFS，但是没想起来用队列加入所有的腐烂橘子

2、和二叉树的层序遍历很像

```cpp
int orangesRotting(vector<vector<int>>& grid) {
    int row = grid.size();
    int col = grid[0].size();
    int time = 0;
    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    queue<tuple<int,int>>que;
    for(int i = 0;i<row;++i){
        for(int j = 0;j<col;++j){
            if(grid[i][j]==2){
                que.push({i,j});
            }
        }
    }
    while(!que.empty()){
        int size = que.size();
        bool changed = false;
        for(int k = 0;k<size;++k){
            auto [i,j] = que.front();
            que.pop();
            for(auto [di,dj]:directions){
                if(i+di>=0&&i+di<row&&j+dj>=0&&j+dj<col&&grid[i+di][j+dj]==1){
                    grid[i+di][j+dj] = 2;
                    que.push({i+di,j+dj});
                    changed = true;
                }
            }
        }
        if(changed)time++;
    }
    for(const auto& r:grid){
        if(find(r.begin(),r.end(),1)!=r.end()){
            return -1;
        }
    }
    return time;
}
```



## 回溯

### 全排列

简单的回溯，但是用到了辅助树组来记录是否被访问

## 二分查找

### 搜索插入位置

闭区间分情况考虑写代码：

1、都小于返回0

2、都大于返回数组长度

3、在中间返回看left和right如何移动

### 搜索二维矩阵

就是从左下角开始搜索

## 栈

### 有效的括号

遇到（，就插入），方便弹出的时候进行比较，同时注意栈为空的情况

## 堆

### 手写堆

### 数组中的第k个最大元素

改进版快排能做到0(n),如果基于堆，那么平均复杂度就是0(logn)

```cpp
int findKthLargest(vector<int>& nums, int k) {
    return quickSelect(nums,k);
}
int quickSelect(vector<int>& nums,int k){
  //增加算法稳定性 0(n)，0（logn）
    int pivot = nums[rand()%nums.size()];
    vector<int>big,equal,small;
    for(int& num:nums){
        if(num>pivot)big.push_back(num);
        else if(num<pivot)small.push_back(num);
        else equal.push_back(num);
    }
  //下面的if语句，你把num想象成三段就能理解为啥这样书写逻辑了
    if(k<=big.size())return quickSelect(big,k);
    if(nums.size()-small.size()<k)return quickSelect(small,k-nums.size()+small.size());
    return pivot;
}
```

## 贪心

### 买卖股票的最佳时机

约等于从一个数组中找出相差最大的值

## 技巧

### 只出现一次的数字

异或：两个相同数字异或为0

异或满足交换律和结合律，A异或0等于A

```cpp
int singleNumber(vector<int>& nums) {
    int x = 0;
    for(int i = 0;i<nums.size();++i){
        x ^= nums[i];
    }
    return x;
}
```

### 多数元素

哈希表、数组排序、摩尔投票

1、初始化： 票数统计 votes = 0 ， 众数 x。
2、循环： 遍历数组 nums 中的每个数字 num 。
3、当 票数 votes 等于 0 ，则假设当前数字 num 是众数。
4、当 num = x 时，票数 votes 自增 1 ；当 num != x 时，票数 votes 自减 1 。
5、返回值： 返回 x 即可。

```cpp
int majorityElement(vector<int>& nums) {
    int vote = 0;
    int result = 0;
    for(auto& num:nums){
        if(vote==0||num==result){
            result = num;
            vote++;
        }else{
            vote--;
        }
    }
    return result;
}
```

### 颜色分类

**循环不变量** 简单说就是在循环的过程中保持不变的性质，这个性质是人为根据需要解决的任务定义的。

**整体思路**：使用三路快排的思想，将数组分成三部分，小于1的部分、等于1的部分和大于1的部分。

**变量定义**：

- `zero`：用于标记0应该放置的位置。
- `two`：用于标记2应该放置的位置，从数组末尾开始。
- `i`：当前扫描的位置。

**算法流程**：

1. 当 `nums[i] == 0` 时，将其与 `nums[zero]` 交换，并将 `zero` 和 `i` 都加1。
2. 当 `nums[i] == 1` 时，直接跳过，即 `i++`。
3. 当 `nums[i] == 2` 时，将其与 `nums[two-1]` 交换，并将 `two` 减1，但 `i` 不变，以便重新检查新换过来的值。

```cpp
void sortColors(vector<int>& nums) {
    int size = nums.size();
    if(size<2)return;
    int zero = 0;//0结束的位置
    int two = size;//2结束的位置
    int i = 0;
    while(i<two){
        if(nums[i]==0){
            swap(nums[zero],nums[i]);
            zero++;
            i++;
        }else if(nums[i]==1){
            i++;
        }else{
            two--;
            swap(nums[i],nums[two]);
        }
    }
}
```

