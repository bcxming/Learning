C++11是C++语言的一次重大升级，带来了许多新的特性和改进，使得编写高效、现代的C++代码变得更加容易

- nullptr替代 NULL
- 引入了 auto 和 decltype 这两个关键字实现了类型推导
- 基于范围的 for 循环for(auto& i : res){}
- 类和结构体的中初始化列表
- Lambda 表达式（匿名函数）
- std::forward_list（单向链表）
- 右值引用和move语义

### 自动类型推导（`auto`关键字）

在C++11之前，变量的类型必须显式指定。这在处理复杂类型或模板时会变得繁琐。C++11引入了`auto`关键字，它允许编译器根据初始化表达式自动推导变量的类型。

```cpp
auto x = 42;     // x的类型是int
auto y = 3.14;   // y的类型是double
auto z = "Hello"; // z的类型是const char*
```

使用`auto`可以使代码更加简洁，尤其是在处理复杂的类型时，例如迭代器。

```cpp
std::vector<int> vec = {1, 2, 3, 4};
for (auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << std::endl;
}
```

**decltype：**关键字用于获取表达式的类型，并且不会进行类型转换。它主要用于编译时类型推导，可以用于变量声明、返回类型推导等

**decltype(auto)**：用于声明变量时，**保留表达式的引用特性和常量**属性，并根据表达式的类型推导出变量的类型

**<font color='red'>auto是怎么推导的？</font>**

编译器会根据初始化表达式的类型和上下文环境来推导 `auto` 变量的类型，然后在编译过程中将其替换为实际的

类型

### 范围`for`循环

C++11引入了范围`for`循环，使得遍历容器变得更加简单和直观。它的语法类似于其他现代编程语言的`for-each`循环。

```cpp
std::vector<int> vec = {1, 2, 3, 4};
for (int value : vec) {
    std::cout << value << std::endl;
}
```

如果不需要修改元素，可以使用`const`修饰符：

```cpp
for (const auto& value : vec) {
    std::cout << value << std::endl;
}
```

### 智能指针（`std::shared_ptr`和`std::unique_ptr`）

在C++11之前，手动管理动态内存是一件容易出错的事情。C++11引入了智能指针来简化内存管理，并防止内存泄漏。

**std::shared_ptr：**

- `std::shared_ptr` 是一种共享式智能指针，可以多个 `std::shared_ptr` 指向同一块内存
- 内部使用引用计数来跟踪管理的对象的引用次数，当引用次数为 0 时自动释放内存
- **构造函数、复制构造、移动构造会加一、析构函数会减一**
- 可以通过 `std::make_shared` 来创建 `std::shared_ptr`，推荐使用这种方式。

```cpp
#include <memory>
std::shared_ptr<int> p1 = std::make_shared<int>(10);
std::shared_ptr<int> p2 = p1;  // p1和p2共享内存
```

**std::unique_ptr：**

- `std::unique_ptr` 是一种独占式智能指针，它所管理的对象是唯一的，没有其他指针可以指向同一块内存
- 当 `std::unique_ptr` 离开作用域时，它所管理的对象会被自动释放，从而避免了内存泄漏。
- **复制构造函数和复制赋值运算符被删除、移动构造函数和移动赋值运算符来转移所有权**
- 通过使用 `std::move` 函数，可以将所有权转移给另一个 `std::unique_ptr`，实现所有权的转移。

```cpp
#include <memory>
std::unique_ptr<int> p1 = std::make_unique<int>(10);
// std::unique_ptr<int> p2 = p1;  // 错误：unique_ptr不能被复制
std::unique_ptr<int> p2 = std::move(p1);  // 可以转移所有权

```

```cpp
// 删除复制构造函数和复制赋值运算符
MyUniquePtr(const MyUniquePtr&) = delete;
MyUniquePtr& operator=(const MyUniquePtr&) = delete;

// 移动构造函数
MyUniquePtr(MyUniquePtr&& other) noexcept {
    ptr = other.ptr;
    other.ptr = nullptr;
}

// 移动赋值运算符
MyUniquePtr& operator=(MyUniquePtr&& other) noexcept {
    if (this != &other) {
        delete ptr;
        ptr = other.ptr;
        other.ptr = nullptr;
    }
    return *this;
}
```

**std::weak_ptr：**

- `std::weak_ptr` 是 `std::shared_ptr` 的一种弱引用，不增加对象的引用计数。
- 主要用于解决 `std::shared_ptr` 的循环引用问题，避免出现内存泄漏。
- 可以通过 `lock()` 方法获取一个 `std::shared_ptr` 的临时拷贝。

```cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() {
        std::cout << "MyClass created" << std::endl;
    }

    ~MyClass() {
        std::cout << "MyClass destroyed" << std::endl;
    }
};

int main() {
    // 创建一个 shared_ptr 指向 MyClass 的实例
    std::shared_ptr<MyClass> shared = std::make_shared<MyClass>();

    // 创建一个 weak_ptr 指向 MyClass 的实例
    std::weak_ptr<MyClass> weak = shared;

    // 检查 weak_ptr 是否有效
    if (weak.expired()) {
        std::cout << "Weak pointer is expired." << std::endl;
    } else {
        std::cout << "Weak pointer is not expired." << std::endl;
    }

    // 通过 weak_ptr 获取 shared_ptr
    std::shared_ptr<MyClass> strong = weak.lock();

    // 检查获取的 shared_ptr 是否为空
    if (strong) {
        std::cout << "Strong pointer obtained from weak pointer is valid." << std::endl;
    } else {
        std::cout << "Strong pointer obtained from weak pointer is null." << std::endl;
    }

    // 手动释放 shared_ptr，模拟对象被删除的情况
    shared.reset();

    // 再次检查 weak_ptr 是否有效
    if (weak.expired()) {
        std::cout << "Weak pointer is now expired." << std::endl;
    } else {
        std::cout << "Weak pointer is still not expired." << std::endl;
    }

    // 尝试再次通过 weak_ptr 获取 shared_ptr
    strong = weak.lock();

    // 检查获取的 shared_ptr 是否为空
    if (strong) {
        std::cout << "Strong pointer obtained from weak pointer is valid." << std::endl;
    } else {
        std::cout << "Strong pointer obtained from weak pointer is null." << std::endl;
    }

    return 0;
}
```

简易的共享指针

```cpp
#include <iostream>
#include <cassert>

template<typename T>
class SimpleSharedPtr {
private:
    T* ptr;
    mutable size_t* ref_count;

public:
    // 构造函数
    explicit SimpleSharedPtr(T* p = nullptr) : ptr(p), ref_count(new size_t(1)) {}

    // 从裸指针构造
    SimpleSharedPtr(T* p, size_t* count) : ptr(p), ref_count(count) {}

    // 析构函数
    ~SimpleSharedPtr() {
        if (--(*ref_count) == 0) {
            delete ptr;
            delete ref_count;
        }
    }

    // 获取内部指针
    T* get() const {
        return ptr;
    }

    // 获取引用计数
    size_t use_count() const {
        return *ref_count;
    }

    // 重载解引用操作符
    T& operator*() const {
        assert(ptr != nullptr);
        return *ptr;
    }

    // 重载箭头操作符
    T* operator->() const {
        assert(ptr != nullptr);
        return ptr;
    }

    // 复制构造函数
    SimpleSharedPtr(const SimpleSharedPtr& other) : ptr(other.ptr), ref_count(other.ref_count) {
        (*ref_count)++;
    }

    // 移动构造函数
    SimpleSharedPtr(SimpleSharedPtr&& other) noexcept : ptr(other.ptr), ref_count(other.ref_count) {
        other.ptr = nullptr;
        other.ref_count = nullptr;
    }

    // 复制赋值操作符
    SimpleSharedPtr& operator=(const SimpleSharedPtr& other) {
        SimpleSharedPtr tmp(other);
        std::swap(ptr, tmp.ptr);
        std::swap(ref_count, tmp.ref_count);
        return *this;
    }

    // 移动赋值操作符
    SimpleSharedPtr& operator=(SimpleSharedPtr&& other) noexcept {
        std::swap(ptr, other.ptr);
        std::swap(ref_count, other.ref_count);
        return *this;
    }
};

// 测试代码
int main() {
    // 创建一个 SimpleSharedPtr
    SimpleSharedPtr<int> ptr1(new int(42));

    // 检查引用计数
    std::cout << "Use count: " << ptr1.use_count() << std::endl;

    // 创建第二个 SimpleSharedPtr，指向同一个对象
    SimpleSharedPtr<int> ptr2 = ptr1;

    // 检查引用计数
    std::cout << "Use count after copy: " << ptr1.use_count() << std::endl;

    // 使用解引用操作符
    *ptr2 = 100;

    // 输出修改后的值
    std::cout << "Value of *ptr1: " << *ptr1 << std::endl;

    // 使用箭头操作符
    std::cout << "Value of *ptr2: " << *ptr2 << std::endl;

    return 0;
}
```

### Lambda表达式

C++11引入了Lambda表达式，使得编写内联匿名函数变得更加方便。Lambda表达式在需要传递短小的函数对象时非常有用，例如在STL算法中。

```cpp
auto add = [](int a, int b) -> int { return a + b; };
std::cout << add(2, 3) << std::endl;  // 输出5
```

Lambda表达式也可以捕获作用域中的变量：

```cpp
int x = 10;
auto lambda = [x](int a) { return x + a; };
std::cout << lambda(5) << std::endl;  // 输出15
```

### 右值引用和移动语义

**左值引用**

左值引用是C++中的一种引用类型，它允许你引用一个左值。左值通常指的是具有名称的变量，这些变量在内存中有固定的地址。左值引用本质上是已有引用的一种扩展，它在C++98/C++03中就已经存在。在C++11中可以取地址的、有名字的就是左值。

**右值引用**

右值引用是C++11中引入的新特性。它允许你引用一个右值。右值通常指的是临时对象或者表达式的结果，这些值通常没有名称，并且在内存中可能没有固定的地址。右值引用的引入使得C++能够更有效地处理临时对象，并且支持移动语义，从而提高程序的性能，允许程序员定义更高效的资源管理方式。右值引用使得“移动”资源（如动态内存、文件句柄）成为可能，而不是简单地复制它们。

```cpp
int x = 5;
// 使用右值引用初始化一个临时变量
int&& rref = 10;
// 将临时变量作为参数传递给接受右值引用参数的函数
processRvalue(std::move(rref)); // 使用 std::move() 将左值转换为右值
// 使用 std::move() 将左值转换为右值引用
processRvalue(std::move(x)); // 注意：x 在此之后可能处于不确定的状态
```

- 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去
- 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值
- T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化

==右值引用的主要作用有两个方面：==

**移动语义（Move Semantics）**：通过右值引用，可以实现资源（如动态分配的内存、文件句柄等）的有效转移，而不是简单的拷贝。这在处理临时对象时特别有用，可以提升程序的性能。

**完美转发（Perfect Forwarding）**：右值引用还用于实现通用代码中的完美转发，即在不失去参数类型信息的同时，将参数传递给其他函数。

如何正确地将参数传递给其他函数，保持其原始的值类别和const属性

完美转发通常在两个主要的场景下使用：

1. **传递参数给模板或者泛型函数**：当模板或者泛型函数需要将参数转发给其他函数时，可以使用完美转发确保传递的参数类型和引用类型保持不变。
2. **传递参数给其他类的构造函数或者成员函数**：当编写包装器类（wrapper class）或者代理类（proxy class）时，经常需要将构造函数或者成员函数的参数传递给内部对象，完美转发可以帮助保持==原始参数的类型和引用性质。==

完美转发主要依赖于两个重要的特性：

- **右值引用**（Rvalue reference）：C++11引入的`&&`语法，用于标识临时对象或将要销毁的对象。
- **`std::forward`函数模板**：C++11标准库中提供的一个工具函数，用于将参数完美转发给其他函数。

**示例一**

```cpp
#include <iostream>
#include <utility>
// 接受任意类型的参数并转发给其他函数的模板函数
template<typename T>
void wrapper(T&& arg) {
    // 将参数完美转发给其他函数
    forwarder(std::forward<T>(arg));
}
// 接受参数的具体实现函数
void forwarder(int& x) {
    std::cout << "Lvalue reference: " << x << std::endl;
}
void forwarder(int&& x) {
    std::cout << "Rvalue reference: " << x << std::endl;
}
int main() {
    int x = 42;
    wrapper(x); // Lvalue reference: 42
    wrapper(42); // Rvalue reference: 42
    return 0;
}
```

**示例二**

```cpp
#include <iostream>
#include <vector>

std::vector<int> createVector() {
    std::vector<int> vec = {1, 2, 3, 4};
    return vec;
}

int main() {
    std::vector<int> v = createVector();  // 使用移动语义而不是拷贝
    return 0;
}
```

在这个例子中，C++11的移动语义避免了不必要的拷贝，从而提高了性能。

当你从函数 `createVector` 返回 `std::vector<int>` 时，编译器会自动使用移动语义来提高效率。这是因为返回值优化（Return Value Optimization, RVO）和命名返回值优化（Named Return Value Optimization, NRVO）机制会在编译时发生，这两者都是移动语义的应用。

**代码分析**

**函数 `createVector`**：

- 在 `createVector` 函数内部，你创建了一个局部变量 `vec`，并初始化它为 `{1, 2, 3, 4}`。

- 当函数返回 `vec` 时，编译器会检测到 `vec` 是一个临时对象，并且即将被返回。此时，编译器可以选择直接构造返回值到调用者的变量中，这就是 NRVO。

  **函数返回**：当 `createVector` 函数返回时，编译器会检测到返回的是一个局部变量 `vec`。

  **直接构造**：

  - 编译器可以选择直接在 `main` 函数中构造 `std::vector<int> v`，而不是先构造一个临时对象再拷贝给 `v`。

  - 这意味着编译器会直接使用 `createVector` 函数内部的 `vec` 的数据来构造 `v`，而不是创建一个新的临时对象。

  **避免拷贝**：

  - 通过直接构造 `v`，编译器避免了创建临时对象和拷贝操作，这可以提高性能，特别是当返回的对象较大时。

**主函数 `main`**：

- 在 `main` 函数中，你通过 `std::vector<int> v = createVector();` 来接收 `createVector` 函数的返回值。

- 由于 `createVector` 返回的是一个临时对象，编译器可以选择使用移动构造函数来将这个临时对象移动到 `v` 中，而不是进行深拷贝。

  **创建临时对象**：

  - 当 `createVector` 函数返回时，编译器会创建一个临时的 `std::vector<int>` 对象来保存 `vec` 的数据。

  **移动构造**：

  - `std::vector<int> v` 的构造会使用移动构造函数，它接受一个临时对象作为参数。
  - 移动构造函数会将临时对象的资源（例如内存块和元素）移动到 `v` 中，而不是复制。
  - 移动构造函数通常比拷贝构造函数更快，因为它避免了数据的复制操作。

  **临时对象销毁**：

  - 一旦移动构造完成，临时对象就被销毁了，因为它已经完成了自己的使命，将资源移动给了 `v`。

**右值引用可以绑定到右值（临时对象），但不能绑定到左值（非临时对象）**

示例一：绑定右值引用到临时对象

```CPP
#include <iostream>

void foo(int&& x) {
    std::cout << "Temporary object: " << x << std::endl;
}

int main() {
    foo(42); // 绑定到临时对象 42
    return 0;
}
```

示例二：绑定右值引用到左值

```cpp
#include <iostream>

void bar(int&& x) {
    std::cout << "Temporary object: " << x << std::endl;
}

int main() {
    int y = 42;
    bar(y); // 编译错误：不能将左值绑定到右值引用
    return 0;
}
//解决办法一：无论 z 是左值还是右值，都可以正确地转发给函数
template<typename T>
void forward_example(T&& x) {
    std::cout << "Forwarded value: " << std::forward<T>(x) << std::endl;
}

int main() {
    int z = 42;
    forward_example(z); // 使用 std::forward 正确转发
    return 0;
}
//解决办法二：std::move(z) 将 z 显式地转换为右值，从而可以绑定到 int&& 参数
void move_example(int&& x) {
    std::cout << "Moved value: " << x << std::endl;
}

int main() {
    int z = 42;
    move_example(std::move(z)); // 使用 std::move 转换为右值
    return 0;
}
```

**移动语义的作用**

- **提高效率**：移动语义可以避免不必要的深拷贝操作，尤其是在处理大型对象或资源密集型对象时，可以显著提高性能。
- **减少内存开销**：移动语义可以减少内存分配和拷贝的开销。
- **Move 语义的实现依赖于右值引用**，通常，我们会为类实现移动构造函数和移动赋值运算符，以实现资源的有效转移和管理

### constexpr关键字

`constexpr`关键字用于定义在编译期求值的常量表达式。这可以提高程序的效率，因为编译器可以在编译时就计算出结果，而不是在运行时。

```cpp
constexpr int square(int x) {
    return x * x;
}

int main() {
    int array[square(5)];  // 编译时计算出数组大小
    return 0;
}
```

### 强类型枚举（`enum class`）

传统的C++枚举（`enum`）存在隐式转换为整数的风险。C++11引入了强类型枚举（`enum class`），它更安全且不允许隐式转换。

```cpp
enum class Color { Red, Green, Blue };

Color color = Color::Red;

// 不能直接与整数比较
// if (color == 0) { ... }  // 错误

if (color == Color::Red) {
    std::cout << "The color is Red" << std::endl;
}
```

### 初始化列表（Initializer List）

C++11允许使用初始化列表来初始化类、数组和容器，使得代码更加简洁易读。

```cpp
#include <vector>

std::vector<int> vec = {1, 2, 3, 4};

struct Point {
    int x;
    int y;
};

Point p = {10, 20};  // 使用初始化列表初始化结构体
```

###  `nullptr`关键字

C++11引入了`nullptr`，这是一个类型安全的空指针常量，取代了传统的`NULL`宏定义，避免了与整数`0`混淆的风险。

```cpp
void foo(int* ptr) {
    if (ptr == nullptr) {
        std::cout << "Pointer is null" << std::endl;
    }
}

int main() {
    foo(nullptr);  // 使用nullptr而不是NULL
    return 0;
}
```
