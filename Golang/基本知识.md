## 入门

1、布尔型无法参与数值运算，也无法与其他类型进行转换

2、Go语言字符串和C++中string有所不同，其中最大的不同就是Go语言中字符串无法直接通过下标修改每一个字

符元素，只能通过重新构造新的字符串并赋值给原来的字符串变量实现

3、Go语言的字符有以下两种：

一种是uint8类型，或者叫byte类型，代表了一个ASCII码的一个字符。等价于C语言中unsigned char

一种是rune类型，代表UTF-8字符，底层是int32类型。用来处理中文、日文等复合字符。

4、定义方式

```go
var i int = 12    //明确定义i为int类型
var i =  12       //自动识别i为int类型
i := 12           //自动推断变量i为int类型

a, b = b, a   //交换了a和b的值

for i < 19 {  //等价于C语言中的while(i < 19)
    i++
}

//for-range遍历通道
for v := range c {
    fmt.Println(v)    //不断从通道中取数据，直到通道被关闭

```

5、**Go** 支持什么形式的类型转换?将整数转换为浮点数

```go
i := 55 //int
j := 67.8 //float64
sum := i + int(j)//j is converted to int
```

6、Golang 的引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。

## 数据类型

### slice

**定义方式**

```go
//一维数组
var str [3]string
var str = [3]string{"hello", "world", ""}
var str = [...]string{"hello", "world", ""}
//二维数组
var arr [3][4]int    //定义三行四列的整型数组
for k, v := range str {
    fmt.Println(k, v)
}

//方式一：从数组生成切片
var a = [...]int{1, 2, 3}
var slice []int = a[1:2]   //从数组a生成切片slice
 
//方式二：从切片生成切片
var a = [...]int{1, 2, 3}
var slice []int = a[0:]
var ss []int = slice[1:2]
 
//方式三：直接声明新的切片
var slice []int
 
//方式四：使用make()函数构造切片
make([]T, size, cap)
//构造一个元素个数为size,容量为cap,类型为T的切片
a := make([]int, 2, 3)
 
//如果你执行 slice[1:4]，那么这个操作会返回从索引 1 开始到索引 3 结束的元素（不包含索引 4 的元素）
//slice[:3] 等同于 slice[0:3]
//slice[2:] 表示从索引 2 开始直到切片结束
//slice[0:0] 返回一个长度为 0 的空切片
 
//append
var slice[] int
slice = append(slice, 3)        //使用append()一次添加一个元素
slice = append(slice, 1, 2, 3)  //使用append()一次添加多个元素
 
team := []string{"pig", "chicken"}
slice = append(slice, team...)  //team后面加上...，表示将team整个添加到slice后面

//切片复制
src := []int{1, 2, 3, 4, 5}
dst := make([]int, len(src)) // 创建一个目标切片，长度与源切片相同
copy(dst, src)               // 将源切片的内容复制到目标切片

//go没有提供直接对切片删除元素的接口，只能通过append实现
seq := []string{"a", "b", "c", "d", "e"}
index := 2
seq = append(seq[:index], seq[index + 1:]...)
```

**nil切片和空切片指向的地址一样吗？**

切片的数据结构

```go
type SliceHeader struct {
 Data uintptr  //引用数组指针地址
 Len  int     // 切片的目前使用长度
 Cap  int     // 切片的容量
}
```

- nil切片和空切片指向的地址不一样。
- nil空切片引用数组指针地址为0（无指向任何实际地址），所有的空切片指向的数组引用地址都是一样的，且固定为一个值

**拷贝大切片一定比小切片代价大吗？**

并不是，所有切片的大小相同；

三个字段:切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字;

所以 拷贝大切片跟小切片的代价应该是一样的。

**for循环里面能append吗**

```go
func main() {
 s := []int{1,2,3,4,5}
 for _, v:=range s {
  s =append(s, v)
  fmt.Printf("len(s)=%v\n",len(s))
 }
}
```

- **不会死循环**，`for range`其实是`golang`的`语法糖`，在循环开始前会获取切片的长度 `len(切片)`，然后再执行`len(切片)`次数的循环。

**Go 中切片扩容的策略是这样的:**

首先判断，如果新申请容量大于2 倍的旧容量，最终容量就是新申请的容量 

否则判断，如果旧切片的⻓度小于1024，则最终容量就是旧容量的两倍 

否则判断，如果旧切片⻓度大于等于1024，则最终容量从旧容量开始循环增加原来的1/4,直到最终容量大于 等于新申请的容量

如果最终容量计算值溢出，则最终容量就是新申请容量

**扩容前后的 Slice 是否相同?** 

情况一:原数组还有容量可以扩容(实际容量没有填充完)，这种情况下，扩容以后的数组还是指向原来的数组，

对一个切片的操作可能影响多个指针指向相同地址的 Slice。 

情况二:原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷⻉过来，然后再执行 append()操作。这种情况丝毫不影响原数组。 要复制一个 Slice，最好使用 Copy函数。

### string

**字符串转成byte数组，会发生内存拷贝吗？**

严格来说，只要是发生类型强转都会发生内存拷贝

```go
func main() {
 a :="aaa"
 ssh := *(*reflect.StringHeader)(unsafe.Pointer(&a))
 b := *(*[]byte)(unsafe.Pointer(&ssh))  
 fmt.Printf("%v",b)
}
```

`StringHeader` 是`字符串`在go的底层结构

```go
type StringHeader struct {
 Data uintptr
 Len  int
}
```

`SliceHeader` 是`切片`在go的底层结构

```go
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
```

- 1.`unsafe.Pointer(&a)`方法可以得到变量`a`的地址。
- 2.`(*reflect.StringHeader)(unsafe.Pointer(&a))` 可以把字符串a转成底层结构的形式。
- 3.`(*[]byte)(unsafe.Pointer(&ssh))` 可以把ssh底层结构体转成byte的切片的指针。
- 4.再通过 `*`转为指针指向的实际内容。

```go
func BytesToStr(data []byte) string {
	return *(*string)(unsafe.Pointer(&data))
}
func StrToBytes(data string) []byte {
	str := (*reflect.StringHeader)(unsafe.Pointer(&data))
	bs := reflect.SliceHeader{
		Data: str.Data,
		Len:  str.Len,
		Cap:  str.Len,
	}

	return *(*[]byte)(unsafe.Pointer(&bs))
}
```

**翻转含有中文、数字、英文字母的字符串**

```go
func main() {
  src := "你好abc啊哈哈"
  dst := reverse([]rune(src))
}

func reverse(s []rune) []rune {
  for i, j := 0, len(s)-1; i < j; i++, j-- {
  s[i], s[j] = s[j], s[i]
  }
  return s
}
```

`rune`关键字，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），可表示更多的字符



### chan

channel 中使用了 ring buffer(环形缓冲区)来缓存写入的数据。ring buffer 有很多好处，而且非常适合用来实现 FIFO 式的固定⻓度队列。

Go语言中，不要通过共享内存来通信，而要通过通信来实现内存共享

**创建通道**

你可以使用内置的 `make` 函数来创建一个通道：

```go
ch := make(chan int) 
```

这里我们创建了一个传递 `int` 类型的无缓冲通道。

发送和接收数据

- **发送数据**：使用 `<-` 操作符将数据发送到通道。
- **接收数据**：同样使用 `<-` 操作符从通道接收数据。

**缓冲通道**

默认情况下，通道是无缓冲的，这意味着只有当有接收者准备好接收数据时，发送操作才会完成。如果需要，可以创建带缓冲的通道，这样即使没有立即接收者，发送操作也能完成，直到缓冲区满为止。

```go
package main 
import (    
  "fmt" 
) 
func main() {    
  ch := make(chan int, 2)  // 创建一个容量为2的缓冲通道  
  ch <- 1    
  ch <- 2     
  fmt.Println(<-ch)  // 输出: 1    
  fmt.Println(<-ch)  // 输出: 2 
} 
```

**关闭通道**

你可以使用 `close` 函数来关闭通道，表示不再向该通道发送更多的数据。关闭后的通道仍然可以接收剩余的数据，但不能再发送。

**Select语句**

`select` 语句允许一个 goroutine 等待多个通信操作。当其中一个操作完成时，程序就会执行相应的分支。

```go
package main 
import (    
  "fmt"    
  "time" 
) 
func main() {    
  ch1 := make(chan string)    
  ch2 := make(chan string)     
  go func() {        
    time.Sleep(1 * time.Second)        
    ch1 <- "one"    
  }  
  go func() {        
    time.Sleep(2 * time.Second)        
    ch2 <- "two"    
	}
  for i := 0; i < 2; i++ {        
    select {        
      case msg1 := <-ch1:  
      fmt.Println("Received", msg1)        
      case msg2 := <-ch2:   
      fmt.Println("Received", msg2)        
      }    
  } 
} 
```

这个例子展示了如何使用 `select` 语句同时等待两个通道的消息，并根据哪个通道先收到消息来处理不同的情况。

**总结**

- 使用 `make` 函数创建通道。
- 使用 `<-` 操作符发送和接收数据。
- 可以创建带缓冲的通道以支持异步发送。
- 使用 `close` 函数关闭通道。
- 使用 `select` 语句等待多个通道的通信操作。

channel存在3种状态:

nil，未初始化的状态，只进行了声明，或者手动赋值为nil 

active，正常的channel，可读或者可写 

closed，已关闭，千万不要误认为关闭channel后，channel的值是nil

channel特性：

1. 给一个 nil channel 发送数据，造成永远阻塞

2. 从一个 nil channel 接收数据，造成永远阻塞
3. 给一个已经关闭的 channel 发送数据，引起 panic
4. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值 5. 无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的
5. 关闭一个 nil channel 将会发生 panic

### map

**定义方式**

```go
//只遍历值
for _, v :range scene {
......
}
 
//只遍历键
for k : range scene {
......
}

delete(map, key)               //从map中删除key的元素
```

使用 `Store` 方法将键值对存储到 `sync.Map` 中：

```go
m.Store("key1", "value1")
m.Store(2, 3.14) // 支持不同类型的键和值
```

使用 `Load` 方法根据键加载对应的值。如果该键存在，则返回值和 true；否则返回 nil 和 false：

```go
if value, ok := m.Load("key1"); ok {
    fmt.Println("key1:", value)
} else {
    fmt.Println("key1 not found")
}
```

使用 `Delete` 方法删除指定键的键值对：

```go
m.Delete("key1")
```

使用 `LoadOrStore` 方法，如果键已存在则返回其对应的值和 true，否则存储新的键值对并返回新值和 false：

```go
value, loaded := m.LoadOrStore("key2", "new_value")
fmt.Println("Value:", value, "Loaded:", loaded)
```

使用 `Range` 方法遍历 `sync.Map` 中的所有键值对。注意：`Range` 的回调函数的参数是键和值，且如果回调函数返回 false 则停止遍历：

```go
m.Range(func(key, value interface{}) bool {
    fmt.Println("Key:", key, "Value:", value)
    return true // 返回 true 继续遍历，返回 false 停止遍历
})
```

**map的底层哈希表是怎么查询的？**

1. **哈希函数**：
   - 每个键通过一个哈希函数转换成一个哈希值。
   - 哈希函数的目的是将不同的键尽可能均匀地分布到哈希表的各个桶（bucket）中。
2. **定位桶**：
   - 使用哈希值计算出具体应该放入或查找的桶的位置。通常，这一步骤是通过取模运算（hash % bucket_count）完成的。
   - 在Go语言中，每个桶可以包含多个键值对。
3. **遍历桶**：
   - 如果桶中的元素较多，会采用链地址法或者其他方法来解决冲突。
   - 遍历桶中的所有元素，通过比较键找到目标键值对。
4. **扩展机制**：
   - 当负载因子超过一定阈值时，哈希表会自动进行扩展，即增加桶的数量并重新分配已有的键值对，以减少冲突。

### list

**定义方式**

```go
//方式一：通过container/list包的New方法初始化list
l := list.New()
//方式二:通过声明初始化list
var l list.List
 
//在列表中插入元素
l := list.New()
l.PushBack("first")              //从链表尾部插入元素“first”
element := l.PushFront(67)       //从链表头部插入元素67
l.InsertAfter("high", element)   //在element后插入元素
l.InsertBefore("noon", element)  //在element前插入元素
 
//从链表中删除元素
l.Remove(element)
 
//遍历列表
for i := l.Front(); i != nil; i = i.Next() {
    fmt.Println(i.Value)
```



## 高级特性

### 结构体

**go struct能不能比较**

- 相同struct类型的可以比较

- 不同struct类型的不可以比较,编译都不过，类型不匹配



### 反射

Go 语言中的反射（reflection）是一种强大的编程技术，允许程序在运行时检查和操作对象的类型和值。反射可以用来查看变量的类型信息、动态调用方法以及创建新的实例等。

在 Go 中，反射主要通过 `reflect` 包提供的一组函数和类型来实现。以下是一些基本概念和示例，帮助你理解 Go 的反射机制：

**基本概念**

1. **Type**：表示一个 Go 类型，可以通过 `reflect.TypeOf` 函数获取。
2. **Value**：表示一个 Go 值，可以通过 `reflect.ValueOf` 函数获取。
3. **Kind**：表示具体的类别，比如整数、浮点数、结构体、指针等，可以通过 `Type.Kind` 方法获取。

**获取类型和值**

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
func main() {    
  var x float64 = 3.4    
  fmt.Println("type:", reflect.TypeOf(x))   
  // 输出: type: float64    
  fmt.Println("value:", reflect.ValueOf(x)) 
  // 输出: value: 3.4 
} 
```

**操作值**

通过 `reflect.Value` 可以对值进行各种操作，如修改值、调用方法等。

**修改值**

要修改值，需要传递一个可寻址的变量（通常是指针）。

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
func main() {    
  var x float64 = 3.4    
  p := reflect.ValueOf(&x) // 注意这里传入的是 &x    
  v := p.Elem()        
  if v.CanSet() {        
    v.SetFloat(7.1)    
  }    
  fmt.Println(x) // 输出: 7.1 
} 
```

**动态调用方法**

通过反射，你可以在运行时动态地调用方法。

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
type MyStruct struct{} 
func (m MyStruct) Hello(name string){ fmt.Println("Hello,", name) 
} 
func main() {    
  m := MyStruct{}    
  v := reflect.ValueOf(m)    
  method := v.MethodByName("Hello")        
  args := []reflect.Value{
    reflect.ValueOf("World")
  }    
  method.Call(args) // 输出: Hello, World 
} 
```

**总结**

- **Type 和 Value**：`reflect.TypeOf` 返回类型信息，`reflect.ValueOf` 返回值信息。
- **修改值**：需要传递指针并使用 `Elem()` 获取实际值，通过 `CanSet` 检查是否可设置。
- **动态调用方法**：使用 `MethodByName` 查找方法，并使用 `Call` 调用。
- **创建新实例**：使用 `reflect.New` 创建类型的新实例。

如果你只需要处理固定类型的数据，并且追求高性能和简洁的代码，那么不使用反射是更好的选择。

如果你需要编写高度通用的代码，并且愿意接受一定的性能损失和复杂度增加，那么反射是一个非常强大的工具。

### context

以下是一些常见的`context`类型及其使用方式：

`context.Background()`：返回一个空的上下文，这个上下文通常在主函数、初始化或测试代码中作为顶级的上下文使用

```go
ctx := context.Background()
```

`context.TODO()`：返回一个空的上下文，但它表示目前还不知道应该使用什么样的上下文。这种情况下可以用`TODO`来占位，将来再替换成具体的上下文

```go
ctx := context.TODO()
```

`context.WithCancel(parent)`：创建一个可取消的上下文，并返回该上下文和一个取消函数。当调用取消函数时，该上下文会发送取消信号给所有基于它衍生的上下文

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel() // 确保在不再需要的时候调用取消函数

go func() {
    select {
    case <-ctx.Done():
        fmt.Println("Context canceled")
    }
}()
```

`context.WithDeadline(parent, deadline)`：创建一个带有截止时间的上下文。如果到了指定的时间点，上下文会自动发送取消信号

```go
deadline := time.Now().Add(5 * time.Second)
ctx, cancel := context.WithDeadline(context.Background(), deadline)
defer cancel()

go func() {
    select {
    case <-ctx.Done():
        fmt.Println("Context deadline exceeded")
    }
}()
```

`context.WithValue(parent, key, value)`：创建一个携带值的上下文，可以将键值对存储在上下文中，以便在不同的Goroutine之间传递数据。注意，`key`应当是一个非导出的、自定义类型，以避免冲突。

```go
type MyKey string
const key MyKey = "myKey"

ctx := context.WithValue(context.Background(), key, "myValue")

go func(ctx context.Context) {
    if val, ok := ctx.Value(key).(string); ok {
        fmt.Println("Value:", val)
    }
}(ctx)
```

### 并发编程

**Golang 中常用的并发模型?**

- 同步并发控制

```go
func main() {
    ch := make(chan struct{})
    go func() {
        fmt.Println("start working")
        time.Sleep(time.Second * 1)
        ch <- struct{}{}
}()
<-ch
    fmt.Println("finished")
}
```

- 通过sync包中的WaitGroup实现并发控制

```go
//Add, 可以添加或减少 goroutine的数量.
//Done, 相当于Add(-1).
//Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.
func main(){
    var wg sync.WaitGroup
    var urls = []string{
        "http://www.golang.org/",
        "http://www.google.com/",
    }
    for _, url := range urls {
        wg.Add(1)
        go func(url string) {
            defer wg.Done()
            http.Get(url)
        }(url)
}
wg.Wait() }
```

- Context上下文，实现并发控制

通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。 所以我们需要 一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context

```go
func main() {
    // 创建一个带有超时的context
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    go func(ctx context.Context) {
        select {
        case <-ctx.Done():
            fmt.Println("Context canceled:", ctx.Err())
        }
    }(ctx)

    // 模拟一些工作
    time.Sleep(1 * time.Second)

    // 检查context是否已经过期或者被取消
    if err := ctx.Err(); err != nil {
        fmt.Println("Error:", err)
    }

    // 获取context的截止时间
    deadline, ok := ctx.Deadline()
    if ok {
        fmt.Println("Deadline set to:", deadline)
    } else {
        fmt.Println("No deadline set")
    }

    // 使用Value传递数据
    key := "exampleKey"
    valueCtx := context.WithValue(ctx, key, "exampleValue")

    val := valueCtx.Value(key)
    fmt.Println("Value from context:", val)
}

```

**协程，线程，进程的区别**

- 进程：独立内存空间、进程间通信、上下文切换开销大（栈、寄存器、虚拟内存、文件句柄）
- 线程：不独立拥有内存、共享内存通信、开销小

**协程和线程的区别**

**调度上的开销区别：**OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存 中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换:即保存一个线程 的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。

**栈空间：**goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到 1GB

**标识上：**goroutine没有一个特定的标识

**死锁**

条件：互斥、等待、不可剥夺、环路

情况：

- 同一个线程先后两次调用lock
- 两个线程相互等待对方

预防死锁：

- 资源一次性分配
- 阻塞时释放已有资源
- 有序分配资源

**说Go中的锁有哪些?**

互斥锁、读写锁、sync.Map安全锁

**怎么限制Goroutine的数量**

1、通道

```go
func worker(id int, wg *sync.WaitGroup, semaphore chan struct{}) {
    defer wg.Done()

    // 占用一个信号量
    semaphore <- struct{}{}
    fmt.Printf("Worker %d is starting\n", id)
    time.Sleep(2 * time.Second) // 模拟工作
    fmt.Printf("Worker %d is done\n", id)
    
    // 释放一个信号量
    <-semaphore
}

func main() {
    var wg sync.WaitGroup
    maxGoroutines := 3
    semaphore := make(chan struct{}, maxGoroutines)

    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go worker(i, &wg, semaphore)
    }

    wg.Wait()
}

```

**defer**

不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反

## go进阶

`for`循环`select`时，如果通道已经关闭会怎么样？如果`select`中的`case`只有一个，又会怎么样？

- `select`中如果任意某个通道有值可读时，它就会被执行，其他被忽略。
  - 其中如果通道被关闭了，那么会返回0，false，然后会一直执行，除非你遇到false就把通道关闭了

- 如果没有`default`字句，`select`将有可能阻塞，直到某个通道有值可以运行，所以`select`里最好有一个`default`，否则将有一直阻塞的风险。

对**已经关闭**的的 `chan` 进行读写，会怎么样？**为什么？**

- 读**已经关闭**的 `chan` 能一直读到东西，但是读到的内容根据通道内`关闭前`是否有元素而不同。
  - 如果 `chan` 关闭前，`buffer` 内有元素**还未读** , 会正确读到 `chan` 内的值，且返回的第二个 bool 值（是否读成功）为 `true`。
  - 如果 `chan` 关闭前，`buffer` 内有元素**已经被读完**，`chan` 内无值，接下来所有接收的值都会非阻塞直接成功，返回 `channel` 元素的**零值**，但是第二个 `bool` 值一直为 `false`。
- 写**已经关闭**的 `chan` 会 `panic`

**对未初始化的的chan进行读写，会怎么样?为什么?**

1. **读取未初始化的channel**：如果你尝试从一个未初始化的channel读取数据（即 `var ch chan int`），程序会发生阻塞，因为这个channel没有被分配内存，也没有任何发送者可以向它发送数据。所以，读取操作将永远等待。
2. **写入未初始化的channel**：同样，如果你尝试向一个未初始化的channel发送数据，程序也会发生阻塞，因为没有接收者能够从这个channel读取数据，而且该channel无法接受任何数据。

能说说uintptr和unsafe.Pointer的区别吗？

- unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；
- 而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；
- unsafe.Pointer 可以和 普通指针 进行相互转换；
- unsafe.Pointer 可以和 uintptr 进行相互转换。

```go
func main() {
 var w *W = new(W)
 //这时w的变量打印出来都是默认值0，0
 fmt.Println(w.b,w.c)

 //现在我们通过指针运算给b变量赋值为10
 b := unsafe.Pointer(uintptr(unsafe.Pointer(w)) + unsafe.Offsetof(w.b))
 *((*int)(b)) = 10
 //此时结果就变成了10，0
 fmt.Println(w.b,w.c)
}
```



## 包

### json

**`json`包里使用的时候，结构体里的变量不加`tag`能不能正常转成`json`里的字段？**

- 如果变量`首字母小写`，则为`private`。无论如何`不能转`，因为取不到`反射信息`。
- 如果变量`首字母大写`，则为`public`。
  - `不加tag`，可以正常转为`json`里的字段，`json`内字段名跟结构体内字段`原名一致`。
  - `加了tag`，从`struct`转`json`的时候，`json`的字段名就是`tag`里的字段名，原字段名已经没用。

```go
type J struct {
    a string             //小写无tag
    b string `json:"B"`  //小写+tag
    C string             //大写无tag
    D string `json:"DD"` //大写+tag
}
//转为json前j结构体的内容 = {a:1 b:2 C:3 D:4}
//转为json后的内容 = {"C":"3","DD":"4"}
```

**`json`包里使用的时候，会结构体里的字段边上加`tag`，有没有什么办法可以获取到这个`tag`的内容呢？**

```go
type J struct {
    a string //小写无tag
    b string `json:"B"` //小写+tag
    C string //大写无tag
    D string `json:"DD" otherTag:"good"` //大写+tag
}
//printTag方法传入的是j的指针
func printTag(stru interface{}) {
  //reflect.TypeOf(stru).Elem()获取指针指向的值对应的结构体内容
    t := reflect.TypeOf(stru).Elem()
    for i := 0; i < t.NumField(); i++ {
        fmt.Printf("结构体内第%v个字段 %v 对应的json tag是 %v , 还有otherTag？ = %v \n", i+1, t.Field(i).Name, t.Field(i).Tag.Get("json"), t.Field(i).Tag.Get("otherTag"))
 }
}
```

