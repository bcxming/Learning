### 课程表二

```cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> result;
        unordered_map<int, vector<int>> adjList; // 邻接表表示图
        vector<int> inDegree(numCourses, 0);     // 每个节点的入度

        // 构建邻接表和计算每个节点的入度
        for (const auto& pair : prerequisites) {
            int course = pair[0];
            int prereq = pair[1];
            adjList[prereq].push_back(course);
            inDegree[course]++;
        }
        queue<int> que;

        // 将所有入度为0的节点加入队列
        for (int i = 0; i < numCourses; ++i) {
            if (inDegree[i] == 0) {
                que.push(i);
            }
        }

        // 拓扑排序
        while (!que.empty()) {
            int node = que.front();
            que.pop();
            result.push_back(node);

            for (int neighbor : adjList[node]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    que.push(neighbor);
                }
            }
        }
        // 如果结果中的课程数量等于总课程数，则返回结果，否则返回空数组
        return result.size() == numCourses ? result : vector<int>();
    }
};

```

### 账户合并

1、哈希表key 为邮箱地址，value 为这个邮箱对应的账户下标列表

2、bool数组标记访问过的账户下标

3、DFS 之前，创建一个哈希集合 *emails*，用来保存 DFS 中访问到的邮箱地址

4、DFS搜索

```cpp
class Solution {
private:
    //key 为邮箱地址，value 为这个邮箱对应的账户下标列表。
    unordered_map<string,vector<int>>email_to_idx;
    // 用于收集 DFS 中访问到的邮箱地址
    unordered_set<string>email_set;
    // 标记访问过的账户下标
    vector<int>vis;
    void dfs(int i,vector<vector<string>>& accounts){
        vis[i] = true;
        for(int k = 1;k<accounts[i].size();k++){
            string email = accounts[i][k];
            if(email_set.count(email)){
                continue;
            }
            email_set.insert(email);
            for(int j:email_to_idx[email]){
                if(!vis[j]){
                    dfs(j,accounts);
                }
            }
        }
    }

public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        // 构建 email_to_idx 映射
        for(int i = 0;i<accounts.size();i++){
            for(int j = 1;j<accounts[i].size();j++){
                email_to_idx[accounts[i][j]].push_back(i);
            }
        }

        vector<vector<string>>result;
        // 新增的元素将被初始化为 0
        vis.resize(accounts.size());

        // 遍历所有账户
        for(int i = 0;i<vis.size();i++){
            if(vis[i]){
                continue;
            }
            email_set.clear();
            dfs(i,accounts);
            vector<string>res = {accounts[i][0]};
            res.insert(res.end(),email_set.begin(),email_set.end());
            sort(res.begin()+1,res.end());
            result.push_back(res);

        }
        return result;
    }
};
```

