## 二叉树

### 二叉树的最大深度

自己写的递归秒杀

```cpp
int maxDepth(TreeNode* root) {
    if(root==nullptr)return 0;
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    return max(left,right)+1;
}
```

### 翻转二叉树

自己写的

```cpp
TreeNode* invertTree(TreeNode* root) {
    if(root==nullptr)return root;
    swap(root->left,root->right);
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

### 对称二叉树

如果直接用层序遍历，那么放在队列中的节点不易比较，因此需要按照比较的顺序将其放进去

### 二叉树的直径

树形DP：我们定义一个递归函数 dfs，递归搜索每个节点max(ans,left+right+1）并设一个全局变量 ans 记录最大值，最后返回 ans-1 即为树的直径。

```cpp
class Solution {
private:
    int ans;
    int dfs(TreeNode* root){
        if(root==nullptr)return 0;
        int left = dfs(root->left);
        int right = dfs(root->right);
        ans = max(ans,left+right+1);
        return max(left,right)+1;
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 0;
        dfs(root);
        return ans-1;
    }
};
```

**二叉树的最大路径和**

```cpp
class Solution {
    int dfs(TreeNode* root, int& val) {
        if (root == nullptr) return 0;
        // 正确地计算左右子树的最大路径和
        int left = dfs(root->left, val);
        int right = dfs(root->right, val);
        // 当前节点加上左右子树的贡献，如果为负则取0
        int lmr = root->val + max(0, left) + max(0, right);
        // 当前节点加上较大的那边的贡献，用于返回给父节点
        int ret = root->val + max(0, max(left, right));
        // 更新全局最大值
        val = max(val, lmr);
        return ret;
    }
public:
    int maxPathSum(TreeNode* root) {
        int val = INT_MIN;
        dfs(root, val);
        return val;
    }
};
```

### 二叉树的层序遍历

队列没啥可说的

### 有序树组变成二叉搜索树

简单递归

**有序链表转化为二叉搜索树**

1、边界条件没有处理好：如果只有一个节点就直接返回

2、没有把中间节点进行截断

3、没有比较中间节点和左节点是否一致

```cpp
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        if (head == nullptr) return nullptr;
        if (head->next == nullptr) return new TreeNode(head->val);
        ListNode* slow = head;
        ListNode* fast = head;
        ListNode* prev = nullptr;  
        while (fast != nullptr && fast->next != nullptr) {
            prev = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        if (prev != nullptr) {
            prev->next = nullptr;
        }
        
        TreeNode* root = new TreeNode(slow->val);
        
        // Recursively construct the left subtree and right subtree
        if (slow != head) {  // Ensure we do not pass same head multiple times
            root->left = sortedListToBST(head);
        }
        root->right = sortedListToBST(slow->next);
        
        return root;
    }
};
```

### 验证二叉搜索树

这题不会写

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST(root,nullptr,nullptr);
    }
    bool isValidBST(TreeNode* root, TreeNode* minNode,TreeNode* maxNode) {
        if(root==nullptr)return true;
      //同时判断，先判空再判值的用法非常好用，避免空指针无法访问值
        if((minNode&&root->val<=minNode->val)||(maxNode&&root->val>=maxNode->val))return false;
        return isValidBST(root->left,minNode,root)&&isValidBST(root->right,root,maxNode);
    }
};
```

后序遍历

```cpp
class Solution {
    pair<long, long> dfs(TreeNode* node) {
        // 如果当前节点为空，则返回 {LONG_MAX, LONG_MIN} 表示空子树
        if (node == nullptr) {
            return {LONG_MAX, LONG_MIN};
        }
        // 递归地处理左子树，得到左子树中的最小值和最大值
        auto[l_min, l_max] = dfs(node->left);
        // 递归地处理右子树，得到右子树中的最小值和最大值
        auto[r_min, r_max] = dfs(node->right); 
        // 当前节点的值
        long x = node->val;   
        // 判断当前节点是否满足二叉搜索树的性质，如果不满足则返回 {LONG_MIN, LONG_MAX}
        if (x <= l_max || x >= r_min) {
            return {LONG_MIN, LONG_MAX};
        }
        // 返回以当前节点为根的子树的最小值和最大值
        return {min(l_min, x), max(r_max, x)};
    }
public:
    bool isValidBST(TreeNode* root) {
        // 调用 dfs 函数，并检查其返回值的 second 是否不等于 LONG_MAX，以此判断树是否为 BST
        return dfs(root).second != LONG_MAX;
    }
};
```

### 二叉搜索树中第k小的元素

1、中序遍历

2、返回树组的k-1位置上的数

### 二叉树的右视图

层序遍历秒杀

### 二叉树展开为链表



## 图论

### 岛屿数量

要么修改岛屿中的数字，要么用额外的布尔空间去记录是否被访问

### 腐烂的橘子

1、知道要用BFS，但是没想起来用队列加入所有的腐烂橘子

2、和二叉树的层序遍历很像

```cpp
int orangesRotting(vector<vector<int>>& grid) {
    int row = grid.size();
    int col = grid[0].size();
    int time = 0;
    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    queue<tuple<int,int>>que;
    for(int i = 0;i<row;++i){
        for(int j = 0;j<col;++j){
            if(grid[i][j]==2){
                que.push({i,j});
            }
        }
    }
    while(!que.empty()){
        int size = que.size();
        bool changed = false;
        for(int k = 0;k<size;++k){
            auto [i,j] = que.front();
            que.pop();
            for(auto [di,dj]:directions){
                if(i+di>=0&&i+di<row&&j+dj>=0&&j+dj<col&&grid[i+di][j+dj]==1){
                    grid[i+di][j+dj] = 2;
                    que.push({i+di,j+dj});
                    changed = true;
                }
            }
        }
        if(changed)time++;
    }
    for(const auto& r:grid){
        if(find(r.begin(),r.end(),1)!=r.end()){
            return -1;
        }
    }
    return time;
}
```

```cpp
//tuple用法
std::tuple<int, std::string, double> myTuple = {1, "Hello", 3.14};
// 使用 std::get
std::cout << "First: " << std::get<0>(myTuple) 
<< ", Second: " << std::get<1>(myTuple)
<< ", Third: " << std::get<2>(myTuple) << std::endl;
```

### 课程表

拓扑排序

```cpp
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int>indegree(numCourses,0);
    map<int,vector<int>>mymap;
    //先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
    for(int i = 0;i<prerequisites.size();++i){
        indegree[prerequisites[i][0]]++;//记录课程0入度
        //把课程1对应的节点记录下来
        mymap[prerequisites[i][1]].push_back(prerequisites[i][0]);
    }
    queue<int>que;
    for(int i = 0;i<indegree.size();i++){
        if(indegree[i]==0)que.push(i);
    }
    while(!que.empty()){
        int node = que.front();que.pop();
        numCourses--;
        for(int i = 0;i<mymap[node].size();++i){
            indegree[mymap[node][i]]--;
            if(indegree[mymap[node][i]]==0){
                que.push(mymap[node][i]);
            }
        }
    }
    return numCourses==0;
}
```

### 前缀树

Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。

查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。

Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m的n次方)

```cpp
class Trie {
private:
  bool isEnd;
  Trie* next[26];
public:
Trie() {
    isEnd = false;
    memset(next,0,sizeof(next));
}

void insert(string word) {
    Trie* node = this;
    for(char& c:word){
        if(node->next[c-'a']==nullptr){
            node->next[c-'a'] = new Trie();
        }
        node = node->next[c-'a'];
    }
    node->isEnd = true;
}

bool search(string word) {
    Trie* node = this;
    for(char& c:word){
        node = node->next[c-'a'];
        if(node==nullptr){
            return false;
        }
    }
    return node->isEnd;
}

bool startsWith(string prefix) {
    Trie* node = this;
    for(char& c:prefix){
        node = node->next[c-'a'];
        if(node==nullptr){
            return false;
        }
    }
    return true;
}
};
```

## 回溯

1、有push_back就得有pop_back

2、注意start

### 全排列

简单的回溯，但是用到了辅助树组来记录是否被访问

### 子集

标准回溯模板

```cpp
void backtracking(vector<int>&nums,int start){
    result.push_back(path);
    for(int i = start;i<nums.size();i++){
        path.push_back(nums[i]);
        backtracking(nums,i+1);
        path.pop_back();
    }
}
```

### 电话号码的字母组合

忘了怎么做了

```cpp
class Solution {
    string map[10] = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
public:
    vector<string> letterCombinations(string digits) {
        int n = digits.size();
        if(n==0)return {};
        vector<string>ans;
        string path(n,0);
        function<void(int)>dfs = [&](int i){
            if(i==n){
                ans.emplace_back(path);
                return;
            }
            for(char c:map[digits[i]-'0']){
                path[i] = c;
                dfs(i+1);
            }
        };
        dfs(0);
        return ans;
    }
};
```



### 组合总和

没看清题意，我还在那里思考半天怎么去重，题目中明确告诉没有重复的

解法：回溯模板

### 括号生成

debug了半天

```cpp
class Solution {
    vector<string>result;
    string path;
    void backtracking(int n,int left,int right){
        if(left<right||left>n||right>n){
            return;
        }
        if(n*2==path.size()){
            result.push_back(path);
            return;
        }
        for(int i = 0;i<2;i++){
            if(i==0){
                path += '(';
                backtracking(n,left+1,right);
                path.pop_back();
            }else{
                path += ')';
                backtracking(n,left,right+1);
                path.pop_back();
            }
        }
    }
public:
    vector<string> generateParenthesis(int n) {
        backtracking(n,0,0);
        return result;
    }
};
```



### 单词搜索

腾讯实习真题

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0;i<board.size();i++){
            for(int j = 0;j<board[0].size();j++){
                if(backtracking(board,word,i,j,0))return true;
            }
        }
        return false;
    }
    bool backtracking(vector<vector<char>>& board,string& word,int i,int j,int start){
        if(i<0||j<0||i>=board.size()||j>=board[0].size()||board[i][j]!=word[start])return false;
        if(start==word.size()-1)return true;
        board[i][j] = '1';
        bool res = backtracking(board,word,i+1,j,start+1)||backtracking(board,word,i-1,j,start+1)||backtracking(board,word,i,j+1,start+1)||backtracking(board,word,i,j-1,start+1);
        board[i][j]=word[start];
        return res;
    }
};
```



## 二分查找

关键不在于区间里的元素具有什么性质，而是区间外面的元素具有什么性质

### 搜索插入位置

闭区间分情况考虑写代码：

1、都小于返回0

2、都大于返回数组长度

3、在中间返回看left和right如何移动

### 搜索二维矩阵

就是从左下角开始搜索

### 在排序数组中查找元素的第一个和最后一个位置

来源于灵神题解，真棒

```cpp
class Solution {
    // lower_bound 返回最小的满足 nums[i] >= target 的 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.size()
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
        // 闭区间写法
    int lower_bound(vector<int> &nums, int target) {
        int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1; // 范围缩小到 [mid+1, right]
            } else {
                right = mid - 1; // 范围缩小到 [left, mid-1]
            }
        }
        return left;
    }

public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int start = lower_bound(nums,target);
        if(start==nums.size()||nums[start]!=target){
            return {-1,-1};
        }
        int end = lower_bound(nums,target+1)-1;
        return {start,end};
    }
};
//nums[i] > target
int lower_bound(vector<char>& letters,char target){
    int left = 0;
    int right = letters.size()-1;
    while(left<=right){
        int mid = left+(right-left)/2;
        if(letters[mid]<=target){
            left = mid+1;
        }else{
            right = mid-1;
        }
    }
    return left;
}
```

### 搜索旋转排序树组

知道思路写不出代码

```cpp
int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size()-1;
    while(left<=right){
        int mid = left+(right-left)/2;
        if(nums[mid]==target)return mid;
        if(nums[left]<=nums[mid]){
            //left到mid是顺序区间
            (target>=nums[left]&&target<nums[mid])?right = mid-1:left = mid+1;
        }else{
            //mid到right是顺序区间
            (target>nums[mid]&&target<=nums[right])?left = mid+1:right = mid-1;
        }
    }
    return -1;
}
```



## 栈

### 有效的括号

遇到（，就插入），方便弹出的时候进行比较，同时注意栈为空的情况

### 最小栈

一个栈正常使用

一个单调栈保存最小值

### 解码字符串

知道思路写不出来代码

1、数字：num = num*10+s[i]-'0';保存超过10的数

2、大小写字母：直接累加

3、遇见'['栈保存次数和字符串

4、遇见']',两个栈弹出开始计算，同时 res = strs.top();

### 每日温度

维护一个递减栈，栈里面保存原数组的下标索引

二者距离就是下标索引的差值

```cpp
vector<int> dailyTemperatures(vector<int>& temperatures) {
    stack<int>st;
    vector<int>result(temperatures.size());
    for(int i = 0;i<temperatures.size();i++){
        while(!st.empty()&&temperatures[st.top()]<temperatures[i]){
            result[st.top()] = i-st.top();
            st.pop();
        }
        st.push(i);
    }
    return result;
}
```

### 柱状图中最大的矩形

1、维护一个递增栈找左边界，一个递减栈找右边界

2、第三次枚举每个值*（右边界-左边界）

## 堆

### 手写堆

### 数组中的第k个最大元素

改进版快排能做到0(n),如果基于堆，那么平均复杂度就是0(logn)

```cpp
int findKthLargest(vector<int>& nums, int k) {
    return quickSelect(nums,k);
}
int quickSelect(vector<int>& nums,int k){
  //增加算法稳定性 0(n)，0（logn）
    int pivot = nums[rand()%nums.size()];
    vector<int>big,equal,small;
    for(int& num:nums){
        if(num>pivot)big.push_back(num);
        else if(num<pivot)small.push_back(num);
        else equal.push_back(num);
    }
  //下面的if语句，你把num想象成三段就能理解为啥这样书写逻辑了
    if(k<=big.size())return quickSelect(big,k);
    if(nums.size()-small.size()<k)return quickSelect(small,k-nums.size()+small.size());
    return pivot;
}
```

## 贪心

### 买卖股票的最佳时机

约等于从一个数组中找出相差最大的值

### 编辑距离

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void print_edit_steps(const string& s1, const string& s2) {
    int m = s1.length();
    int n = s2.length();
    
    // Initialize dp table and operations table
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    vector<vector<pair<string, char>>> operations(m + 1, vector<pair<string, char>>(n + 1, make_pair("", ' ')));
    
    for (int i = 0; i <= m; ++i) {
        dp[i][0] = i;
        if (i > 0) {
            operations[i][0] = make_pair("delete", s1[i - 1]);
        }
    }
    
    for (int j = 0; j <= n; ++j) {
        dp[0][j] = j;
        if (j > 0) {
            operations[0][j] = make_pair("insert", s2[j - 1]);
        }
    }
    
    // Fill dp table and operations table
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
                if (dp[i][j] == dp[i - 1][j] + 1) {
                    operations[i][j] = make_pair("delete", s1[i - 1]);
                } else if (dp[i][j] == dp[i][j - 1] + 1) {
                    operations[i][j] = make_pair("insert", s2[j - 1]);
                } else {
                    operations[i][j] = make_pair("replace", s1[i - 1]);
                }
            }
        }
    }
    
    // Backtrack to get the edit steps
    vector<string> edit_steps;
    int i = m, j = n;
    while (i > 0 || j > 0) {
        auto op = operations[i][j];
        if (op.first == "replace") {
            edit_steps.push_back("Replace '" + string(1, op.second) + "' at position " + to_string(i - 1) +
                                 " with '" + string(1, s2[j - 1]) + "'");
            --i;
            --j;
        } else if (op.first == "insert") {
            edit_steps.push_back("Insert '" + string(1, s2[j - 1]) + "' at position " + to_string(j));
            --j;
        } else if (op.first == "delete") {
            edit_steps.push_back("Delete '" + string(1, op.second) + "' at position " + to_string(i - 1));
            --i;
        }
    }
    
    // Reverse edit_steps to get steps in order from start to end
    reverse(edit_steps.begin(), edit_steps.end());
    
    // Print edit distance and edit steps
    cout << "Edit distance between '" << s1 << "' and '" << s2 << "' is " << dp[m][n] << endl;
    cout << "Edit steps:" << endl;
    for (const auto& step : edit_steps) {
        cout << step << endl;
    }
}

int main() {
    string s1 = "intention";
    string s2 = "execution";
    
    print_edit_steps(s1, s2);
    
    return 0;
}

```



## 技巧

### 只出现一次的数字

异或：两个相同数字异或为0

异或满足交换律和结合律，A异或0等于A

```cpp
int singleNumber(vector<int>& nums) {
    int x = 0;
    for(int i = 0;i<nums.size();++i){
        x ^= nums[i];
    }
    return x;
}
```

### 多数元素

哈希表、数组排序、摩尔投票

1、初始化： 票数统计 votes = 0 ， 众数 x。
2、循环： 遍历数组 nums 中的每个数字 num 。
3、当 票数 votes 等于 0 ，则假设当前数字 num 是众数。
4、当 num = x 时，票数 votes 自增 1 ；当 num != x 时，票数 votes 自减 1 。
5、返回值： 返回 x 即可。

```cpp
int majorityElement(vector<int>& nums) {
    int vote = 0;
    int result = 0;
    for(auto& num:nums){
        if(vote==0||num==result){
            result = num;
            vote++;
        }else{
            vote--;
        }
    }
    return result;
}
```

### 颜色分类

**循环不变量** 简单说就是在循环的过程中保持不变的性质，这个性质是人为根据需要解决的任务定义的。

**整体思路**：使用三路快排的思想，将数组分成三部分，小于1的部分、等于1的部分和大于1的部分。

**变量定义**：

- `zero`：用于标记0应该放置的位置。
- `two`：用于标记2应该放置的位置，从数组末尾开始。
- `i`：当前扫描的位置。

**算法流程**：

1. 当 `nums[i] == 0` 时，将其与 `nums[zero]` 交换，并将 `zero` 和 `i` 都加1。
2. 当 `nums[i] == 1` 时，直接跳过，即 `i++`。
3. 当 `nums[i] == 2` 时，将其与 `nums[two-1]` 交换，并将 `two` 减1，但 `i` 不变，以便重新检查新换过来的值。

```cpp
void sortColors(vector<int>& nums) {
    int size = nums.size();
    if(size<2)return;
    int zero = 0;//0结束的位置
    int two = size;//2结束的位置
    int i = 0;
    while(i<two){
        if(nums[i]==0){
            swap(nums[zero],nums[i]);
            zero++;
            i++;
        }else if(nums[i]==1){
            i++;
        }else{
            two--;
            swap(nums[i],nums[two]);
        }
    }
}
```

重复的子字符串

```cpp
bool repeatedSubstringPattern(string s) {
    string t = s+s;
    t.erase(t.begin());
    t.erase(t.end()-1);
    if(t.find(s)!=std::string::npos){
        return true;
    }
    return false;
}
```

