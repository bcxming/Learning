### 课程表二

```cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> result;
        unordered_map<int, vector<int>> adjList; // 邻接表表示图
        vector<int> inDegree(numCourses, 0);     // 每个节点的入度

        // 构建邻接表和计算每个节点的入度
        for (const auto& pair : prerequisites) {
            int course = pair[0];
            int prereq = pair[1];
            adjList[prereq].push_back(course);
            inDegree[course]++;
        }
        queue<int> que;

        // 将所有入度为0的节点加入队列
        for (int i = 0; i < numCourses; ++i) {
            if (inDegree[i] == 0) {
                que.push(i);
            }
        }

        // 拓扑排序
        while (!que.empty()) {
            int node = que.front();
            que.pop();
            result.push_back(node);

            for (int neighbor : adjList[node]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    que.push(neighbor);
                }
            }
        }
        // 如果结果中的课程数量等于总课程数，则返回结果，否则返回空数组
        return result.size() == numCourses ? result : vector<int>();
    }
};

```

### 账户合并

1、哈希表key 为邮箱地址，value 为这个邮箱对应的账户下标列表

2、bool数组标记访问过的账户下标

3、DFS 之前，创建一个哈希集合 *emails*，用来保存 DFS 中访问到的邮箱地址

4、DFS搜索

```cpp
class Solution {
private:
    //key 为邮箱地址，value 为这个邮箱对应的账户下标列表。
    unordered_map<string,vector<int>>email_to_idx;
    // 用于收集 DFS 中访问到的邮箱地址
    unordered_set<string>email_set;
    // 标记访问过的账户下标
    vector<int>vis;
    void dfs(int i,vector<vector<string>>& accounts){
        vis[i] = true;
        for(int k = 1;k<accounts[i].size();k++){
            string email = accounts[i][k];
            if(email_set.count(email)){
                continue;
            }
            email_set.insert(email);
            for(int j:email_to_idx[email]){
                if(!vis[j]){
                    dfs(j,accounts);
                }
            }
        }
    }

public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        // 构建 email_to_idx 映射
        for(int i = 0;i<accounts.size();i++){
            for(int j = 1;j<accounts[i].size();j++){
                email_to_idx[accounts[i][j]].push_back(i);
            }
        }

        vector<vector<string>>result;
        // 新增的元素将被初始化为 0
        vis.resize(accounts.size());

        // 遍历所有账户
        for(int i = 0;i<vis.size();i++){
            if(vis[i]){
                continue;
            }
            email_set.clear();
            dfs(i,accounts);
            vector<string>res = {accounts[i][0]};
            res.insert(res.end(),email_set.begin(),email_set.end());
            sort(res.begin()+1,res.end());
            result.push_back(res);

        }
        return result;
    }
};
```

### 阈值距离内邻居最少的城市

**递归 + 记录返回值 = 记忆化搜索**

```cpp
class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        //递归更新的时候肯定会把对应的无穷大值舍去
        //二位矩阵的值保存i，j之间的距离
        vector<vector<int>>w(n,vector<int>(n,INT_MAX/2));
        for(auto &e:edges){
            int x = e[0],y = e[1],wt = e[2];
            w[x][y] = w[y][x] = wt;
        }
        //记忆化搜索，在本题可初始化为0
        vector<vector<vector<int>>>memo(n,vector<vector<int>>(n,vector<int>(n)));
        function<int(int,int,int)>dfs = [&](int k,int i,int j)->int{
            //k<0意味着，节点之间的值都小于0，说明i，j之间没有节点，k=0说明还有一个0号节点夹在二者中间
            if(k<0){
                return w[i][j];
            }
            //这里的引用只是为了节省代码
            auto& res = memo[k][i][j];
            //记忆化搜索防止重复计算
            if(res){
                return res;
            }
            //返回不选k和选k的最小值
            return res = min(dfs(k-1,i,j),dfs(k-1,i,k)+dfs(k-1,k,j));
        };

        int ans = 0;//保存答案
        int min_cnt = n;//初始化为最大节点
        for(int i = 0;i<n;i++){
            int cnt = 0;
            for(int j = 0;j<n;j++){
                //任何一个节点到其余的节点开始遍历
                if(j!=i&&dfs(n-1,i,j)<=distanceThreshold){
                    cnt++;
                }
            }
            //更新答案
            if(cnt<=min_cnt){
                min_cnt = cnt;
                ans = i;
            }
        }
        //通过递归分解子问题+记忆化搜索大大缩减了复杂度
        return ans;
    }
};
```

### 图论理论基础

图的种类：

- 有向图
- 无向图
- 加权有向图
- 加权无向图

度：

- 无向图：几条边就有几度
- 有向图：
  - 出度：从该节点出发的边的个数
  - 入肚：指向该节点边的个数

连通性：

- 无向连通图：任何两个节点都是可以到达的
- 有向连通图(强连通)

图的构造：

- 邻接矩阵：邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组

  缺点：遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费

- 邻接表：邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。

DFS：

```cpp
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

BFS:

```CPP
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
```

#### 岛屿数量

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int n,m;
vector<vector<int>>grids;
vector<vector<bool>>visited;
int ans = 0;
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
void bfs(int x,int y){
    std::queue<pair<int,int>> que;
    que.push({x,y});
    visited[x][y] = true;
    while(!que.empty()){
        pair<int,int> cur = que.front();que.pop();
        for(int i = 0;i<4;i++){
            int nextx = cur.first+dir[i][0];
            int nexty = cur.second+dir[i][1];
            if(nexty>=m||nexty<0||nextx<0||nextx>=n||visited[nextx][nexty]||grids[nextx][nexty]==0)continue;
            que.push({nextx,nexty});
            visited[nextx][nexty] = true;
        }
    }
    ans++;
}
int main(){
    cin>>n>>m;
    grids = vector<vector<int>>(n,vector<int>(m,0));
    visited = vector<vector<bool>>(n,vector<bool>(m,false));
    for(int i = 0;i<n;i++){
        for(int j = 0;j<m;j++){
            cin>>grids[i][j];
        }
    }
    for(int i = 0;i<n;i++){
        for(int j = 0;j<m;j++){
            if(grids[i][j]==1&&!visited[i][j]){
                bfs(i,j);
            }
        }
    }
    cout<<ans<<endl;
    
}
```

#### 网络延迟时间

```cpp
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<vector<pair<int,int>>>g(n);
        for(auto& t:times){
            g[t[0]-1].emplace_back(t[1]-1,t[2]);
        }
        vector<int>dis(n,INT_MAX);
        dis[k-1] = 0;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>>pq;
        pq.emplace(0,k-1);
        while(!pq.empty()){
            auto [dx,x] = pq.top();
            pq.pop();
            if(dx>dis[x]){
                continue;
            }
            for(auto&[y,d]:g[x]){
                int new_dis = dx+d;
                if(new_dis<dis[y]){
                    dis[y] = new_dis;
                    pq.emplace(new_dis,y);
                }
            }
        }
        int mx = ranges::max(dis);
        return mx<INT_MAX?mx:-1;
    }
};
```

