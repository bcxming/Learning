## 二叉树

### 二叉树的最大深度

自己写的递归秒杀

```cpp
int maxDepth(TreeNode* root) {
    if(root==nullptr)return 0;
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    return max(left,right)+1;
}
```

### 翻转二叉树

自己写的

```cpp
TreeNode* invertTree(TreeNode* root) {
    if(root==nullptr)return root;
    swap(root->left,root->right);
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

### 对称二叉树

如果直接用层序遍历，那么放在队列中的节点不易比较，因此需要按照比较的顺序将其放进去

### 二叉树的直径

树形DP：我们定义一个递归函数 dfs，递归搜索每个节点max(ans,left+right+1）并设一个全局变量 ans 记录最大值，最后返回 ans-1 即为树的直径。

```cpp
class Solution {
private:
    int ans;
    int dfs(TreeNode* root){
        if(root==nullptr)return 0;
        int left = dfs(root->left);
        int right = dfs(root->right);
        ans = max(ans,left+right+1);
        return max(left,right)+1;
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 0;
        dfs(root);
        return ans-1;
    }
};
```



## 图论

### 岛屿数量

要么修改岛屿中的数字，要么用额外的布尔空间去记录是否被访问

### 腐烂的橘子

1、知道要用BFS，但是没想起来用队列加入所有的腐烂橘子

2、和二叉树的层序遍历很像

```cpp
int orangesRotting(vector<vector<int>>& grid) {
    int row = grid.size();
    int col = grid[0].size();
    int time = 0;
    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    queue<tuple<int,int>>que;
    for(int i = 0;i<row;++i){
        for(int j = 0;j<col;++j){
            if(grid[i][j]==2){
                que.push({i,j});
            }
        }
    }
    while(!que.empty()){
        int size = que.size();
        bool changed = false;
        for(int k = 0;k<size;++k){
            auto [i,j] = que.front();
            que.pop();
            for(auto [di,dj]:directions){
                if(i+di>=0&&i+di<row&&j+dj>=0&&j+dj<col&&grid[i+di][j+dj]==1){
                    grid[i+di][j+dj] = 2;
                    que.push({i+di,j+dj});
                    changed = true;
                }
            }
        }
        if(changed)time++;
    }
    for(const auto& r:grid){
        if(find(r.begin(),r.end(),1)!=r.end()){
            return -1;
        }
    }
    return time;
}
```

```cpp
//tuple用法
std::tuple<int, std::string, double> myTuple = {1, "Hello", 3.14};
// 使用 std::get
std::cout << "First: " << std::get<0>(myTuple) 
<< ", Second: " << std::get<1>(myTuple)
<< ", Third: " << std::get<2>(myTuple) << std::endl;
```

### 课程表

拓扑排序

```cpp
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int>indegree(numCourses,0);
    map<int,vector<int>>mymap;
    //先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
    for(int i = 0;i<prerequisites.size();++i){
        indegree[prerequisites[i][0]]++;//记录课程0入度
        //把课程1对应的节点记录下来
        mymap[prerequisites[i][1]].push_back(prerequisites[i][0]);
    }
    queue<int>que;
    for(int i = 0;i<indegree.size();i++){
        if(indegree[i]==0)que.push(i);
    }
    while(!que.empty()){
        int node = que.front();que.pop();
        numCourses--;
        for(int i = 0;i<mymap[node].size();++i){
            indegree[mymap[node][i]]--;
            if(indegree[mymap[node][i]]==0){
                que.push(mymap[node][i]);
            }
        }
    }
    return numCourses==0;
}
```

### 前缀树

Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。

查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。

Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m的n次方)

```cpp
class Trie {
private:
  bool isEnd;
  Trie* next[26];
public:
Trie() {
    isEnd = false;
    memset(next,0,sizeof(next));
}

void insert(string word) {
    Trie* node = this;
    for(char& c:word){
        if(node->next[c-'a']==nullptr){
            node->next[c-'a'] = new Trie();
        }
        node = node->next[c-'a'];
    }
    node->isEnd = true;
}

bool search(string word) {
    Trie* node = this;
    for(char& c:word){
        node = node->next[c-'a'];
        if(node==nullptr){
            return false;
        }
    }
    return node->isEnd;
}

bool startsWith(string prefix) {
    Trie* node = this;
    for(char& c:prefix){
        node = node->next[c-'a'];
        if(node==nullptr){
            return false;
        }
    }
    return true;
}
};
```

## 回溯

### 全排列

简单的回溯，但是用到了辅助树组来记录是否被访问

## 二分查找

### 搜索插入位置

闭区间分情况考虑写代码：

1、都小于返回0

2、都大于返回数组长度

3、在中间返回看left和right如何移动

### 搜索二维矩阵

就是从左下角开始搜索

## 栈

### 有效的括号

遇到（，就插入），方便弹出的时候进行比较，同时注意栈为空的情况

## 堆

### 手写堆

### 数组中的第k个最大元素

改进版快排能做到0(n),如果基于堆，那么平均复杂度就是0(logn)

```cpp
int findKthLargest(vector<int>& nums, int k) {
    return quickSelect(nums,k);
}
int quickSelect(vector<int>& nums,int k){
  //增加算法稳定性 0(n)，0（logn）
    int pivot = nums[rand()%nums.size()];
    vector<int>big,equal,small;
    for(int& num:nums){
        if(num>pivot)big.push_back(num);
        else if(num<pivot)small.push_back(num);
        else equal.push_back(num);
    }
  //下面的if语句，你把num想象成三段就能理解为啥这样书写逻辑了
    if(k<=big.size())return quickSelect(big,k);
    if(nums.size()-small.size()<k)return quickSelect(small,k-nums.size()+small.size());
    return pivot;
}
```

## 贪心

### 买卖股票的最佳时机

约等于从一个数组中找出相差最大的值

## 技巧

### 只出现一次的数字

异或：两个相同数字异或为0

异或满足交换律和结合律，A异或0等于A

```cpp
int singleNumber(vector<int>& nums) {
    int x = 0;
    for(int i = 0;i<nums.size();++i){
        x ^= nums[i];
    }
    return x;
}
```

### 多数元素

哈希表、数组排序、摩尔投票

1、初始化： 票数统计 votes = 0 ， 众数 x。
2、循环： 遍历数组 nums 中的每个数字 num 。
3、当 票数 votes 等于 0 ，则假设当前数字 num 是众数。
4、当 num = x 时，票数 votes 自增 1 ；当 num != x 时，票数 votes 自减 1 。
5、返回值： 返回 x 即可。

```cpp
int majorityElement(vector<int>& nums) {
    int vote = 0;
    int result = 0;
    for(auto& num:nums){
        if(vote==0||num==result){
            result = num;
            vote++;
        }else{
            vote--;
        }
    }
    return result;
}
```

### 颜色分类

**循环不变量** 简单说就是在循环的过程中保持不变的性质，这个性质是人为根据需要解决的任务定义的。

**整体思路**：使用三路快排的思想，将数组分成三部分，小于1的部分、等于1的部分和大于1的部分。

**变量定义**：

- `zero`：用于标记0应该放置的位置。
- `two`：用于标记2应该放置的位置，从数组末尾开始。
- `i`：当前扫描的位置。

**算法流程**：

1. 当 `nums[i] == 0` 时，将其与 `nums[zero]` 交换，并将 `zero` 和 `i` 都加1。
2. 当 `nums[i] == 1` 时，直接跳过，即 `i++`。
3. 当 `nums[i] == 2` 时，将其与 `nums[two-1]` 交换，并将 `two` 减1，但 `i` 不变，以便重新检查新换过来的值。

```cpp
void sortColors(vector<int>& nums) {
    int size = nums.size();
    if(size<2)return;
    int zero = 0;//0结束的位置
    int two = size;//2结束的位置
    int i = 0;
    while(i<two){
        if(nums[i]==0){
            swap(nums[zero],nums[i]);
            zero++;
            i++;
        }else if(nums[i]==1){
            i++;
        }else{
            two--;
            swap(nums[i],nums[two]);
        }
    }
}
```

