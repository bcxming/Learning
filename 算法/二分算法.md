灵神题单：[二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)

## 题单

### 排序

**归并排序**

[LCR 077. 排序链表](https://leetcode.cn/problems/7WHec2/)  归并排序+寻找链表中点+合并两个排序链表

**堆排序**

**快速排序**

## 排序

### 归并排序

[LCR 077. 排序链表](https://leetcode.cn/problems/7WHec2/)

O(nlogn)的算法有快排、归并和堆排序，链表不支持随机访问，所以用归并

自底向上可以到O1的额外空间，自顶向下要Olog(N)

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // 如果链表为空，直接返回
        if (head == nullptr) {
            return head;
        }

        // 计算链表的长度
        int length = 0;
        ListNode* node = head;
        while (node) {
            length++;
            node = node->next;
        }

        // 创建一个虚拟头结点，方便操作
        ListNode* dummy = new ListNode(0, head);

        // 每轮分割的子链表长度
        for (int sublength = 1; sublength < length; sublength *= 2) {
            ListNode* pre = dummy; // 用于记录合并后链表的尾部
            ListNode* cur = dummy->next; // 当前处理的节点

            // 遍历整个链表
            while (cur) {
                ListNode* head1 = cur; // 第一段链表的头结点
                // 分割第一段链表
                for (int i = 1; i < sublength && cur->next != nullptr; i++) {
                    cur = cur->next;
                }
                ListNode* head2 = cur->next; // 第二段链表的头结点
                cur->next = nullptr; // 断开第一段链表
                cur = head2; // 更新 cur 为第二段链表的头结点

                // 分割第二段链表
                for (int i = 1; i < sublength && cur != nullptr && cur->next != nullptr; i++) {
                    cur = cur->next;
                }
                ListNode* next = nullptr;
                if (cur) {
                    next = cur->next; // 记录下一轮待处理的节点
                    cur->next = nullptr; // 断开第二段链表
                }

                // 合并两段链表
                ListNode* merged = merge(head1, head2);
                pre->next = merged;
                while (pre->next != nullptr) {
                    pre = pre->next; // 移动 pre 到合并后链表的尾部
                }
                cur = next; // 更新 cur 为下一轮待处理的节点
            }
        }

        // 返回排序后的链表
        ListNode* result = dummy->next;
        delete dummy; // 释放虚拟头结点
        return result;
    }

    ListNode* merge(ListNode* head1, ListNode* head2) {
        // 创建一个虚拟头结点，方便操作
        ListNode* dummy = new ListNode(0);
        ListNode* temp = dummy;

        // 合并两个有序链表
        while (head1 && head2) {
            if (head1->val <= head2->val) {
                temp->next = head1;
                head1 = head1->next;
            } else {
                temp->next = head2;
                head2 = head2->next;
            }
            temp = temp->next;
        }

        // 连接剩余部分
        if (head1) {
            temp->next = head1;
        }
        if (head2) {
            temp->next = head2;
        }

        // 返回合并后的链表
        ListNode* result = dummy->next;
        delete dummy; // 释放虚拟头结点
        return result;
    }
};
```

