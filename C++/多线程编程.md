### C++中的线程库

C++11标准引入了`<thread>`头文件，提供了一个标准的线程库。这个库让创建和管理线程变得更加容易，同时提供了与线程相关的同步机制，如互斥锁（`mutex`）和条件变量（`condition_variable`）

### 创建和管理线程

要在C++中创建一个线程，可以使用`std::thread`类。下面是一个简单的示例：

```cpp
#include <iostream>
#include <thread>

void hello() {
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    std::thread t(hello);  // 创建一个线程，并执行hello函数
    t.join();  // 等待线程t完成
    return 0;
}
```

在这个例子中，我们创建了一个线程`t`，它会执行`hello`函数。`t.join()`确保主线程等待子线程完成后再继续执行。

- **不调用`join()`**：可能导致子线程未被正确结束，从而导致资源泄露或未定义行为。
- **不调用`detach()`**：线程将保持关联状态，必须显式地调用`join()`来等待线程结束。

### 怎么给std::thread传递参数

**使用 Lambda 表达式**

使用 Lambda 表达式可以直接捕获外部作用域的变量，并将其作为参数传递给线程函数。例如：

```cpp
#include <iostream>
#include <thread>

void threadFunction(int a, const std::string& str) {
    std::cout << "Thread function: a = " << a << ", str = " << str << std::endl;
}

int main() {
    int a = 42;
    std::string message = "Hello from main!";

    std::thread t([a, message]() {
        threadFunction(a, message);
    });

    t.join();

    return 0;
}
```

在这个示例中，Lambda 表达式 `[a, message]()` 捕获了 `main` 函数中的 `a` 和 `message` 变量，并将它们作为参数传递给 `threadFunction` 函数。

**使用 `std::bind` 绑定函数**

可以使用 `std::bind` 函数来绑定函数和其参数，创建一个可调用对象，然后将其传递给 `std::thread` 构造函数。例如：

```cpp
#include <iostream>
#include <thread>
#include <functional>

void threadFunction(int a, const std::string& str) {
    std::cout << "Thread function: a = " << a << ", str = " << str << std::endl;
}

int main() {
    int a = 42;
    std::string message = "Hello from main!";

    auto boundFunction = std::bind(threadFunction, a, message);
    std::thread t(boundFunction);

    t.join();

    return 0;
}
```

**使用 `std::ref` 传递引用**

如果需要将引用传递给线程函数，可以使用 `std::ref` 来传递引用。例如：

```cpp
#include <iostream>
#include <thread>
#include <functional>

void threadFunction(int& a) {
    a += 10;
}

int main() {
    int a = 42;

    std::thread t(threadFunction, std::ref(a));
    t.join();

    std::cout << "After thread execution, a = " << a << std::endl;

    return 0;
}
```

在这个例子中，`std::ref(a)` 将 `a` 的引用传递给 `threadFunction`。

**使用 `std::move` 传递移动语义的参数**

如果需要将一个移动语义的参数传递给线程函数，可以使用 `std::move`。例如：

```cpp
#include <iostream>
#include <thread>
#include <string>

void threadFunction(std::string message) {
    std::cout << "Thread function: message = " << message << std::endl;
}

int main() {
    std::string message = "Hello from main!";

    std::thread t(threadFunction, std::move(message));
    t.join();

    // 此时 message 可能已经被移动，不再有效,会输出为空，且弹出警告
    // std::cout << "After thread execution, message = " << message << std::endl;

    return 0;
}
```

在这个例子中，`std::move(message)` 将 `message` 的所有权转移给 `threadFunction`。

**为什么这个时候访问message不会报错?**

按照C++的标准，访问已移动的对象是未定义行为（Undefined Behavior, UB）。这意味着编译器和运行时环境可以有不同的行为，甚至可能没有任何明显的错误或警告。

在这个特定的示例中，编译器可能允许你访问 `message`，因为它仍然保留着原始的数据成员，尽管这些成员可能已经被置为默认构造的状态（通常是 `std::string` 的空状态）。这并不意味着访问 `message` 是安全的，而是编译器恰好在这种情况下没有触发任何明显的错误。

**编译器优化**：

- 编译器可能进行了某些优化，使得即使 `message` 被移动后，其内存布局仍然保留着原始数据，但这并不是一种可依赖的行为。

**未定义行为**：

- 访问已移动的对象是未定义行为。这意味着编译器可以做出任何事情，包括但不限于：
  - 允许你访问 `message`，即使它是空的。
  - 抛出异常。
  - 导致程序崩溃。
  - 什么都不做。

**直接值传递示例**

在这个例子中，`std::thread t(threadFunction, a, message);` 直接将 `a` 和 `message` 的值传递给 `threadFunction` 函数。这种方式会复制 `a` 和 `message` 的值到新的线程中，因此在 `threadFunction` 中对这些值的修改不会影响主线程中的 `a` 和 `message`。

```cpp
#include <iostream>
#include <thread>

void threadFunction(int a, const std::string str) {
    std::cout << "Thread function: a = " << a << ", str = " << str << std::endl;
}

int main() {
    int a = 42;
    std::string message = "Hello from main!";

    // 直接传递值给线程函数
    std::thread t(threadFunction, a, message);
    t.join();

    return 0;
}
```

### 数据共享与同步

在多线程程序中，共享数据是常见的需求。然而，如果多个线程同时访问共享数据而没有适当的同步机制，可能会导致数据竞争问题。C++提供了`std::mutex`来保护共享数据。

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;

void print_message(const std::string& message) {
    std::lock_guard<std::mutex> lock(mtx);
    std::cout << message << std::endl;
}

int main() {
    std::thread t1(print_message, "Hello from thread 1");
    std::thread t2(print_message, "Hello from thread 2");

    t1.join();
    t2.join();

    return 0;
}
```

在这个例子中，`std::mutex`保护了`std::cout`，防止多个线程同时写入控制台，导致输出混乱。`std::lock_guard`是一个RAII机制，自动管理互斥锁的加锁和解锁。

**std::unique_lock和std::lock_guard的区别**

`std::lock_guard`是一个非常简单易用的类模板，它在构造时自动锁定互斥锁，在析构时自动释放互斥锁。它主要用于那些不需要额外控制锁的场景。

```cpp
void print_block(char ch, int n) {
    std::lock_guard<std::mutex> lock(mtx);  // 自动锁定和解锁
    for (int i = 0; i < n; ++i) {
        std::cout << ch;
    }
    std::cout << '\n';
}
```

- **自动锁定**：在`std::lock_guard`对象构造时自动锁定互斥锁。

- **自动解锁**：在`std::lock_guard`对象析构时自动释放互斥锁。

- **不可移动**：`std::lock_guard`对象是不可移动的，这意味着你不能将一个`std::lock_guard`对象赋值给另一个`std::lock_guard`对象，也不能使用`std::move`来移动它。

  ```cpp
  std::mutex mtx;
  std::lock_guard<std::mutex> lg1(mtx);  // 锁定 mtx
  std::lock_guard<std::mutex> lg2 = lg1;  // 编译错误：不能赋值给 std::lock_guard
  std::lock_guard<std::mutex> lg3 = std::move(lg1);  // 编译错误：不能移动 std::lock_guard
  ```

- **不可重入**：如果同一个线程试图多次锁定同一个互斥锁，将会抛出异常。

  ```cpp
  std::mutex mtx;
  {
      std::lock_guard<std::mutex> lg(mtx);  // 锁定 mtx
      {
          std::lock_guard<std::mutex> lg(mtx);  // 抛出异常：std::lock_guard 不支持重入
      }
  }
  ```

- **非阻塞**：构造函数总是立即锁定互斥锁，如果无法锁定，则会抛出`std::system_error`异常。

  ```cpp
  std::mutex mtx;
  std::thread t([&](){
      std::lock_guard<std::mutex> lg(mtx);  // 锁定 mtx
  });
  
  // 等待线程开始锁定 mtx
  std::this_thread::sleep_for(std::chrono::milliseconds(100));
  
  try {
      std::lock_guard<std::mutex> lg(mtx);  // 抛出 std::system_error 异常
  } catch (const std::system_error& e) {
      std::cerr << "Caught exception: " << e.what() << std::endl;
  }
  ```

`std::unique_lock`提供了一种更加灵活的方式来管理互斥锁。它允许用户在构造后显式地锁定或解锁互斥锁，还可以转移所有权（移动语义）。

```cpp
void print_block(char ch, int n) {
    std::unique_lock<std::mutex> lock(mtx, std::defer_lock);  // 构造时不锁定
    lock.lock();  // 显式锁定
    for (int i = 0; i < n; ++i) {
        std::cout << ch;
    }
    std::cout << '\n';
    lock.unlock();  // 显式解锁
}
```

- **可选锁定**：可以在构造时不锁定互斥锁，之后再显式锁定。

- **可选解锁**：可以在析构前显式解锁。

- **可移动**：`std::unique_lock`对象是可移动的，这意味着你可以将一个`std::unique_lock`对象赋值给另一个`std::unique_lock`对象，也可以使用`std::move`来移动它。

  ```cpp
  void lock_and_print() {
      std::unique_lock<std::mutex> lock(mtx);  // 锁定 mtx
      std::cout << "Locked mtx." << std::endl;
  }
  
  int main() {
      std::unique_lock<std::mutex> lock1(mtx);  // 锁定 mtx
      std::unique_lock<std::mutex> lock2 = std::move(lock1);  // 移动 lock1 到 lock2
      // lock1 不再持有 mtx 的锁
  
      std::thread t(lock_and_print);  // 试图锁定 mtx，但由于 lock2 正在持有 mtx 的锁，所以会阻塞
  
      t.join();  // 等待线程结束
  
      return 0;
  }
  ```

- **可重入**：支持同一个线程多次锁定同一个互斥锁。

  ```cpp
  void reentrant_lock() {
      std::unique_lock<std::mutex> lock(mtx);  // 锁定 mtx
      std::cout << "First lock acquired." << std::endl;
      lock.lock();  // 再次锁定 mtx
      std::cout << "Second lock acquired." << std::endl;
      lock.unlock();  // 解锁 mtx
      lock.unlock();  // 再次解锁 mtx
  }
  ```

- **阻塞/非阻塞**：可以使用`try_lock()`尝试锁定互斥锁，如果无法锁定则返回`false`，而不是抛出异常。

  ```cpp
  #include <iostream>
  #include <mutex>
  #include <thread>
  
  std::mutex mtx;
  
  void try_lock() {
      std::unique_lock<std::mutex> lock(mtx, std::defer_lock);  // 构造时不锁定
      if (lock.try_lock()) {  // 尝试锁定 mtx
          std::cout << "Lock acquired." << std::endl;
      } else {
          std::cout << "Lock not acquired." << std::endl;
      }
  }
  
  int main() {
      std::thread t1(try_lock);
      std::thread t2(try_lock);
  
      t1.join();
      t2.join();
  
      return 0;
  }
  ```

**std::lock_guard**适用于简单的同步任务，当你只需要在某个作用域内锁定互斥锁并在离开作用域时自动释放锁时，`std::lock_guard`是最简单的选择。

**std::unique_lock**提供了更多的灵活性，可以更好地控制何时锁定和解锁互斥锁，适用于更复杂的同步需求，例如与条件变量一起使用。

**多线程中有哪些锁？**

**读写锁**

- 多个读者可以同时进行读
- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

**互斥锁**

一次只能一个线程拥有互斥锁，其他线程只有等待

**条件变量**

互斥锁是线程间互斥的机制，条件变量则是同步机制

**自旋锁**

进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁

```cpp
std::mutex//互斥锁
std::shared_mutex//读写锁
std::atomic_flag spinlock//自旋锁
```

### 避免死锁

死锁是多线程编程中的一个常见问题，发生在两个或多个线程互相等待对方持有的资源，导致程序陷入僵局。为了避免死锁，可以采取以下几种策略：

- **锁的顺序**：确保所有线程以相同的顺序获取锁。
- **尝试锁**：使用`std::try_lock`尝试获取多个锁，如果失败则释放已获取的锁并重新尝试。
- **锁合并**：使用`std::lock`同时锁定多个互斥量。

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx1, mtx2;

void thread_func1() {
    std::lock(mtx1, mtx2);  // 同时锁定多个互斥量
    std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);
    std::cout << "Thread 1 acquired both locks" << std::endl;
}

void thread_func2() {
    std::lock(mtx1, mtx2);  
    std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);
    std::cout << "Thread 2 acquired both locks" << std::endl;
}

int main() {
    std::thread t1(thread_func1);
    std::thread t2(thread_func2);

    t1.join();
    t2.join();

    return 0;
}
```

在这个例子中，使用`std::lock`避免了死锁的发生，因为它会确保所有锁在同一时间点被获取。

- `std::lock` 可以同时锁定多个互斥锁，并且这些互斥锁是独立锁定的。
- 使用 `std::lock_guard` 和 `std::adopt_lock` 可以采用互斥锁的当前状态，这意味着如果互斥锁已经被锁定，`std::lock_guard` 不会再次尝试锁定互斥锁，而是接管已有的锁定状态。

### 线程的生命周期管理

除了`join`之外，C++中的线程还可以通过`detach`方法进行分离。这意味着线程会在后台运行，主线程无需等待它完成。但需要注意的是，分离线程的生命周期由操作系统管理，因此必须小心资源管理，避免出现未定义行为。

```cpp
#include <iostream>
#include <thread>

void background_task() {
    std::cout << "Background task is running..." << std::endl;
}

int main() {
    std::thread t(background_task);
    t.detach();  // 分离线程
    std::cout << "Main thread continues..." << std::endl;
    return 0;
}
```

在这个例子中，`background_task`在后台执行，而主线程继续执行其它任务。

### 示例

**三个线程依次打印1-100**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
int count = 1;

void printNumber(int threadId) {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [threadId] { return (count % 3) == threadId || count > 100; });

        if (count > 100) {
            cv.notify_all();
            return;
        }

        std::cout << "Thread " << threadId << ": " << count << std::endl;
        count++;
        cv.notify_all();
    }
}

int main() {
    std::thread t1(printNumber, 1);
    std::thread t2(printNumber, 2);
    std::thread t3(printNumber, 0);

    t1.join();
    t2.join();
    t3.join();

    return 0;
}
```

**两个线程交替打印ab**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool isA = true; // 初始时打印 'a'

void printChar(char ch, int count) {
    for (int i = 0; i < count; ++i) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [ch] { return (ch == 'a') ? isA : !isA; }); // 等待条件满足

        std::cout << ch;
        isA = !isA; // 切换到下一个字符
        cv.notify_all(); // 通知其他线程
    }
}

int main() {
    std::thread t1(printChar, 'a', 50); // 打印50个 'a'
    std::thread t2(printChar, 'b', 50); // 打印50个 'b'

    t1.join();
    t2.join();

    std::cout << std::endl;

    return 0;
}
```

**线程池**

```cpp
class ThreadPool {
public:
    ThreadPool(size_t num_threads) : num_threads_(num_threads), stop_(false) {
        for (size_t i = 0; i < num_threads_; ++i) {
            threads_.emplace_back([this] {
                while (true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(mutex_);
                        //使当前线程等待，直到被通知或唤醒
                        //wait() 被调用后，会释放锁，让其他线程能够获得锁并继续执行。等待时，该线程会处于阻塞状态。
                        //condition_.wait_for(),最多等待多久
                        condition_.wait(lock, [this] {
                            return stop_ || !tasks_.empty();
                        });
                        // stop_ 为真（true）,或者 tasks_ 非空,当前线程不需要继续等待
                        if (stop_ && tasks_.empty()) {
                            return;
                        }
                        task = std::move(tasks_.front());
                        tasks_.pop();
                    }
                    task();
                }
            });
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(mutex_);
            stop_ = true;
        }
        condition_.notify_all();
        for (std::thread& thread : threads_) {
            thread.join();
        }
    }

    template <class F>
    void submit(F&& f) {
        {
            std::unique_lock<std::mutex> lock(mutex_);
            tasks_.emplace(std::forward<F>(f));//完美转发
        }
        condition_.notify_one();
    }

private:
    size_t num_threads_;
    std::vector<std::thread> threads_;
    std::queue<std::function<void()>> tasks_;
    std::mutex mutex_;
    std::condition_variable condition_;
    std::atomic<bool> stop_;
};
```

