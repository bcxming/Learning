## 概述

### 七层网络模型

应用层（数据）：HTTP、FTP、DNS、DHCP

表示层：语法问题

会话层：建立通信会话

传输层（段）：UDP、TCP

网络层（包）：IP

数据链路层（帧）：上层数据封装成帧，MAC访问

物理层（比特流）：设备之间

## TCP和UDP

### TCP头部

源端口、目的端口

序列号（乱序）

确认号（丢包）

首部长度（4位）、保留（6位）、控制位（**URG**、**ACK**、**RST**、**SYN**、**FIN**、**PSH**）、窗口（16位）

校验和（CRC算法）、紧急指针（16位）

### TCP如何保证可靠传输?

三次握手

校验和：验证TCP首部和数据在发送过程中没有任何改动

序列号和确认号

流量控制：如果缓冲区大小为0，那么发送方会停止发送数据。并且发送方定期会发送探测报文，来获取缓冲区大小

拥塞控制：慢启动算法、拥塞避免算法、快速重传和快速恢复

超时重传、快速重传

四次挥手

### TCP的拥塞控制？

慢启动：

- 初始化设置 cwnd = 1，并开始传输数据

- 收到ACK，会将 cwnd 加 1
- 当 cwnd >= ssthresh 或发生丢包重传时慢启动结束，进入拥塞避免状态

拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd

拥塞发生：

- 超时重传：ssthresh 设为 cwnd/2，cwnd 重置为 1
- 快速重传：cwnd = cwnd/2 ，ssthresh = cwnd，进入快速恢复

快速恢复：

- 拥塞窗口 cwnd = ssthresh + 3
- 重传丢失的数据包，收到重复的 ACK，那么 cwnd 增加 1
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，进入拥塞避免

### TCP的三次握手？

**第一次握手**

客户端请求建立连接，将首部的SYN标识位置为1，初始化序列号seq=x，发送给服务器，并进入**SYN_SENT**状态，等待服务器确认。

**第二次握手**

服务器接收到SYN后，将首部的SYN和ACK标识位置为1，回复确认ack的值为客户端发送的序列号x+1，同时自己也要初始化一个seq=y，ACK和SYN一起发送客户端，进入**SYN_RECV**状态。

**第三次握手**

客户端收到服务器的SYN和ACK包后，向服务器发送确认包ack，值为服务器的序列号y+1，并且自己的seq为x+1，此包发送完毕，客户端和服务器进入**ESTABLISHED**（TCP连接成功）状态。

### TCP为什么要三次握手？

同步双方序列号和确认服务端和客户端的收发能力都是正常的

### TCP的三次握手丢了？

ACK报文发生了丢包是不会重传的

**第一次丢失：**重传的SYN报文序列号和之前相同，一般5次

**第二次丢失**：客户端和服务端都会重传

**第三次丢失**：服务端收不到ACK会触发超时重传机制，重传 SYN-ACK 报文

### TCP为什么不是两次握手？

首要原因是为了防止旧的重复连接初始化造成混乱

同步双方初始序列号

### TCP的四次挥手？

第一次挥手：首部的FIN标识位置为1，序列号seq=u，客户端进入**FIN_WAIT_1**状态，即便FIN报文不携带数据，也要消耗一个序列号。

第二次挥手：ACK标识位置为1，ack = u+1, seq = v,服务器进入**CLOSE_WAIT关闭等待**状态，客户端进入**FIN_WAIT_2**状态

第三次挥手：FIN标识位置为1，ACK标识位置为1，seq = w，ack = u+1,服务器进入**LAST_ACK**状态

第四次挥手：seq = u+1，ack = w+1，客户端就进入**TIME_WAIT**状态







## IP

## HTTP