# 分布式场景题

### CAP定理

在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终 一致性”，只要这个最终时间是在用户可以接受的范围内即可。

### 分布式服务接口的幂等性如何设计?

幂等性：确保即使同一个操作被执行多次，其结果也不会改变。

关键在于：

- 每个操作都有唯一标识符
- 每次处理这个请求都要记录处理结果
- 执行这个请求之前需要判断之前是否已经被处理过

**数据库约束：**

利用数据库的唯一键约束来防止重复插入。例如，在处理用户注册时，可以使用电子邮件地址作为唯一键，如果插入失败则说明已经存在，不再进行重复操作。

**幂等操作设计：**

确保操作本身具有幂等性。例如，对于“创建”操作可以采用“先查询后创建”的策略，如果记录已存在则不进行重复创建；对于“删除”操作，即使多次删除同一资源，最终状态都是不存在。

**去重缓存：**

在短时间内对同一请求进行去重处理，例如利用Redis等缓存技术，将请求ID存储在缓存中，设置合理的过期时间，若发现相同请求ID则忽略该请求。

### 接口调用如何保证顺序性？

消息队列、多线程可使用内存队列、分布式锁

### 分布式锁使用场景、实现方式？

分布式锁基本条件：

**互斥：**在同一时间只能有一个客户端能持有锁

**高可用：**某些节点出现故障，其他节点依然可以正常获取和释放锁

**高性能：**获取锁和释放锁的操作应该尽可能快，以减少对系统性能的影响

**可重入性**：同一个客户端在持有锁的情况下能够再次获取该锁，而不会导致死锁。

**锁失效机制：**设置超时时间，当超过这个时间后锁会自动释放

**非阻塞特性：**如果无法获取到锁，应立即返回获取失败的结果，而不是一直等待

实现方式

**基于数据库实现分布式锁**

数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

1、数据库必须高可用高性能

2、可重入：需要 在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是 否和当前机器和线程相同，若相同则直接获取锁

3、锁失效：需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据

4、阻塞锁：获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取

**基于缓存redis实现分布式锁**

1、SET lock currentTime+expireTime EX 600 NX，使用set设置lock值，并设置过期时间为600秒，如果成功， 则获取锁;

2、获取锁后，如果该节点掉线，则到过期时间ock值自动失效; 

3、释放锁时，使用del删除lock键值;

主从复制高可用（主从切换丢失数据）、高性能、rdb/aof持久化

**基于Zookeeper实现分布式锁**

1、创建一个目录mylock;

2、线程A想获取锁就在mylock目录下创建临时顺序节点;

3、获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁;

4、线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点;

5、线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

因为需要频繁的创建和删除节点，性能上不如Redis方式

**基于etcd实现分布式锁**

1、在ectd系统里创建一个key

2、如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1

3、如果创建成功，则认为我获得了锁

```go
package main
import (
  "context"
  "fmt"
  "log"
  "time"
  clientv3 "go.etcd.io/etcd/client/v3"
  concurrency "go.etcd.io/etcd/client/v3/concurrency"
)

func main() {
  // 创建etcd客户端
  cli, err := clientv3.New(clientv3.Config{
      Endpoints:   []string{"localhost:2379"},
      DialTimeout: 5 * time.Second,
  })
  if err != nil {
      log.Fatal(err)
  }
  defer cli.Close()// 创建一个新的会话来管理锁
	s1, err := concurrency.NewSession(cli)
	if err != nil {
		log.Fatal(err)
	}
	defer s1.Close()

	// 创建一个分布式锁对象
	mutex := concurrency.NewMutex(s1, "/my-lock/")
	
	// 尝试获取锁
	ctx := context.TODO()
	if err := mutex.Lock(ctx); err != nil {
		log.Fatal(err)
	}

	fmt.Println("Acquired lock")

	// 模拟一些工作
	time.Sleep(2 * time.Second)

	// 释放锁
	if err := mutex.Unlock(ctx); err != nil {
		log.Fatal(err)
	}
	fmt.Println("Released lock")
}
```
### Zookeeper使用场景

分布式协调:系统 A发送个请求到 mq，然后 B 消费了之后处理。那 A系统如何指导 B系统的处理结果?用 zk 就可以实现分布式系统之间的协调工作。A系统 发送请求之后可以在 zk 上对某个节点的值注册个监听器，一旦 B系统处理完了就修改 zk 那个节点的值，A立⻢就可以收到通知

分布式锁

配置中心

### zk和redis各有什么优缺点？

**强一致性需求**：如果你的应用对一致性要求非常高，并且能够容忍一定程度的复杂性，那么ZooKeeper可能更适合你。

**高性能需求**：如果你的应用需要处理大量的并发请求，并且对一致性要求不是极端苛刻，那么Redis可能是一个更好的选择。