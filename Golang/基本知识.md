## 入门

1、布尔型无法参与数值运算，也无法与其他类型进行转换

2、Go语言字符串和C++中string有所不同，其中最大的不同就是Go语言中字符串无法直接通过下标修改每一个字

符元素，只能通过重新构造新的字符串并赋值给原来的字符串变量实现

3、Go语言的字符有以下两种：

一种是uint8类型，或者叫byte类型，代表了一个ASCII码的一个字符。等价于C语言中unsigned char

一种是rune类型，代表UTF-8字符，底层是int32类型。用来处理中文、日文等复合字符。

4、定义方式

```go
var i int = 12    //明确定义i为int类型
var i =  12       //自动识别i为int类型
i := 12           //自动推断变量i为int类型

a, b = b, a   //交换了a和b的值

for i < 19 {  //等价于C语言中的while(i < 19)
    i++
}

//for-range遍历通道
for v := range c {
    fmt.Println(v)    //不断从通道中取数据，直到通道被关闭

```



## 数据类型

### slice

**定义方式**

```go
//一维数组
var str [3]string
var str = [3]string{"hello", "world", ""}
var str = [...]string{"hello", "world", ""}
//二维数组
var arr [3][4]int    //定义三行四列的整型数组
for k, v := range str {
    fmt.Println(k, v)
}

//方式一：从数组生成切片
var a = [...]int{1, 2, 3}
var slice []int = a[1:2]   //从数组a生成切片slice
 
//方式二：从切片生成切片
var a = [...]int{1, 2, 3}
var slice []int = a[0:]
var ss []int = slice[1:2]
 
//方式三：直接声明新的切片
var slice []int
 
//方式四：使用make()函数构造切片
make([]T, size, cap)
//构造一个元素个数为size,容量为cap,类型为T的切片
a := make([]int, 2, 3)
 
//如果你执行 slice[1:4]，那么这个操作会返回从索引 1 开始到索引 3 结束的元素（不包含索引 4 的元素）
//slice[:3] 等同于 slice[0:3]
//slice[2:] 表示从索引 2 开始直到切片结束
//slice[0:0] 返回一个长度为 0 的空切片
 
//append
var slice[] int
slice = append(slice, 3)        //使用append()一次添加一个元素
slice = append(slice, 1, 2, 3)  //使用append()一次添加多个元素
 
team := []string{"pig", "chicken"}
slice = append(slice, team...)  //team后面加上...，表示将team整个添加到slice后面

//切片复制
src := []int{1, 2, 3, 4, 5}
dst := make([]int, len(src)) // 创建一个目标切片，长度与源切片相同
copy(dst, src)               // 将源切片的内容复制到目标切片

//go没有提供直接对切片删除元素的接口，只能通过append实现
seq := []string{"a", "b", "c", "d", "e"}
index := 2
seq = append(seq[:index], seq[index + 1:]...)
```

**nil切片和空切片指向的地址一样吗？**

切片的数据结构

```go
type SliceHeader struct {
 Data uintptr  //引用数组指针地址
 Len  int     // 切片的目前使用长度
 Cap  int     // 切片的容量
}
```

- nil切片和空切片指向的地址不一样。
- nil空切片引用数组指针地址为0（无指向任何实际地址），所有的空切片指向的数组引用地址都是一样的，且固定为一个值

**拷贝大切片一定比小切片代价大吗？**

并不是，所有切片的大小相同；

三个字段:切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字;

所以 拷贝大切片跟小切片的代价应该是一样的。

### string

**字符串转成byte数组，会发生内存拷贝吗？**

严格来说，只要是发生类型强转都会发生内存拷贝

```go
func main() {
 a :="aaa"
 ssh := *(*reflect.StringHeader)(unsafe.Pointer(&a))
 b := *(*[]byte)(unsafe.Pointer(&ssh))  
 fmt.Printf("%v",b)
}
```

`StringHeader` 是`字符串`在go的底层结构

```go
type StringHeader struct {
 Data uintptr
 Len  int
}
```

`SliceHeader` 是`切片`在go的底层结构

```go
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
```

- 1.`unsafe.Pointer(&a)`方法可以得到变量`a`的地址。
- 2.`(*reflect.StringHeader)(unsafe.Pointer(&a))` 可以把字符串a转成底层结构的形式。
- 3.`(*[]byte)(unsafe.Pointer(&ssh))` 可以把ssh底层结构体转成byte的切片的指针。
- 4.再通过 `*`转为指针指向的实际内容。

```go
func BytesToStr(data []byte) string {
	return *(*string)(unsafe.Pointer(&data))
}
func StrToBytes(data string) []byte {
	str := (*reflect.StringHeader)(unsafe.Pointer(&data))
	bs := reflect.SliceHeader{
		Data: str.Data,
		Len:  str.Len,
		Cap:  str.Len,
	}

	return *(*[]byte)(unsafe.Pointer(&bs))
}
```

**翻转含有中文、数字、英文字母的字符串**

```go
func main() {
  src := "你好abc啊哈哈"
  dst := reverse([]rune(src))
}

func reverse(s []rune) []rune {
  for i, j := 0, len(s)-1; i < j; i++, j-- {
  s[i], s[j] = s[j], s[i]
  }
  return s
}
```

`rune`关键字，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），可表示更多的字符



### chan

在Go语言中，`chan`（通道）是一种用于 goroutine 之间通信的机制。通过通道，你可以在线程间发送和接收数据，从而实现并发编程中的同步与协作。

**创建通道**

你可以使用内置的 `make` 函数来创建一个通道：

```go
ch := make(chan int) 
```

这里我们创建了一个传递 `int` 类型的无缓冲通道。

发送和接收数据

- **发送数据**：使用 `<-` 操作符将数据发送到通道。
- **接收数据**：同样使用 `<-` 操作符从通道接收数据。

**缓冲通道**

默认情况下，通道是无缓冲的，这意味着只有当有接收者准备好接收数据时，发送操作才会完成。如果需要，可以创建带缓冲的通道，这样即使没有立即接收者，发送操作也能完成，直到缓冲区满为止。

```go
package main 
import (    
  "fmt" 
) 
func main() {    
  ch := make(chan int, 2)  // 创建一个容量为2的缓冲通道  
  ch <- 1    
  ch <- 2     
  fmt.Println(<-ch)  // 输出: 1    
  fmt.Println(<-ch)  // 输出: 2 
} 
```

**关闭通道**

你可以使用 `close` 函数来关闭通道，表示不再向该通道发送更多的数据。关闭后的通道仍然可以接收剩余的数据，但不能再发送。

**Select语句**

`select` 语句允许一个 goroutine 等待多个通信操作。当其中一个操作完成时，程序就会执行相应的分支。

```go
package main 
import (    
  "fmt"    
  "time" 
) 
func main() {    
  ch1 := make(chan string)    
  ch2 := make(chan string)     
  go func() {        
    time.Sleep(1 * time.Second)        
    ch1 <- "one"    
  }  
  go func() {        
    time.Sleep(2 * time.Second)        
    ch2 <- "two"    
	}
  for i := 0; i < 2; i++ {        
    select {        
      case msg1 := <-ch1:  
      fmt.Println("Received", msg1)        
      case msg2 := <-ch2:   
      fmt.Println("Received", msg2)        
      }    
  } 
} 
```

这个例子展示了如何使用 `select` 语句同时等待两个通道的消息，并根据哪个通道先收到消息来处理不同的情况。

**总结**

- 使用 `make` 函数创建通道。
- 使用 `<-` 操作符发送和接收数据。
- 可以创建带缓冲的通道以支持异步发送。
- 使用 `close` 函数关闭通道。
- 使用 `select` 语句等待多个通道的通信操作。

### map

**定义方式**

```go
//只遍历值
for _, v :range scene {
......
}
 
//只遍历键
for k : range scene {
......
}

delete(map, key)               //从map中删除key的元素
```

使用 `Store` 方法将键值对存储到 `sync.Map` 中：

```go
m.Store("key1", "value1")
m.Store(2, 3.14) // 支持不同类型的键和值
```

使用 `Load` 方法根据键加载对应的值。如果该键存在，则返回值和 true；否则返回 nil 和 false：

```go
if value, ok := m.Load("key1"); ok {
    fmt.Println("key1:", value)
} else {
    fmt.Println("key1 not found")
}
```

使用 `Delete` 方法删除指定键的键值对：

```go
m.Delete("key1")
```

使用 `LoadOrStore` 方法，如果键已存在则返回其对应的值和 true，否则存储新的键值对并返回新值和 false：

```go
value, loaded := m.LoadOrStore("key2", "new_value")
fmt.Println("Value:", value, "Loaded:", loaded)
```

使用 `Range` 方法遍历 `sync.Map` 中的所有键值对。注意：`Range` 的回调函数的参数是键和值，且如果回调函数返回 false 则停止遍历：

```go
m.Range(func(key, value interface{}) bool {
    fmt.Println("Key:", key, "Value:", value)
    return true // 返回 true 继续遍历，返回 false 停止遍历
})
```

### list

**定义方式**

```go
//方式一：通过container/list包的New方法初始化list
l := list.New()
//方式二:通过声明初始化list
var l list.List
 
//在列表中插入元素
l := list.New()
l.PushBack("first")              //从链表尾部插入元素“first”
element := l.PushFront(67)       //从链表头部插入元素67
l.InsertAfter("high", element)   //在element后插入元素
l.InsertBefore("noon", element)  //在element前插入元素
 
//从链表中删除元素
l.Remove(element)
 
//遍历列表
for i := l.Front(); i != nil; i = i.Next() {
    fmt.Println(i.Value)
```



## 高级特性

### 反射

Go 语言中的反射（reflection）是一种强大的编程技术，允许程序在运行时检查和操作对象的类型和值。反射可以用来查看变量的类型信息、动态调用方法以及创建新的实例等。

在 Go 中，反射主要通过 `reflect` 包提供的一组函数和类型来实现。以下是一些基本概念和示例，帮助你理解 Go 的反射机制：

**基本概念**

1. **Type**：表示一个 Go 类型，可以通过 `reflect.TypeOf` 函数获取。
2. **Value**：表示一个 Go 值，可以通过 `reflect.ValueOf` 函数获取。
3. **Kind**：表示具体的类别，比如整数、浮点数、结构体、指针等，可以通过 `Type.Kind` 方法获取。

**获取类型和值**

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
func main() {    
  var x float64 = 3.4    
  fmt.Println("type:", reflect.TypeOf(x))   
  // 输出: type: float64    
  fmt.Println("value:", reflect.ValueOf(x)) 
  // 输出: value: 3.4 
} 
```

**操作值**

通过 `reflect.Value` 可以对值进行各种操作，如修改值、调用方法等。

**修改值**

要修改值，需要传递一个可寻址的变量（通常是指针）。

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
func main() {    
  var x float64 = 3.4    
  p := reflect.ValueOf(&x) // 注意这里传入的是 &x    
  v := p.Elem()        
  if v.CanSet() {        
    v.SetFloat(7.1)    
  }    
  fmt.Println(x) // 输出: 7.1 
} 
```

**动态调用方法**

通过反射，你可以在运行时动态地调用方法。

```go
package main 
import (    
  "fmt"    
  "reflect" 
) 
type MyStruct struct{} 
func (m MyStruct) Hello(name string){ fmt.Println("Hello,", name) 
} 
func main() {    
  m := MyStruct{}    
  v := reflect.ValueOf(m)    
  method := v.MethodByName("Hello")        
  args := []reflect.Value{
    reflect.ValueOf("World")
  }    
  method.Call(args) // 输出: Hello, World 
} 
```

**总结**

- **Type 和 Value**：`reflect.TypeOf` 返回类型信息，`reflect.ValueOf` 返回值信息。
- **修改值**：需要传递指针并使用 `Elem()` 获取实际值，通过 `CanSet` 检查是否可设置。
- **动态调用方法**：使用 `MethodByName` 查找方法，并使用 `Call` 调用。
- **创建新实例**：使用 `reflect.New` 创建类型的新实例。

如果你只需要处理固定类型的数据，并且追求高性能和简洁的代码，那么不使用反射是更好的选择。

如果你需要编写高度通用的代码，并且愿意接受一定的性能损失和复杂度增加，那么反射是一个非常强大的工具。

### context

以下是一些常见的`context`类型及其使用方式：

`context.Background()`：返回一个空的上下文，这个上下文通常在主函数、初始化或测试代码中作为顶级的上下文使用

```go
ctx := context.Background()
```

`context.TODO()`：返回一个空的上下文，但它表示目前还不知道应该使用什么样的上下文。这种情况下可以用`TODO`来占位，将来再替换成具体的上下文

```go
ctx := context.TODO()
```

`context.WithCancel(parent)`：创建一个可取消的上下文，并返回该上下文和一个取消函数。当调用取消函数时，该上下文会发送取消信号给所有基于它衍生的上下文

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel() // 确保在不再需要的时候调用取消函数

go func() {
    select {
    case <-ctx.Done():
        fmt.Println("Context canceled")
    }
}()
```

`context.WithDeadline(parent, deadline)`：创建一个带有截止时间的上下文。如果到了指定的时间点，上下文会自动发送取消信号

```go
deadline := time.Now().Add(5 * time.Second)
ctx, cancel := context.WithDeadline(context.Background(), deadline)
defer cancel()

go func() {
    select {
    case <-ctx.Done():
        fmt.Println("Context deadline exceeded")
    }
}()
```

`context.WithValue(parent, key, value)`：创建一个携带值的上下文，可以将键值对存储在上下文中，以便在不同的Goroutine之间传递数据。注意，`key`应当是一个非导出的、自定义类型，以避免冲突。

```go
type MyKey string
const key MyKey = "myKey"

ctx := context.WithValue(context.Background(), key, "myValue")

go func(ctx context.Context) {
    if val, ok := ctx.Value(key).(string); ok {
        fmt.Println("Value:", val)
    }
}(ctx)
```

## 包

### json

**`json`包里使用的时候，结构体里的变量不加`tag`能不能正常转成`json`里的字段？**

- 如果变量`首字母小写`，则为`private`。无论如何`不能转`，因为取不到`反射信息`。
- 如果变量`首字母大写`，则为`public`。
  - `不加tag`，可以正常转为`json`里的字段，`json`内字段名跟结构体内字段`原名一致`。
  - `加了tag`，从`struct`转`json`的时候，`json`的字段名就是`tag`里的字段名，原字段名已经没用。

```go
type J struct {
    a string             //小写无tag
    b string `json:"B"`  //小写+tag
    C string             //大写无tag
    D string `json:"DD"` //大写+tag
}
//转为json前j结构体的内容 = {a:1 b:2 C:3 D:4}
//转为json后的内容 = {"C":"3","DD":"4"}
```

**`json`包里使用的时候，会结构体里的字段边上加`tag`，有没有什么办法可以获取到这个`tag`的内容呢？**

```go
type J struct {
    a string //小写无tag
    b string `json:"B"` //小写+tag
    C string //大写无tag
    D string `json:"DD" otherTag:"good"` //大写+tag
}
//printTag方法传入的是j的指针
func printTag(stru interface{}) {
  //reflect.TypeOf(stru).Elem()获取指针指向的值对应的结构体内容
    t := reflect.TypeOf(stru).Elem()
    for i := 0; i < t.NumField(); i++ {
        fmt.Printf("结构体内第%v个字段 %v 对应的json tag是 %v , 还有otherTag？ = %v \n", i+1, t.Field(i).Name, t.Field(i).Tag.Get("json"), t.Field(i).Tag.Get("otherTag"))
 }
}
```

