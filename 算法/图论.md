## 基本知识

一般情况，深搜需要二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多

图的构造：

- 邻接矩阵：邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组

  缺点：遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费

- 邻接表：邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表

  ```cpp
   unordered_map<int, vector<int>> adjList; // 邻接表表示图
  ```

**DFS模板**

```cpp
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

**BFS模板**

```cpp
int orangesRotting(vector<vector<int>>& grid) {
    int row = grid.size();
    int col = grid[0].size();
    int time = 0;
    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    queue<tuple<int,int>>que;
    for(int i = 0;i<row;++i){
        for(int j = 0;j<col;++j){
            if(grid[i][j]==2){
                que.push({i,j});
            }
        }
    }
    while(!que.empty()){
        int size = que.size();
        bool changed = false;
        for(int k = 0;k<size;++k){
            auto [i,j] = que.front();
            que.pop();
            for(auto [di,dj]:directions){
                if(i+di>=0&&i+di<row&&j+dj>=0&&j+dj<col&&grid[i+di][j+dj]==1){
                    grid[i+di][j+dj] = 2;
                    que.push({i+di,j+dj});
                    changed = true;
                }
            }
        }
        if(changed)time++;
    }
    for(const auto& r:grid){
        if(find(r.begin(),r.end(),1)!=r.end()){
            return -1;
        }
    }
    return time;
}
```

并查集模板

Floyd 算法

Dijkstra算法

## 题单

**剑指offer得刷**

### DFS

[133. 克隆图 - 力扣（LeetCode）](https://leetcode.cn/problems/clone-graph/) ：哈希表+递归

[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/)

[721. 账户合并](https://leetcode.cn/problems/accounts-merge/) ：连通块+DFS

### BFS

[207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/)

[210. 课程表 II - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-ii/description/)

[310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

### 并查集

[547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)

### Floyd 算法

[1334. 阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/) ：递归 + 记录返回值 = 记忆化搜索

### Dijkstra算法

[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

### 网格图

防止访问重复的：改变数值或者visist数组

怎么进行上下左右的访问：一个是dis数组，一个是dfs(i+1,j)这种

[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

[面试题 16.19. 水域大小](https://leetcode.cn/problems/pond-sizes-lcci/)

[994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

## DFS

[133. 克隆图 - 力扣（LeetCode）](https://leetcode.cn/problems/clone-graph/)

使用DFS进行递归调用，这其中关键点就在于用map来记录老节点和新节点之间的关系，第一次dfs的时候就会一条路走到底

可以画个正方形理解一下

```cpp
class Solution {
private:
    unordered_map<Node*,Node*>vis;
public:
    Node* cloneGraph(Node* node) {
        if(node==nullptr)return node;
        if(vis.find(node)!=vis.end()){
            return vis[node];
        }
        Node* root = new Node(node->val);
        vis[node] = root;
        for(int i = 0;i<node->neighbors.size();i++){
            root->neighbors.emplace_back(cloneGraph(node->neighbors[i]));
        }
        return root;
    }
};
```

[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/)

修改访问过的数据或者用一个二维数组来记录访问过的数据

[721. 账户合并](https://leetcode.cn/problems/accounts-merge/)

<img src="图论.assets/image-20240828142905362.png" alt="image-20240828142905362" style="zoom:25%;" />

思路：通过每个邮箱对应的账户列表，即可把有关联的一次找完

步骤：1、构建邮箱和账户们的映射；2、在DFS中会记录已经访问过的账户，同时收集该账户对应的邮箱地址

如果用上面的图举例，那么就是先访问0，然后遍历johnsmith@mail.com，接着访问2，然后就一直回退到0的john00@mail.com，结束循环

```cpp
class Solution {
private:
    //key 为邮箱地址，value 为这个邮箱对应的账户下标列表。
    unordered_map<string,vector<int>>email_to_idx;
    // 用于收集 DFS 中访问到的邮箱地址
    unordered_set<string>email_set;
    // 标记访问过的账户下标
    vector<int>vis;
    void dfs(int i,vector<vector<string>>& accounts){
        vis[i] = true;
        for(int k = 1;k<accounts[i].size();k++){
            string email = accounts[i][k];
            if(email_set.count(email)){
                continue;
            }
            email_set.insert(email);
            for(int j:email_to_idx[email]){
                if(!vis[j]){
                    dfs(j,accounts);
                }
            }
        }
    }

public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        // 构建 email_to_idx 映射
        for(int i = 0;i<accounts.size();i++){
            for(int j = 1;j<accounts[i].size();j++){
                email_to_idx[accounts[i][j]].push_back(i);
            }
        }

        vector<vector<string>>result;
        // 新增的元素将被初始化为 0
        vis.resize(accounts.size());

        // 遍历所有账户
        for(int i = 0;i<vis.size();i++){
            if(vis[i]){
                continue;
            }
            email_set.clear();
            dfs(i,accounts);
            vector<string>res = {accounts[i][0]};
            res.insert(res.end(),email_set.begin(),email_set.end());
            sort(res.begin()+1,res.end());
            result.push_back(res);

        }
        return result;
    }
};
```



## BFS

[207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/)

拓扑排序的板子题

```cpp
vector<int> indegree(numCourses, 0);//入度
vector<vector<int>> adjacencyList(numCourses);//记录后续课程
queue<int> courseQueue;//入度为0压入队列
```

[210. 课程表 II - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule-ii/description/)

和上一题一样，就是用一个动态数组去保存节点而已

[310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

**<font color='blue'>思路：</font>**树原来是无向图

我的错误思路:我以为要遍历每一个节点然后返回它的BFS最短路径，这样时间复杂度太高了

正确思路：拓扑排序不停的去删掉外围的节点，然后最后只剩下一个或两个节点就是答案，因为如果有三个节点，那么就有一个节点的入度是2，树的高度又要更上一层楼

```cpp
vector<int>ans;
while(!que.empty()){
    ans.clear();
    for(int i = que.size();i>0;--i){
        int a = que.front();
        que.pop();
        ans.push_back(a);
        for(int b : g[a]){
            if(--degree[b]==1){
                que.push(b);
            }
        }
    }
}
```

## 并查集

[547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)

并查集模板

```cpp
class Solution {
public:
    vector<int> father;

    int find(int u) {
        return u == father[u] ? u : find(father[u]);
    }

    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return;
        father[v] = u;
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        father = vector<int>(n);

        // 初始化 father 数组
        for (int i = 0; i < n; i++) {
            father[i] = i;
        }

        // 遍历 isConnected，进行合并操作
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    join(i, j);
                }
            }
        }

        // 计算圈子数量
        int result = 0;
        for (int i = 0; i < n; i++) {
            if (father[i] == i) {
                result++;
            }
        }

        return result;
    }
};
```

## 网格图

[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

经典板子题

```cpp
ans += dfs(grid,i-1,j);
ans += dfs(grid,i+1,j);
ans += dfs(grid,i,j+1);
ans += dfs(grid,i,j-1);
```

[面试题 16.19. 水域大小](https://leetcode.cn/problems/pond-sizes-lcci/)

```cpp
class Solution {
private:
    vector<vector<bool>>visited;
    int dfs(vector<vector<int>>& land,int i,int j){
        if(i<0||i>=land.size()||j<0||j>=land[0].size()||land[i][j]!=0||visited[i][j])return 0;
        int ans = 1;
        visited[i][j] = true;
        ans += dfs(land,i,j+1);
        ans += dfs(land,i,j-1);
        ans += dfs(land,i+1,j);
        ans += dfs(land,i-1,j);
        ans += dfs(land,i+1,j+1);
        ans += dfs(land,i-1,j-1);
        ans += dfs(land,i-1,j+1);
        ans += dfs(land,i+1,j-1);
        return ans;
    }
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        int m = land.size();
        int n = land[0].size();
        visited = vector<vector<bool>>(m,vector<bool>(n,false));
        vector<int>result;
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(land[i][j]==0){
                    int temp = dfs(land,i,j);
                    if(temp>0)result.push_back(temp);
                }
            }
        }
        sort(result.begin(),result.end());
        return result;
    }
};
```

[994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

没有bug一口气写出来还是有点难度的

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int row = grid.size();
        int col = grid[0].size();
        int time = 0;
        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        queue<tuple<int,int>>que;
        for(int i = 0;i<row;++i){
            for(int j = 0;j<col;++j){
                if(grid[i][j]==2){
                    que.push({i,j});
                }
            }
        }
        while(!que.empty()){
            int size = que.size();
            bool changed = false;
            for(int k = 0;k<size;++k){
                auto [i,j] = que.front();
                que.pop();
                for(auto [di,dj]:directions){
                    if(i+di>=0&&i+di<row&&j+dj>=0&&j+dj<col&&grid[i+di][j+dj]==1){
                        grid[i+di][j+dj] = 2;
                        que.push({i+di,j+dj});
                        changed = true;
                    }
                }
            }
            if(changed)time++;
        }
        for(const auto& r:grid){
            if(find(r.begin(),r.end(),1)!=r.end()){
                return -1;
            }
        }
        return time;
    }
};
```

## Floyd 算法

[1334. 阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/) 

<img src="图论.assets/image-20240828145624503.png" alt="image-20240828145624503" style="zoom:33%;" />

定义 dfs(k,i,j) 表示从 i 到 j 的最短路长度，并且这条最短路的中间节点编号都 ≤k。注意中间节点不包含 i 和 j。

```cpp
class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        //递归更新的时候肯定会把对应的无穷大值舍去
        //二位矩阵的值保存i，j之间的距离
        vector<vector<int>>w(n,vector<int>(n,INT_MAX/2));
        for(auto &e:edges){
            int x = e[0],y = e[1],wt = e[2];
            w[x][y] = w[y][x] = wt;
        }
        //记忆化搜索，在本题可初始化为0
        vector<vector<vector<int>>>memo(n,vector<vector<int>>(n,vector<int>(n)));
        function<int(int,int,int)>dfs = [&](int k,int i,int j)->int{
            //k<0意味着，节点之间的值都小于0，说明i，j之间没有节点，k=0说明还有一个0号节点夹在二者中间
            if(k<0){
                return w[i][j];
            }
            //这里的引用只是为了节省代码
            auto& res = memo[k][i][j];
            //记忆化搜索防止重复计算
            if(res){
                return res;
            }
            //返回不选k和选k的最小值
            return res = min(dfs(k-1,i,j),dfs(k-1,i,k)+dfs(k-1,k,j));
        };

        int ans = 0;//保存答案
        int min_cnt = n;//初始化为最大节点
        for(int i = 0;i<n;i++){
            int cnt = 0;
            for(int j = 0;j<n;j++){
                //任何一个节点到其余的节点开始遍历
                if(j!=i&&dfs(n-1,i,j)<=distanceThreshold){
                    cnt++;
                }
            }
            //更新答案
            if(cnt<=min_cnt){
                min_cnt = cnt;
                ans = i;
            }
        }
        //通过递归分解子问题+记忆化搜索大大缩减了复杂度
        return ans;
    }
};
```

## Dijkstra算法

[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

```cpp
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // 创建一个图，g[i]存储节点i的所有邻居及其对应的权重
        vector<vector<pair<int,int>>> g(n);
        
        // 填充图的数据结构，将输入的times转换为邻接表形式
        for(auto& t : times){
            // t[0]-1表示起点，t[1]-1表示终点，t[2]表示边的权重
            g[t[0] - 1].emplace_back(t[1] - 1, t[2]);
        }
        
        // 初始化距离数组dis，初始值为无穷大（INT_MAX）
        vector<int> dis(n, INT_MAX);
        // 起点k-1到自身的距离为0
        dis[k - 1] = 0;
        
        // 优先队列pq，用于Dijkstra算法，按距离从小到大排序
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> pq;
        // 将起点加入优先队列
        pq.emplace(0, k - 1);
        
        // 开始Dijkstra算法
        while(!pq.empty()){
            // 取出当前距离最小的节点dx和该节点编号x
            auto [dx, x] = pq.top();
            pq.pop();
            
            // 如果当前节点的距离已经大于记录的最短距离，则跳过
            //起点的dx = 0，dis【x】 = 0；
            if(dx > dis[x]){
                continue;
            }
            
            // 遍历当前节点的所有邻居
            for(auto& [y, d] : g[x]){
                // 计算新路径的距离
                int new_dis = dx + d;
                // 如果新路径比已知的最短路径更短，则更新并将新的状态加入优先队列
                if(new_dis < dis[y]){
                    dis[y] = new_dis;
                    pq.emplace(new_dis, y);
                }
            }
        }
        
        // 找到所有节点中最大的距离
        int mx = ranges::max(dis);
        // 如果最大距离仍然是无穷大，说明有节点不可达，返回-1；否则返回最大距离
        return mx < INT_MAX ? mx : -1;
    }
};
```



## 真题